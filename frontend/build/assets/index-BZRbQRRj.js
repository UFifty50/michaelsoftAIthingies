(function () { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const r of document.querySelectorAll('link[rel="modulepreload"]')) n(r); new MutationObserver(r => { for (const o of r) if (o.type === "childList") for (const s of o.addedNodes) s.tagName === "LINK" && s.rel === "modulepreload" && n(s) }).observe(document, { childList: !0, subtree: !0 }); function i(r) { const o = {}; return r.integrity && (o.integrity = r.integrity), r.referrerPolicy && (o.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? o.credentials = "include" : r.crossOrigin === "anonymous" ? o.credentials = "omit" : o.credentials = "same-origin", o } function n(r) { if (r.ep) return; r.ep = !0; const o = i(r); fetch(r.href, o) } })(); function lu(t) { return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t } var au = { exports: {} }, Qr = {}, uu = { exports: {} }, M = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Gn = Symbol.for("react.element"), Fh = Symbol.for("react.portal"), Bh = Symbol.for("react.fragment"), jh = Symbol.for("react.strict_mode"), Uh = Symbol.for("react.profiler"), $h = Symbol.for("react.provider"), Jh = Symbol.for("react.context"), Qh = Symbol.for("react.forward_ref"), Zh = Symbol.for("react.suspense"), Yh = Symbol.for("react.memo"), Kh = Symbol.for("react.lazy"), Wl = Symbol.iterator; function Xh(t) { return t === null || typeof t != "object" ? null : (t = Wl && t[Wl] || t["@@iterator"], typeof t == "function" ? t : null) } var du = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, hu = Object.assign, cu = {}; function Hi(t, e, i) { this.props = t, this.context = e, this.refs = cu, this.updater = i || du } Hi.prototype.isReactComponent = {}; Hi.prototype.setState = function (t, e) { if (typeof t != "object" && typeof t != "function" && t != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, t, e, "setState") }; Hi.prototype.forceUpdate = function (t) { this.updater.enqueueForceUpdate(this, t, "forceUpdate") }; function pu() { } pu.prototype = Hi.prototype; function Ms(t, e, i) { this.props = t, this.context = e, this.refs = cu, this.updater = i || du } var bs = Ms.prototype = new pu; bs.constructor = Ms; hu(bs, Hi.prototype); bs.isPureReactComponent = !0; var Hl = Array.isArray, fu = Object.prototype.hasOwnProperty, Ws = { current: null }, mu = { key: !0, ref: !0, __self: !0, __source: !0 }; function vu(t, e, i) { var n, r = {}, o = null, s = null; if (e != null) for (n in e.ref !== void 0 && (s = e.ref), e.key !== void 0 && (o = "" + e.key), e) fu.call(e, n) && !mu.hasOwnProperty(n) && (r[n] = e[n]); var l = arguments.length - 2; if (l === 1) r.children = i; else if (1 < l) { for (var a = Array(l), u = 0; u < l; u++)a[u] = arguments[u + 2]; r.children = a } if (t && t.defaultProps) for (n in l = t.defaultProps, l) r[n] === void 0 && (r[n] = l[n]); return { $$typeof: Gn, type: t, key: o, ref: s, props: r, _owner: Ws.current } } function qh(t, e) { return { $$typeof: Gn, type: t.type, key: e, ref: t.ref, props: t.props, _owner: t._owner } } function Hs(t) { return typeof t == "object" && t !== null && t.$$typeof === Gn } function ec(t) { var e = { "=": "=0", ":": "=2" }; return "$" + t.replace(/[=:]/g, function (i) { return e[i] }) } var Fl = /\/+/g; function fo(t, e) { return typeof t == "object" && t !== null && t.key != null ? ec("" + t.key) : e.toString(36) } function ur(t, e, i, n, r) { var o = typeof t; (o === "undefined" || o === "boolean") && (t = null); var s = !1; if (t === null) s = !0; else switch (o) { case "string": case "number": s = !0; break; case "object": switch (t.$$typeof) { case Gn: case Fh: s = !0 } }if (s) return s = t, r = r(s), t = n === "" ? "." + fo(s, 0) : n, Hl(r) ? (i = "", t != null && (i = t.replace(Fl, "$&/") + "/"), ur(r, e, i, "", function (u) { return u })) : r != null && (Hs(r) && (r = qh(r, i + (!r.key || s && s.key === r.key ? "" : ("" + r.key).replace(Fl, "$&/") + "/") + t)), e.push(r)), 1; if (s = 0, n = n === "" ? "." : n + ":", Hl(t)) for (var l = 0; l < t.length; l++) { o = t[l]; var a = n + fo(o, l); s += ur(o, e, i, a, r) } else if (a = Xh(t), typeof a == "function") for (t = a.call(t), l = 0; !(o = t.next()).done;)o = o.value, a = n + fo(o, l++), s += ur(o, e, i, a, r); else if (o === "object") throw e = String(t), Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead."); return s } function Bn(t, e, i) { if (t == null) return t; var n = [], r = 0; return ur(t, n, "", "", function (o) { return e.call(i, o, r++) }), n } function tc(t) { if (t._status === -1) { var e = t._result; e = e(), e.then(function (i) { (t._status === 0 || t._status === -1) && (t._status = 1, t._result = i) }, function (i) { (t._status === 0 || t._status === -1) && (t._status = 2, t._result = i) }), t._status === -1 && (t._status = 0, t._result = e) } if (t._status === 1) return t._result.default; throw t._result } var Se = { current: null }, dr = { transition: null }, ic = { ReactCurrentDispatcher: Se, ReactCurrentBatchConfig: dr, ReactCurrentOwner: Ws }; M.Children = { map: Bn, forEach: function (t, e, i) { Bn(t, function () { e.apply(this, arguments) }, i) }, count: function (t) { var e = 0; return Bn(t, function () { e++ }), e }, toArray: function (t) { return Bn(t, function (e) { return e }) || [] }, only: function (t) { if (!Hs(t)) throw Error("React.Children.only expected to receive a single React element child."); return t } }; M.Component = Hi; M.Fragment = Bh; M.Profiler = Uh; M.PureComponent = Ms; M.StrictMode = jh; M.Suspense = Zh; M.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ic; M.cloneElement = function (t, e, i) { if (t == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + t + "."); var n = hu({}, t.props), r = t.key, o = t.ref, s = t._owner; if (e != null) { if (e.ref !== void 0 && (o = e.ref, s = Ws.current), e.key !== void 0 && (r = "" + e.key), t.type && t.type.defaultProps) var l = t.type.defaultProps; for (a in e) fu.call(e, a) && !mu.hasOwnProperty(a) && (n[a] = e[a] === void 0 && l !== void 0 ? l[a] : e[a]) } var a = arguments.length - 2; if (a === 1) n.children = i; else if (1 < a) { l = Array(a); for (var u = 0; u < a; u++)l[u] = arguments[u + 2]; n.children = l } return { $$typeof: Gn, type: t.type, key: r, ref: o, props: n, _owner: s } }; M.createContext = function (t) { return t = { $$typeof: Jh, _currentValue: t, _currentValue2: t, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, t.Provider = { $$typeof: $h, _context: t }, t.Consumer = t }; M.createElement = vu; M.createFactory = function (t) { var e = vu.bind(null, t); return e.type = t, e }; M.createRef = function () { return { current: null } }; M.forwardRef = function (t) { return { $$typeof: Qh, render: t } }; M.isValidElement = Hs; M.lazy = function (t) { return { $$typeof: Kh, _payload: { _status: -1, _result: t }, _init: tc } }; M.memo = function (t, e) { return { $$typeof: Yh, type: t, compare: e === void 0 ? null : e } }; M.startTransition = function (t) { var e = dr.transition; dr.transition = {}; try { t() } finally { dr.transition = e } }; M.unstable_act = function () { throw Error("act(...) is not supported in production builds of React.") }; M.useCallback = function (t, e) { return Se.current.useCallback(t, e) }; M.useContext = function (t) { return Se.current.useContext(t) }; M.useDebugValue = function () { }; M.useDeferredValue = function (t) { return Se.current.useDeferredValue(t) }; M.useEffect = function (t, e) { return Se.current.useEffect(t, e) }; M.useId = function () { return Se.current.useId() }; M.useImperativeHandle = function (t, e, i) { return Se.current.useImperativeHandle(t, e, i) }; M.useInsertionEffect = function (t, e) { return Se.current.useInsertionEffect(t, e) }; M.useLayoutEffect = function (t, e) { return Se.current.useLayoutEffect(t, e) }; M.useMemo = function (t, e) { return Se.current.useMemo(t, e) }; M.useReducer = function (t, e, i) { return Se.current.useReducer(t, e, i) }; M.useRef = function (t) { return Se.current.useRef(t) }; M.useState = function (t) { return Se.current.useState(t) }; M.useSyncExternalStore = function (t, e, i) { return Se.current.useSyncExternalStore(t, e, i) }; M.useTransition = function () { return Se.current.useTransition() }; M.version = "18.2.0"; uu.exports = M; var At = uu.exports; const A = lu(At);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var nc = At, rc = Symbol.for("react.element"), oc = Symbol.for("react.fragment"), sc = Object.prototype.hasOwnProperty, lc = nc.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, ac = { key: !0, ref: !0, __self: !0, __source: !0 }; function gu(t, e, i) { var n, r = {}, o = null, s = null; i !== void 0 && (o = "" + i), e.key !== void 0 && (o = "" + e.key), e.ref !== void 0 && (s = e.ref); for (n in e) sc.call(e, n) && !ac.hasOwnProperty(n) && (r[n] = e[n]); if (t && t.defaultProps) for (n in e = t.defaultProps, e) r[n] === void 0 && (r[n] = e[n]); return { $$typeof: rc, type: t, key: o, ref: s, props: r, _owner: lc.current } } Qr.Fragment = oc; Qr.jsx = gu; Qr.jsxs = gu; au.exports = Qr; var ie = au.exports, wu = { exports: {} }, Ge = {}, _u = { exports: {} }, yu = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (t) { function e(P, L) { var T = P.length; P.push(L); e: for (; 0 < T;) { var ee = T - 1 >>> 1, de = P[ee]; if (0 < r(de, L)) P[ee] = L, P[T] = de, T = ee; else break e } } function i(P) { return P.length === 0 ? null : P[0] } function n(P) { if (P.length === 0) return null; var L = P[0], T = P.pop(); if (T !== L) { P[0] = T; e: for (var ee = 0, de = P.length, Hn = de >>> 1; ee < Hn;) { var Qt = 2 * (ee + 1) - 1, po = P[Qt], Zt = Qt + 1, Fn = P[Zt]; if (0 > r(po, T)) Zt < de && 0 > r(Fn, po) ? (P[ee] = Fn, P[Zt] = T, ee = Zt) : (P[ee] = po, P[Qt] = T, ee = Qt); else if (Zt < de && 0 > r(Fn, T)) P[ee] = Fn, P[Zt] = T, ee = Zt; else break e } } return L } function r(P, L) { var T = P.sortIndex - L.sortIndex; return T !== 0 ? T : P.id - L.id } if (typeof performance == "object" && typeof performance.now == "function") { var o = performance; t.unstable_now = function () { return o.now() } } else { var s = Date, l = s.now(); t.unstable_now = function () { return s.now() - l } } var a = [], u = [], m = 1, d = null, c = 3, v = !1, g = !1, w = !1, C = typeof setTimeout == "function" ? setTimeout : null, p = typeof clearTimeout == "function" ? clearTimeout : null, h = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function f(P) { for (var L = i(u); L !== null;) { if (L.callback === null) n(u); else if (L.startTime <= P) n(u), L.sortIndex = L.expirationTime, e(a, L); else break; L = i(u) } } function y(P) { if (w = !1, f(P), !g) if (i(a) !== null) g = !0, B(S); else { var L = i(u); L !== null && ji(y, L.startTime - P) } } function S(P, L) { g = !1, w && (w = !1, p(z), z = -1), v = !0; var T = c; try { for (f(L), d = i(a); d !== null && (!(d.expirationTime > L) || P && !ue());) { var ee = d.callback; if (typeof ee == "function") { d.callback = null, c = d.priorityLevel; var de = ee(d.expirationTime <= L); L = t.unstable_now(), typeof de == "function" ? d.callback = de : d === i(a) && n(a), f(L) } else n(a); d = i(a) } if (d !== null) var Hn = !0; else { var Qt = i(u); Qt !== null && ji(y, Qt.startTime - L), Hn = !1 } return Hn } finally { d = null, c = T, v = !1 } } var E = !1, x = null, z = -1, F = 5, O = -1; function ue() { return !(t.unstable_now() - O < F) } function Me() { if (x !== null) { var P = t.unstable_now(); O = P; var L = !0; try { L = x(!0, P) } finally { L ? N() : (E = !1, x = null) } } else E = !1 } var N; if (typeof h == "function") N = function () { h(Me) }; else if (typeof MessageChannel < "u") { var b = new MessageChannel, R = b.port2; b.port1.onmessage = Me, N = function () { R.postMessage(null) } } else N = function () { C(Me, 0) }; function B(P) { x = P, E || (E = !0, N()) } function ji(P, L) { z = C(function () { P(t.unstable_now()) }, L) } t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function (P) { P.callback = null }, t.unstable_continueExecution = function () { g || v || (g = !0, B(S)) }, t.unstable_forceFrameRate = function (P) { 0 > P || 125 < P ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : F = 0 < P ? Math.floor(1e3 / P) : 5 }, t.unstable_getCurrentPriorityLevel = function () { return c }, t.unstable_getFirstCallbackNode = function () { return i(a) }, t.unstable_next = function (P) { switch (c) { case 1: case 2: case 3: var L = 3; break; default: L = c }var T = c; c = L; try { return P() } finally { c = T } }, t.unstable_pauseExecution = function () { }, t.unstable_requestPaint = function () { }, t.unstable_runWithPriority = function (P, L) { switch (P) { case 1: case 2: case 3: case 4: case 5: break; default: P = 3 }var T = c; c = P; try { return L() } finally { c = T } }, t.unstable_scheduleCallback = function (P, L, T) { var ee = t.unstable_now(); switch (typeof T == "object" && T !== null ? (T = T.delay, T = typeof T == "number" && 0 < T ? ee + T : ee) : T = ee, P) { case 1: var de = -1; break; case 2: de = 250; break; case 5: de = 1073741823; break; case 4: de = 1e4; break; default: de = 5e3 }return de = T + de, P = { id: m++, callback: L, priorityLevel: P, startTime: T, expirationTime: de, sortIndex: -1 }, T > ee ? (P.sortIndex = T, e(u, P), i(a) === null && P === i(u) && (w ? (p(z), z = -1) : w = !0, ji(y, T - ee))) : (P.sortIndex = de, e(a, P), g || v || (g = !0, B(S))), P }, t.unstable_shouldYield = ue, t.unstable_wrapCallback = function (P) { var L = c; return function () { var T = c; c = L; try { return P.apply(this, arguments) } finally { c = T } } } })(yu); _u.exports = yu; var uc = _u.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Du = At, Te = uc; function D(t) { for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, i = 1; i < arguments.length; i++)e += "&args[]=" + encodeURIComponent(arguments[i]); return "Minified React error #" + t + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var Cu = new Set, vn = {}; function ui(t, e) { Li(t, e), Li(t + "Capture", e) } function Li(t, e) { for (vn[t] = e, t = 0; t < e.length; t++)Cu.add(e[t]) } var wt = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Bo = Object.prototype.hasOwnProperty, dc = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, Bl = {}, jl = {}; function hc(t) { return Bo.call(jl, t) ? !0 : Bo.call(Bl, t) ? !1 : dc.test(t) ? jl[t] = !0 : (Bl[t] = !0, !1) } function cc(t, e, i, n) { if (i !== null && i.type === 0) return !1; switch (typeof e) { case "function": case "symbol": return !0; case "boolean": return n ? !1 : i !== null ? !i.acceptsBooleans : (t = t.toLowerCase().slice(0, 5), t !== "data-" && t !== "aria-"); default: return !1 } } function pc(t, e, i, n) { if (e === null || typeof e > "u" || cc(t, e, i, n)) return !0; if (n) return !1; if (i !== null) switch (i.type) { case 3: return !e; case 4: return e === !1; case 5: return isNaN(e); case 6: return isNaN(e) || 1 > e }return !1 } function Ee(t, e, i, n, r, o, s) { this.acceptsBooleans = e === 2 || e === 3 || e === 4, this.attributeName = n, this.attributeNamespace = r, this.mustUseProperty = i, this.propertyName = t, this.type = e, this.sanitizeURL = o, this.removeEmptyString = s } var me = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (t) { me[t] = new Ee(t, 0, !1, t, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (t) { var e = t[0]; me[e] = new Ee(e, 1, !1, t[1], null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (t) { me[t] = new Ee(t, 2, !1, t.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (t) { me[t] = new Ee(t, 2, !1, t, null, !1, !1) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (t) { me[t] = new Ee(t, 3, !1, t.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(function (t) { me[t] = new Ee(t, 3, !0, t, null, !1, !1) });["capture", "download"].forEach(function (t) { me[t] = new Ee(t, 4, !1, t, null, !1, !1) });["cols", "rows", "size", "span"].forEach(function (t) { me[t] = new Ee(t, 6, !1, t, null, !1, !1) });["rowSpan", "start"].forEach(function (t) { me[t] = new Ee(t, 5, !1, t.toLowerCase(), null, !1, !1) }); var Fs = /[\-:]([a-z])/g; function Bs(t) { return t[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (t) { var e = t.replace(Fs, Bs); me[e] = new Ee(e, 1, !1, t, null, !1, !1) }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (t) { var e = t.replace(Fs, Bs); me[e] = new Ee(e, 1, !1, t, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(function (t) { var e = t.replace(Fs, Bs); me[e] = new Ee(e, 1, !1, t, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(function (t) { me[t] = new Ee(t, 1, !1, t.toLowerCase(), null, !1, !1) }); me.xlinkHref = new Ee("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (t) { me[t] = new Ee(t, 1, !1, t.toLowerCase(), null, !0, !0) }); function js(t, e, i, n) { var r = me.hasOwnProperty(e) ? me[e] : null; (r !== null ? r.type !== 0 : n || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (pc(e, i, r, n) && (i = null), n || r === null ? hc(e) && (i === null ? t.removeAttribute(e) : t.setAttribute(e, "" + i)) : r.mustUseProperty ? t[r.propertyName] = i === null ? r.type === 3 ? !1 : "" : i : (e = r.attributeName, n = r.attributeNamespace, i === null ? t.removeAttribute(e) : (r = r.type, i = r === 3 || r === 4 && i === !0 ? "" : "" + i, n ? t.setAttributeNS(n, e, i) : t.setAttribute(e, i)))) } var St = Du.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, jn = Symbol.for("react.element"), mi = Symbol.for("react.portal"), vi = Symbol.for("react.fragment"), Us = Symbol.for("react.strict_mode"), jo = Symbol.for("react.profiler"), Su = Symbol.for("react.provider"), Eu = Symbol.for("react.context"), $s = Symbol.for("react.forward_ref"), Uo = Symbol.for("react.suspense"), $o = Symbol.for("react.suspense_list"), Js = Symbol.for("react.memo"), xt = Symbol.for("react.lazy"), xu = Symbol.for("react.offscreen"), Ul = Symbol.iterator; function Ui(t) { return t === null || typeof t != "object" ? null : (t = Ul && t[Ul] || t["@@iterator"], typeof t == "function" ? t : null) } var K = Object.assign, mo; function tn(t) {
    if (mo === void 0) try { throw Error() } catch (i) { var e = i.stack.trim().match(/\n( *(at )?)/); mo = e && e[1] || "" } return `
`+ mo + t
} var vo = !1; function go(t, e) {
    if (!t || vo) return ""; vo = !0; var i = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (e) if (e = function () { throw Error() }, Object.defineProperty(e.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(e, []) } catch (u) { var n = u } Reflect.construct(t, [], e) } else { try { e.call() } catch (u) { n = u } t.call(e.prototype) } else { try { throw Error() } catch (u) { n = u } t() } } catch (u) {
        if (u && n && typeof u.stack == "string") {
            for (var r = u.stack.split(`
`), o = n.stack.split(`
`), s = r.length - 1, l = o.length - 1; 1 <= s && 0 <= l && r[s] !== o[l];)l--; for (; 1 <= s && 0 <= l; s--, l--)if (r[s] !== o[l]) {
                if (s !== 1 || l !== 1) do if (s--, l--, 0 > l || r[s] !== o[l]) {
                    var a = `
`+ r[s].replace(" at new ", " at "); return t.displayName && a.includes("<anonymous>") && (a = a.replace("<anonymous>", t.displayName)), a
                } while (1 <= s && 0 <= l); break
            }
        }
    } finally { vo = !1, Error.prepareStackTrace = i } return (t = t ? t.displayName || t.name : "") ? tn(t) : ""
} function fc(t) { switch (t.tag) { case 5: return tn(t.type); case 16: return tn("Lazy"); case 13: return tn("Suspense"); case 19: return tn("SuspenseList"); case 0: case 2: case 15: return t = go(t.type, !1), t; case 11: return t = go(t.type.render, !1), t; case 1: return t = go(t.type, !0), t; default: return "" } } function Jo(t) { if (t == null) return null; if (typeof t == "function") return t.displayName || t.name || null; if (typeof t == "string") return t; switch (t) { case vi: return "Fragment"; case mi: return "Portal"; case jo: return "Profiler"; case Us: return "StrictMode"; case Uo: return "Suspense"; case $o: return "SuspenseList" }if (typeof t == "object") switch (t.$$typeof) { case Eu: return (t.displayName || "Context") + ".Consumer"; case Su: return (t._context.displayName || "Context") + ".Provider"; case $s: var e = t.render; return t = t.displayName, t || (t = e.displayName || e.name || "", t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"), t; case Js: return e = t.displayName || null, e !== null ? e : Jo(t.type) || "Memo"; case xt: e = t._payload, t = t._init; try { return Jo(t(e)) } catch { } }return null } function mc(t) { var e = t.type; switch (t.tag) { case 24: return "Cache"; case 9: return (e.displayName || "Context") + ".Consumer"; case 10: return (e._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return t = e.render, t = t.displayName || t.name || "", e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return e; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return Jo(e); case 8: return e === Us ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e }return null } function Bt(t) { switch (typeof t) { case "boolean": case "number": case "string": case "undefined": return t; case "object": return t; default: return "" } } function ku(t) { var e = t.type; return (t = t.nodeName) && t.toLowerCase() === "input" && (e === "checkbox" || e === "radio") } function vc(t) { var e = ku(t) ? "checked" : "value", i = Object.getOwnPropertyDescriptor(t.constructor.prototype, e), n = "" + t[e]; if (!t.hasOwnProperty(e) && typeof i < "u" && typeof i.get == "function" && typeof i.set == "function") { var r = i.get, o = i.set; return Object.defineProperty(t, e, { configurable: !0, get: function () { return r.call(this) }, set: function (s) { n = "" + s, o.call(this, s) } }), Object.defineProperty(t, e, { enumerable: i.enumerable }), { getValue: function () { return n }, setValue: function (s) { n = "" + s }, stopTracking: function () { t._valueTracker = null, delete t[e] } } } } function Un(t) { t._valueTracker || (t._valueTracker = vc(t)) } function Pu(t) { if (!t) return !1; var e = t._valueTracker; if (!e) return !0; var i = e.getValue(), n = ""; return t && (n = ku(t) ? t.checked ? "true" : "false" : t.value), t = n, t !== i ? (e.setValue(t), !0) : !1 } function Dr(t) { if (t = t || (typeof document < "u" ? document : void 0), typeof t > "u") return null; try { return t.activeElement || t.body } catch { return t.body } } function Qo(t, e) { var i = e.checked; return K({}, e, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: i ?? t._wrapperState.initialChecked }) } function $l(t, e) { var i = e.defaultValue == null ? "" : e.defaultValue, n = e.checked != null ? e.checked : e.defaultChecked; i = Bt(e.value != null ? e.value : i), t._wrapperState = { initialChecked: n, initialValue: i, controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null } } function zu(t, e) { e = e.checked, e != null && js(t, "checked", e, !1) } function Zo(t, e) { zu(t, e); var i = Bt(e.value), n = e.type; if (i != null) n === "number" ? (i === 0 && t.value === "" || t.value != i) && (t.value = "" + i) : t.value !== "" + i && (t.value = "" + i); else if (n === "submit" || n === "reset") { t.removeAttribute("value"); return } e.hasOwnProperty("value") ? Yo(t, e.type, i) : e.hasOwnProperty("defaultValue") && Yo(t, e.type, Bt(e.defaultValue)), e.checked == null && e.defaultChecked != null && (t.defaultChecked = !!e.defaultChecked) } function Jl(t, e, i) { if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) { var n = e.type; if (!(n !== "submit" && n !== "reset" || e.value !== void 0 && e.value !== null)) return; e = "" + t._wrapperState.initialValue, i || e === t.value || (t.value = e), t.defaultValue = e } i = t.name, i !== "" && (t.name = ""), t.defaultChecked = !!t._wrapperState.initialChecked, i !== "" && (t.name = i) } function Yo(t, e, i) { (e !== "number" || Dr(t.ownerDocument) !== t) && (i == null ? t.defaultValue = "" + t._wrapperState.initialValue : t.defaultValue !== "" + i && (t.defaultValue = "" + i)) } var nn = Array.isArray; function Pi(t, e, i, n) { if (t = t.options, e) { e = {}; for (var r = 0; r < i.length; r++)e["$" + i[r]] = !0; for (i = 0; i < t.length; i++)r = e.hasOwnProperty("$" + t[i].value), t[i].selected !== r && (t[i].selected = r), r && n && (t[i].defaultSelected = !0) } else { for (i = "" + Bt(i), e = null, r = 0; r < t.length; r++) { if (t[r].value === i) { t[r].selected = !0, n && (t[r].defaultSelected = !0); return } e !== null || t[r].disabled || (e = t[r]) } e !== null && (e.selected = !0) } } function Ko(t, e) { if (e.dangerouslySetInnerHTML != null) throw Error(D(91)); return K({}, e, { value: void 0, defaultValue: void 0, children: "" + t._wrapperState.initialValue }) } function Ql(t, e) { var i = e.value; if (i == null) { if (i = e.children, e = e.defaultValue, i != null) { if (e != null) throw Error(D(92)); if (nn(i)) { if (1 < i.length) throw Error(D(93)); i = i[0] } e = i } e == null && (e = ""), i = e } t._wrapperState = { initialValue: Bt(i) } } function Au(t, e) { var i = Bt(e.value), n = Bt(e.defaultValue); i != null && (i = "" + i, i !== t.value && (t.value = i), e.defaultValue == null && t.defaultValue !== i && (t.defaultValue = i)), n != null && (t.defaultValue = "" + n) } function Zl(t) { var e = t.textContent; e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e) } function Iu(t) { switch (t) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function Xo(t, e) { return t == null || t === "http://www.w3.org/1999/xhtml" ? Iu(e) : t === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : t } var $n, Nu = function (t) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (e, i, n, r) { MSApp.execUnsafeLocalFunction(function () { return t(e, i, n, r) }) } : t }(function (t, e) { if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in t) t.innerHTML = e; else { for ($n = $n || document.createElement("div"), $n.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>", e = $n.firstChild; t.firstChild;)t.removeChild(t.firstChild); for (; e.firstChild;)t.appendChild(e.firstChild) } }); function gn(t, e) { if (e) { var i = t.firstChild; if (i && i === t.lastChild && i.nodeType === 3) { i.nodeValue = e; return } } t.textContent = e } var sn = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, gc = ["Webkit", "ms", "Moz", "O"]; Object.keys(sn).forEach(function (t) { gc.forEach(function (e) { e = e + t.charAt(0).toUpperCase() + t.substring(1), sn[e] = sn[t] }) }); function Ou(t, e, i) { return e == null || typeof e == "boolean" || e === "" ? "" : i || typeof e != "number" || e === 0 || sn.hasOwnProperty(t) && sn[t] ? ("" + e).trim() : e + "px" } function Lu(t, e) { t = t.style; for (var i in e) if (e.hasOwnProperty(i)) { var n = i.indexOf("--") === 0, r = Ou(i, e[i], n); i === "float" && (i = "cssFloat"), n ? t.setProperty(i, r) : t[i] = r } } var wc = K({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function qo(t, e) { if (e) { if (wc[t] && (e.children != null || e.dangerouslySetInnerHTML != null)) throw Error(D(137, t)); if (e.dangerouslySetInnerHTML != null) { if (e.children != null) throw Error(D(60)); if (typeof e.dangerouslySetInnerHTML != "object" || !("__html" in e.dangerouslySetInnerHTML)) throw Error(D(61)) } if (e.style != null && typeof e.style != "object") throw Error(D(62)) } } function es(t, e) { if (t.indexOf("-") === -1) return typeof e.is == "string"; switch (t) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var ts = null; function Qs(t) { return t = t.target || t.srcElement || window, t.correspondingUseElement && (t = t.correspondingUseElement), t.nodeType === 3 ? t.parentNode : t } var is = null, zi = null, Ai = null; function Yl(t) { if (t = bn(t)) { if (typeof is != "function") throw Error(D(280)); var e = t.stateNode; e && (e = qr(e), is(t.stateNode, t.type, e)) } } function Ru(t) { zi ? Ai ? Ai.push(t) : Ai = [t] : zi = t } function Tu() { if (zi) { var t = zi, e = Ai; if (Ai = zi = null, Yl(t), e) for (t = 0; t < e.length; t++)Yl(e[t]) } } function Gu(t, e) { return t(e) } function Vu() { } var wo = !1; function Mu(t, e, i) { if (wo) return t(e, i); wo = !0; try { return Gu(t, e, i) } finally { wo = !1, (zi !== null || Ai !== null) && (Vu(), Tu()) } } function wn(t, e) { var i = t.stateNode; if (i === null) return null; var n = qr(i); if (n === null) return null; i = n[e]; e: switch (e) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (n = !n.disabled) || (t = t.type, n = !(t === "button" || t === "input" || t === "select" || t === "textarea")), t = !n; break e; default: t = !1 }if (t) return null; if (i && typeof i != "function") throw Error(D(231, e, typeof i)); return i } var ns = !1; if (wt) try { var $i = {}; Object.defineProperty($i, "passive", { get: function () { ns = !0 } }), window.addEventListener("test", $i, $i), window.removeEventListener("test", $i, $i) } catch { ns = !1 } function _c(t, e, i, n, r, o, s, l, a) { var u = Array.prototype.slice.call(arguments, 3); try { e.apply(i, u) } catch (m) { this.onError(m) } } var ln = !1, Cr = null, Sr = !1, rs = null, yc = { onError: function (t) { ln = !0, Cr = t } }; function Dc(t, e, i, n, r, o, s, l, a) { ln = !1, Cr = null, _c.apply(yc, arguments) } function Cc(t, e, i, n, r, o, s, l, a) { if (Dc.apply(this, arguments), ln) { if (ln) { var u = Cr; ln = !1, Cr = null } else throw Error(D(198)); Sr || (Sr = !0, rs = u) } } function di(t) { var e = t, i = t; if (t.alternate) for (; e.return;)e = e.return; else { t = e; do e = t, e.flags & 4098 && (i = e.return), t = e.return; while (t) } return e.tag === 3 ? i : null } function bu(t) { if (t.tag === 13) { var e = t.memoizedState; if (e === null && (t = t.alternate, t !== null && (e = t.memoizedState)), e !== null) return e.dehydrated } return null } function Kl(t) { if (di(t) !== t) throw Error(D(188)) } function Sc(t) { var e = t.alternate; if (!e) { if (e = di(t), e === null) throw Error(D(188)); return e !== t ? null : t } for (var i = t, n = e; ;) { var r = i.return; if (r === null) break; var o = r.alternate; if (o === null) { if (n = r.return, n !== null) { i = n; continue } break } if (r.child === o.child) { for (o = r.child; o;) { if (o === i) return Kl(r), t; if (o === n) return Kl(r), e; o = o.sibling } throw Error(D(188)) } if (i.return !== n.return) i = r, n = o; else { for (var s = !1, l = r.child; l;) { if (l === i) { s = !0, i = r, n = o; break } if (l === n) { s = !0, n = r, i = o; break } l = l.sibling } if (!s) { for (l = o.child; l;) { if (l === i) { s = !0, i = o, n = r; break } if (l === n) { s = !0, n = o, i = r; break } l = l.sibling } if (!s) throw Error(D(189)) } } if (i.alternate !== n) throw Error(D(190)) } if (i.tag !== 3) throw Error(D(188)); return i.stateNode.current === i ? t : e } function Wu(t) { return t = Sc(t), t !== null ? Hu(t) : null } function Hu(t) { if (t.tag === 5 || t.tag === 6) return t; for (t = t.child; t !== null;) { var e = Hu(t); if (e !== null) return e; t = t.sibling } return null } var Fu = Te.unstable_scheduleCallback, Xl = Te.unstable_cancelCallback, Ec = Te.unstable_shouldYield, xc = Te.unstable_requestPaint, te = Te.unstable_now, kc = Te.unstable_getCurrentPriorityLevel, Zs = Te.unstable_ImmediatePriority, Bu = Te.unstable_UserBlockingPriority, Er = Te.unstable_NormalPriority, Pc = Te.unstable_LowPriority, ju = Te.unstable_IdlePriority, Zr = null, lt = null; function zc(t) { if (lt && typeof lt.onCommitFiberRoot == "function") try { lt.onCommitFiberRoot(Zr, t, void 0, (t.current.flags & 128) === 128) } catch { } } var et = Math.clz32 ? Math.clz32 : Nc, Ac = Math.log, Ic = Math.LN2; function Nc(t) { return t >>>= 0, t === 0 ? 32 : 31 - (Ac(t) / Ic | 0) | 0 } var Jn = 64, Qn = 4194304; function rn(t) { switch (t & -t) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return t & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return t } } function xr(t, e) { var i = t.pendingLanes; if (i === 0) return 0; var n = 0, r = t.suspendedLanes, o = t.pingedLanes, s = i & 268435455; if (s !== 0) { var l = s & ~r; l !== 0 ? n = rn(l) : (o &= s, o !== 0 && (n = rn(o))) } else s = i & ~r, s !== 0 ? n = rn(s) : o !== 0 && (n = rn(o)); if (n === 0) return 0; if (e !== 0 && e !== n && !(e & r) && (r = n & -n, o = e & -e, r >= o || r === 16 && (o & 4194240) !== 0)) return e; if (n & 4 && (n |= i & 16), e = t.entangledLanes, e !== 0) for (t = t.entanglements, e &= n; 0 < e;)i = 31 - et(e), r = 1 << i, n |= t[i], e &= ~r; return n } function Oc(t, e) { switch (t) { case 1: case 2: case 4: return e + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function Lc(t, e) { for (var i = t.suspendedLanes, n = t.pingedLanes, r = t.expirationTimes, o = t.pendingLanes; 0 < o;) { var s = 31 - et(o), l = 1 << s, a = r[s]; a === -1 ? (!(l & i) || l & n) && (r[s] = Oc(l, e)) : a <= e && (t.expiredLanes |= l), o &= ~l } } function os(t) { return t = t.pendingLanes & -1073741825, t !== 0 ? t : t & 1073741824 ? 1073741824 : 0 } function Uu() { var t = Jn; return Jn <<= 1, !(Jn & 4194240) && (Jn = 64), t } function _o(t) { for (var e = [], i = 0; 31 > i; i++)e.push(t); return e } function Vn(t, e, i) { t.pendingLanes |= e, e !== 536870912 && (t.suspendedLanes = 0, t.pingedLanes = 0), t = t.eventTimes, e = 31 - et(e), t[e] = i } function Rc(t, e) { var i = t.pendingLanes & ~e; t.pendingLanes = e, t.suspendedLanes = 0, t.pingedLanes = 0, t.expiredLanes &= e, t.mutableReadLanes &= e, t.entangledLanes &= e, e = t.entanglements; var n = t.eventTimes; for (t = t.expirationTimes; 0 < i;) { var r = 31 - et(i), o = 1 << r; e[r] = 0, n[r] = -1, t[r] = -1, i &= ~o } } function Ys(t, e) { var i = t.entangledLanes |= e; for (t = t.entanglements; i;) { var n = 31 - et(i), r = 1 << n; r & e | t[n] & e && (t[n] |= e), i &= ~r } } var H = 0; function $u(t) { return t &= -t, 1 < t ? 4 < t ? t & 268435455 ? 16 : 536870912 : 4 : 1 } var Ju, Ks, Qu, Zu, Yu, ss = !1, Zn = [], Rt = null, Tt = null, Gt = null, _n = new Map, yn = new Map, Pt = [], Tc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function ql(t, e) { switch (t) { case "focusin": case "focusout": Rt = null; break; case "dragenter": case "dragleave": Tt = null; break; case "mouseover": case "mouseout": Gt = null; break; case "pointerover": case "pointerout": _n.delete(e.pointerId); break; case "gotpointercapture": case "lostpointercapture": yn.delete(e.pointerId) } } function Ji(t, e, i, n, r, o) { return t === null || t.nativeEvent !== o ? (t = { blockedOn: e, domEventName: i, eventSystemFlags: n, nativeEvent: o, targetContainers: [r] }, e !== null && (e = bn(e), e !== null && Ks(e)), t) : (t.eventSystemFlags |= n, e = t.targetContainers, r !== null && e.indexOf(r) === -1 && e.push(r), t) } function Gc(t, e, i, n, r) { switch (e) { case "focusin": return Rt = Ji(Rt, t, e, i, n, r), !0; case "dragenter": return Tt = Ji(Tt, t, e, i, n, r), !0; case "mouseover": return Gt = Ji(Gt, t, e, i, n, r), !0; case "pointerover": var o = r.pointerId; return _n.set(o, Ji(_n.get(o) || null, t, e, i, n, r)), !0; case "gotpointercapture": return o = r.pointerId, yn.set(o, Ji(yn.get(o) || null, t, e, i, n, r)), !0 }return !1 } function Ku(t) { var e = Xt(t.target); if (e !== null) { var i = di(e); if (i !== null) { if (e = i.tag, e === 13) { if (e = bu(i), e !== null) { t.blockedOn = e, Yu(t.priority, function () { Qu(i) }); return } } else if (e === 3 && i.stateNode.current.memoizedState.isDehydrated) { t.blockedOn = i.tag === 3 ? i.stateNode.containerInfo : null; return } } } t.blockedOn = null } function hr(t) { if (t.blockedOn !== null) return !1; for (var e = t.targetContainers; 0 < e.length;) { var i = ls(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent); if (i === null) { i = t.nativeEvent; var n = new i.constructor(i.type, i); ts = n, i.target.dispatchEvent(n), ts = null } else return e = bn(i), e !== null && Ks(e), t.blockedOn = i, !1; e.shift() } return !0 } function ea(t, e, i) { hr(t) && i.delete(e) } function Vc() { ss = !1, Rt !== null && hr(Rt) && (Rt = null), Tt !== null && hr(Tt) && (Tt = null), Gt !== null && hr(Gt) && (Gt = null), _n.forEach(ea), yn.forEach(ea) } function Qi(t, e) { t.blockedOn === e && (t.blockedOn = null, ss || (ss = !0, Te.unstable_scheduleCallback(Te.unstable_NormalPriority, Vc))) } function Dn(t) { function e(r) { return Qi(r, t) } if (0 < Zn.length) { Qi(Zn[0], t); for (var i = 1; i < Zn.length; i++) { var n = Zn[i]; n.blockedOn === t && (n.blockedOn = null) } } for (Rt !== null && Qi(Rt, t), Tt !== null && Qi(Tt, t), Gt !== null && Qi(Gt, t), _n.forEach(e), yn.forEach(e), i = 0; i < Pt.length; i++)n = Pt[i], n.blockedOn === t && (n.blockedOn = null); for (; 0 < Pt.length && (i = Pt[0], i.blockedOn === null);)Ku(i), i.blockedOn === null && Pt.shift() } var Ii = St.ReactCurrentBatchConfig, kr = !0; function Mc(t, e, i, n) { var r = H, o = Ii.transition; Ii.transition = null; try { H = 1, Xs(t, e, i, n) } finally { H = r, Ii.transition = o } } function bc(t, e, i, n) { var r = H, o = Ii.transition; Ii.transition = null; try { H = 4, Xs(t, e, i, n) } finally { H = r, Ii.transition = o } } function Xs(t, e, i, n) { if (kr) { var r = ls(t, e, i, n); if (r === null) Ao(t, e, n, Pr, i), ql(t, n); else if (Gc(r, t, e, i, n)) n.stopPropagation(); else if (ql(t, n), e & 4 && -1 < Tc.indexOf(t)) { for (; r !== null;) { var o = bn(r); if (o !== null && Ju(o), o = ls(t, e, i, n), o === null && Ao(t, e, n, Pr, i), o === r) break; r = o } r !== null && n.stopPropagation() } else Ao(t, e, n, null, i) } } var Pr = null; function ls(t, e, i, n) { if (Pr = null, t = Qs(n), t = Xt(t), t !== null) if (e = di(t), e === null) t = null; else if (i = e.tag, i === 13) { if (t = bu(e), t !== null) return t; t = null } else if (i === 3) { if (e.stateNode.current.memoizedState.isDehydrated) return e.tag === 3 ? e.stateNode.containerInfo : null; t = null } else e !== t && (t = null); return Pr = t, null } function Xu(t) { switch (t) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (kc()) { case Zs: return 1; case Bu: return 4; case Er: case Pc: return 16; case ju: return 536870912; default: return 16 }default: return 16 } } var It = null, qs = null, cr = null; function qu() { if (cr) return cr; var t, e = qs, i = e.length, n, r = "value" in It ? It.value : It.textContent, o = r.length; for (t = 0; t < i && e[t] === r[t]; t++); var s = i - t; for (n = 1; n <= s && e[i - n] === r[o - n]; n++); return cr = r.slice(t, 1 < n ? 1 - n : void 0) } function pr(t) { var e = t.keyCode; return "charCode" in t ? (t = t.charCode, t === 0 && e === 13 && (t = 13)) : t = e, t === 10 && (t = 13), 32 <= t || t === 13 ? t : 0 } function Yn() { return !0 } function ta() { return !1 } function Ve(t) { function e(i, n, r, o, s) { this._reactName = i, this._targetInst = r, this.type = n, this.nativeEvent = o, this.target = s, this.currentTarget = null; for (var l in t) t.hasOwnProperty(l) && (i = t[l], this[l] = i ? i(o) : o[l]); return this.isDefaultPrevented = (o.defaultPrevented != null ? o.defaultPrevented : o.returnValue === !1) ? Yn : ta, this.isPropagationStopped = ta, this } return K(e.prototype, { preventDefault: function () { this.defaultPrevented = !0; var i = this.nativeEvent; i && (i.preventDefault ? i.preventDefault() : typeof i.returnValue != "unknown" && (i.returnValue = !1), this.isDefaultPrevented = Yn) }, stopPropagation: function () { var i = this.nativeEvent; i && (i.stopPropagation ? i.stopPropagation() : typeof i.cancelBubble != "unknown" && (i.cancelBubble = !0), this.isPropagationStopped = Yn) }, persist: function () { }, isPersistent: Yn }), e } var Fi = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (t) { return t.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, el = Ve(Fi), Mn = K({}, Fi, { view: 0, detail: 0 }), Wc = Ve(Mn), yo, Do, Zi, Yr = K({}, Mn, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: tl, button: 0, buttons: 0, relatedTarget: function (t) { return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget }, movementX: function (t) { return "movementX" in t ? t.movementX : (t !== Zi && (Zi && t.type === "mousemove" ? (yo = t.screenX - Zi.screenX, Do = t.screenY - Zi.screenY) : Do = yo = 0, Zi = t), yo) }, movementY: function (t) { return "movementY" in t ? t.movementY : Do } }), ia = Ve(Yr), Hc = K({}, Yr, { dataTransfer: 0 }), Fc = Ve(Hc), Bc = K({}, Mn, { relatedTarget: 0 }), Co = Ve(Bc), jc = K({}, Fi, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Uc = Ve(jc), $c = K({}, Fi, { clipboardData: function (t) { return "clipboardData" in t ? t.clipboardData : window.clipboardData } }), Jc = Ve($c), Qc = K({}, Fi, { data: 0 }), na = Ve(Qc), Zc = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, Yc = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, Kc = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function Xc(t) { var e = this.nativeEvent; return e.getModifierState ? e.getModifierState(t) : (t = Kc[t]) ? !!e[t] : !1 } function tl() { return Xc } var qc = K({}, Mn, { key: function (t) { if (t.key) { var e = Zc[t.key] || t.key; if (e !== "Unidentified") return e } return t.type === "keypress" ? (t = pr(t), t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? Yc[t.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: tl, charCode: function (t) { return t.type === "keypress" ? pr(t) : 0 }, keyCode: function (t) { return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0 }, which: function (t) { return t.type === "keypress" ? pr(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0 } }), ep = Ve(qc), tp = K({}, Yr, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), ra = Ve(tp), ip = K({}, Mn, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: tl }), np = Ve(ip), rp = K({}, Fi, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), op = Ve(rp), sp = K({}, Yr, { deltaX: function (t) { return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0 }, deltaY: function (t) { return "deltaY" in t ? t.deltaY : "wheelDeltaY" in t ? -t.wheelDeltaY : "wheelDelta" in t ? -t.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), lp = Ve(sp), ap = [9, 13, 27, 32], il = wt && "CompositionEvent" in window, an = null; wt && "documentMode" in document && (an = document.documentMode); var up = wt && "TextEvent" in window && !an, ed = wt && (!il || an && 8 < an && 11 >= an), oa = " ", sa = !1; function td(t, e) { switch (t) { case "keyup": return ap.indexOf(e.keyCode) !== -1; case "keydown": return e.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function id(t) { return t = t.detail, typeof t == "object" && "data" in t ? t.data : null } var gi = !1; function dp(t, e) { switch (t) { case "compositionend": return id(e); case "keypress": return e.which !== 32 ? null : (sa = !0, oa); case "textInput": return t = e.data, t === oa && sa ? null : t; default: return null } } function hp(t, e) { if (gi) return t === "compositionend" || !il && td(t, e) ? (t = qu(), cr = qs = It = null, gi = !1, t) : null; switch (t) { case "paste": return null; case "keypress": if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) { if (e.char && 1 < e.char.length) return e.char; if (e.which) return String.fromCharCode(e.which) } return null; case "compositionend": return ed && e.locale !== "ko" ? null : e.data; default: return null } } var cp = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function la(t) { var e = t && t.nodeName && t.nodeName.toLowerCase(); return e === "input" ? !!cp[t.type] : e === "textarea" } function nd(t, e, i, n) { Ru(n), e = zr(e, "onChange"), 0 < e.length && (i = new el("onChange", "change", null, i, n), t.push({ event: i, listeners: e })) } var un = null, Cn = null; function pp(t) { fd(t, 0) } function Kr(t) { var e = yi(t); if (Pu(e)) return t } function fp(t, e) { if (t === "change") return e } var rd = !1; if (wt) { var So; if (wt) { var Eo = "oninput" in document; if (!Eo) { var aa = document.createElement("div"); aa.setAttribute("oninput", "return;"), Eo = typeof aa.oninput == "function" } So = Eo } else So = !1; rd = So && (!document.documentMode || 9 < document.documentMode) } function ua() { un && (un.detachEvent("onpropertychange", od), Cn = un = null) } function od(t) { if (t.propertyName === "value" && Kr(Cn)) { var e = []; nd(e, Cn, t, Qs(t)), Mu(pp, e) } } function mp(t, e, i) { t === "focusin" ? (ua(), un = e, Cn = i, un.attachEvent("onpropertychange", od)) : t === "focusout" && ua() } function vp(t) { if (t === "selectionchange" || t === "keyup" || t === "keydown") return Kr(Cn) } function gp(t, e) { if (t === "click") return Kr(e) } function wp(t, e) { if (t === "input" || t === "change") return Kr(e) } function _p(t, e) { return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e } var it = typeof Object.is == "function" ? Object.is : _p; function Sn(t, e) { if (it(t, e)) return !0; if (typeof t != "object" || t === null || typeof e != "object" || e === null) return !1; var i = Object.keys(t), n = Object.keys(e); if (i.length !== n.length) return !1; for (n = 0; n < i.length; n++) { var r = i[n]; if (!Bo.call(e, r) || !it(t[r], e[r])) return !1 } return !0 } function da(t) { for (; t && t.firstChild;)t = t.firstChild; return t } function ha(t, e) { var i = da(t); t = 0; for (var n; i;) { if (i.nodeType === 3) { if (n = t + i.textContent.length, t <= e && n >= e) return { node: i, offset: e - t }; t = n } e: { for (; i;) { if (i.nextSibling) { i = i.nextSibling; break e } i = i.parentNode } i = void 0 } i = da(i) } } function sd(t, e) { return t && e ? t === e ? !0 : t && t.nodeType === 3 ? !1 : e && e.nodeType === 3 ? sd(t, e.parentNode) : "contains" in t ? t.contains(e) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(e) & 16) : !1 : !1 } function ld() { for (var t = window, e = Dr(); e instanceof t.HTMLIFrameElement;) { try { var i = typeof e.contentWindow.location.href == "string" } catch { i = !1 } if (i) t = e.contentWindow; else break; e = Dr(t.document) } return e } function nl(t) { var e = t && t.nodeName && t.nodeName.toLowerCase(); return e && (e === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || e === "textarea" || t.contentEditable === "true") } function yp(t) { var e = ld(), i = t.focusedElem, n = t.selectionRange; if (e !== i && i && i.ownerDocument && sd(i.ownerDocument.documentElement, i)) { if (n !== null && nl(i)) { if (e = n.start, t = n.end, t === void 0 && (t = e), "selectionStart" in i) i.selectionStart = e, i.selectionEnd = Math.min(t, i.value.length); else if (t = (e = i.ownerDocument || document) && e.defaultView || window, t.getSelection) { t = t.getSelection(); var r = i.textContent.length, o = Math.min(n.start, r); n = n.end === void 0 ? o : Math.min(n.end, r), !t.extend && o > n && (r = n, n = o, o = r), r = ha(i, o); var s = ha(i, n); r && s && (t.rangeCount !== 1 || t.anchorNode !== r.node || t.anchorOffset !== r.offset || t.focusNode !== s.node || t.focusOffset !== s.offset) && (e = e.createRange(), e.setStart(r.node, r.offset), t.removeAllRanges(), o > n ? (t.addRange(e), t.extend(s.node, s.offset)) : (e.setEnd(s.node, s.offset), t.addRange(e))) } } for (e = [], t = i; t = t.parentNode;)t.nodeType === 1 && e.push({ element: t, left: t.scrollLeft, top: t.scrollTop }); for (typeof i.focus == "function" && i.focus(), i = 0; i < e.length; i++)t = e[i], t.element.scrollLeft = t.left, t.element.scrollTop = t.top } } var Dp = wt && "documentMode" in document && 11 >= document.documentMode, wi = null, as = null, dn = null, us = !1; function ca(t, e, i) { var n = i.window === i ? i.document : i.nodeType === 9 ? i : i.ownerDocument; us || wi == null || wi !== Dr(n) || (n = wi, "selectionStart" in n && nl(n) ? n = { start: n.selectionStart, end: n.selectionEnd } : (n = (n.ownerDocument && n.ownerDocument.defaultView || window).getSelection(), n = { anchorNode: n.anchorNode, anchorOffset: n.anchorOffset, focusNode: n.focusNode, focusOffset: n.focusOffset }), dn && Sn(dn, n) || (dn = n, n = zr(as, "onSelect"), 0 < n.length && (e = new el("onSelect", "select", null, e, i), t.push({ event: e, listeners: n }), e.target = wi))) } function Kn(t, e) { var i = {}; return i[t.toLowerCase()] = e.toLowerCase(), i["Webkit" + t] = "webkit" + e, i["Moz" + t] = "moz" + e, i } var _i = { animationend: Kn("Animation", "AnimationEnd"), animationiteration: Kn("Animation", "AnimationIteration"), animationstart: Kn("Animation", "AnimationStart"), transitionend: Kn("Transition", "TransitionEnd") }, xo = {}, ad = {}; wt && (ad = document.createElement("div").style, "AnimationEvent" in window || (delete _i.animationend.animation, delete _i.animationiteration.animation, delete _i.animationstart.animation), "TransitionEvent" in window || delete _i.transitionend.transition); function Xr(t) { if (xo[t]) return xo[t]; if (!_i[t]) return t; var e = _i[t], i; for (i in e) if (e.hasOwnProperty(i) && i in ad) return xo[t] = e[i]; return t } var ud = Xr("animationend"), dd = Xr("animationiteration"), hd = Xr("animationstart"), cd = Xr("transitionend"), pd = new Map, pa = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function Ut(t, e) { pd.set(t, e), ui(e, [t]) } for (var ko = 0; ko < pa.length; ko++) { var Po = pa[ko], Cp = Po.toLowerCase(), Sp = Po[0].toUpperCase() + Po.slice(1); Ut(Cp, "on" + Sp) } Ut(ud, "onAnimationEnd"); Ut(dd, "onAnimationIteration"); Ut(hd, "onAnimationStart"); Ut("dblclick", "onDoubleClick"); Ut("focusin", "onFocus"); Ut("focusout", "onBlur"); Ut(cd, "onTransitionEnd"); Li("onMouseEnter", ["mouseout", "mouseover"]); Li("onMouseLeave", ["mouseout", "mouseover"]); Li("onPointerEnter", ["pointerout", "pointerover"]); Li("onPointerLeave", ["pointerout", "pointerover"]); ui("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); ui("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); ui("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); ui("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); ui("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); ui("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var on = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Ep = new Set("cancel close invalid load scroll toggle".split(" ").concat(on)); function fa(t, e, i) { var n = t.type || "unknown-event"; t.currentTarget = i, Cc(n, e, void 0, t), t.currentTarget = null } function fd(t, e) { e = (e & 4) !== 0; for (var i = 0; i < t.length; i++) { var n = t[i], r = n.event; n = n.listeners; e: { var o = void 0; if (e) for (var s = n.length - 1; 0 <= s; s--) { var l = n[s], a = l.instance, u = l.currentTarget; if (l = l.listener, a !== o && r.isPropagationStopped()) break e; fa(r, l, u), o = a } else for (s = 0; s < n.length; s++) { if (l = n[s], a = l.instance, u = l.currentTarget, l = l.listener, a !== o && r.isPropagationStopped()) break e; fa(r, l, u), o = a } } } if (Sr) throw t = rs, Sr = !1, rs = null, t } function U(t, e) { var i = e[fs]; i === void 0 && (i = e[fs] = new Set); var n = t + "__bubble"; i.has(n) || (md(e, t, 2, !1), i.add(n)) } function zo(t, e, i) { var n = 0; e && (n |= 4), md(i, t, n, e) } var Xn = "_reactListening" + Math.random().toString(36).slice(2); function En(t) { if (!t[Xn]) { t[Xn] = !0, Cu.forEach(function (i) { i !== "selectionchange" && (Ep.has(i) || zo(i, !1, t), zo(i, !0, t)) }); var e = t.nodeType === 9 ? t : t.ownerDocument; e === null || e[Xn] || (e[Xn] = !0, zo("selectionchange", !1, e)) } } function md(t, e, i, n) { switch (Xu(e)) { case 1: var r = Mc; break; case 4: r = bc; break; default: r = Xs }i = r.bind(null, e, i, t), r = void 0, !ns || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (r = !0), n ? r !== void 0 ? t.addEventListener(e, i, { capture: !0, passive: r }) : t.addEventListener(e, i, !0) : r !== void 0 ? t.addEventListener(e, i, { passive: r }) : t.addEventListener(e, i, !1) } function Ao(t, e, i, n, r) { var o = n; if (!(e & 1) && !(e & 2) && n !== null) e: for (; ;) { if (n === null) return; var s = n.tag; if (s === 3 || s === 4) { var l = n.stateNode.containerInfo; if (l === r || l.nodeType === 8 && l.parentNode === r) break; if (s === 4) for (s = n.return; s !== null;) { var a = s.tag; if ((a === 3 || a === 4) && (a = s.stateNode.containerInfo, a === r || a.nodeType === 8 && a.parentNode === r)) return; s = s.return } for (; l !== null;) { if (s = Xt(l), s === null) return; if (a = s.tag, a === 5 || a === 6) { n = o = s; continue e } l = l.parentNode } } n = n.return } Mu(function () { var u = o, m = Qs(i), d = []; e: { var c = pd.get(t); if (c !== void 0) { var v = el, g = t; switch (t) { case "keypress": if (pr(i) === 0) break e; case "keydown": case "keyup": v = ep; break; case "focusin": g = "focus", v = Co; break; case "focusout": g = "blur", v = Co; break; case "beforeblur": case "afterblur": v = Co; break; case "click": if (i.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": v = ia; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": v = Fc; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": v = np; break; case ud: case dd: case hd: v = Uc; break; case cd: v = op; break; case "scroll": v = Wc; break; case "wheel": v = lp; break; case "copy": case "cut": case "paste": v = Jc; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": v = ra }var w = (e & 4) !== 0, C = !w && t === "scroll", p = w ? c !== null ? c + "Capture" : null : c; w = []; for (var h = u, f; h !== null;) { f = h; var y = f.stateNode; if (f.tag === 5 && y !== null && (f = y, p !== null && (y = wn(h, p), y != null && w.push(xn(h, y, f)))), C) break; h = h.return } 0 < w.length && (c = new v(c, g, null, i, m), d.push({ event: c, listeners: w })) } } if (!(e & 7)) { e: { if (c = t === "mouseover" || t === "pointerover", v = t === "mouseout" || t === "pointerout", c && i !== ts && (g = i.relatedTarget || i.fromElement) && (Xt(g) || g[_t])) break e; if ((v || c) && (c = m.window === m ? m : (c = m.ownerDocument) ? c.defaultView || c.parentWindow : window, v ? (g = i.relatedTarget || i.toElement, v = u, g = g ? Xt(g) : null, g !== null && (C = di(g), g !== C || g.tag !== 5 && g.tag !== 6) && (g = null)) : (v = null, g = u), v !== g)) { if (w = ia, y = "onMouseLeave", p = "onMouseEnter", h = "mouse", (t === "pointerout" || t === "pointerover") && (w = ra, y = "onPointerLeave", p = "onPointerEnter", h = "pointer"), C = v == null ? c : yi(v), f = g == null ? c : yi(g), c = new w(y, h + "leave", v, i, m), c.target = C, c.relatedTarget = f, y = null, Xt(m) === u && (w = new w(p, h + "enter", g, i, m), w.target = f, w.relatedTarget = C, y = w), C = y, v && g) t: { for (w = v, p = g, h = 0, f = w; f; f = ci(f))h++; for (f = 0, y = p; y; y = ci(y))f++; for (; 0 < h - f;)w = ci(w), h--; for (; 0 < f - h;)p = ci(p), f--; for (; h--;) { if (w === p || p !== null && w === p.alternate) break t; w = ci(w), p = ci(p) } w = null } else w = null; v !== null && ma(d, c, v, w, !1), g !== null && C !== null && ma(d, C, g, w, !0) } } e: { if (c = u ? yi(u) : window, v = c.nodeName && c.nodeName.toLowerCase(), v === "select" || v === "input" && c.type === "file") var S = fp; else if (la(c)) if (rd) S = wp; else { S = vp; var E = mp } else (v = c.nodeName) && v.toLowerCase() === "input" && (c.type === "checkbox" || c.type === "radio") && (S = gp); if (S && (S = S(t, u))) { nd(d, S, i, m); break e } E && E(t, c, u), t === "focusout" && (E = c._wrapperState) && E.controlled && c.type === "number" && Yo(c, "number", c.value) } switch (E = u ? yi(u) : window, t) { case "focusin": (la(E) || E.contentEditable === "true") && (wi = E, as = u, dn = null); break; case "focusout": dn = as = wi = null; break; case "mousedown": us = !0; break; case "contextmenu": case "mouseup": case "dragend": us = !1, ca(d, i, m); break; case "selectionchange": if (Dp) break; case "keydown": case "keyup": ca(d, i, m) }var x; if (il) e: { switch (t) { case "compositionstart": var z = "onCompositionStart"; break e; case "compositionend": z = "onCompositionEnd"; break e; case "compositionupdate": z = "onCompositionUpdate"; break e }z = void 0 } else gi ? td(t, i) && (z = "onCompositionEnd") : t === "keydown" && i.keyCode === 229 && (z = "onCompositionStart"); z && (ed && i.locale !== "ko" && (gi || z !== "onCompositionStart" ? z === "onCompositionEnd" && gi && (x = qu()) : (It = m, qs = "value" in It ? It.value : It.textContent, gi = !0)), E = zr(u, z), 0 < E.length && (z = new na(z, t, null, i, m), d.push({ event: z, listeners: E }), x ? z.data = x : (x = id(i), x !== null && (z.data = x)))), (x = up ? dp(t, i) : hp(t, i)) && (u = zr(u, "onBeforeInput"), 0 < u.length && (m = new na("onBeforeInput", "beforeinput", null, i, m), d.push({ event: m, listeners: u }), m.data = x)) } fd(d, e) }) } function xn(t, e, i) { return { instance: t, listener: e, currentTarget: i } } function zr(t, e) { for (var i = e + "Capture", n = []; t !== null;) { var r = t, o = r.stateNode; r.tag === 5 && o !== null && (r = o, o = wn(t, i), o != null && n.unshift(xn(t, o, r)), o = wn(t, e), o != null && n.push(xn(t, o, r))), t = t.return } return n } function ci(t) { if (t === null) return null; do t = t.return; while (t && t.tag !== 5); return t || null } function ma(t, e, i, n, r) { for (var o = e._reactName, s = []; i !== null && i !== n;) { var l = i, a = l.alternate, u = l.stateNode; if (a !== null && a === n) break; l.tag === 5 && u !== null && (l = u, r ? (a = wn(i, o), a != null && s.unshift(xn(i, a, l))) : r || (a = wn(i, o), a != null && s.push(xn(i, a, l)))), i = i.return } s.length !== 0 && t.push({ event: e, listeners: s }) } var xp = /\r\n?/g, kp = /\u0000|\uFFFD/g; function va(t) {
    return (typeof t == "string" ? t : "" + t).replace(xp, `
`).replace(kp, "")
} function qn(t, e, i) { if (e = va(e), va(t) !== e && i) throw Error(D(425)) } function Ar() { } var ds = null, hs = null; function cs(t, e) { return t === "textarea" || t === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null } var ps = typeof setTimeout == "function" ? setTimeout : void 0, Pp = typeof clearTimeout == "function" ? clearTimeout : void 0, ga = typeof Promise == "function" ? Promise : void 0, zp = typeof queueMicrotask == "function" ? queueMicrotask : typeof ga < "u" ? function (t) { return ga.resolve(null).then(t).catch(Ap) } : ps; function Ap(t) { setTimeout(function () { throw t }) } function Io(t, e) { var i = e, n = 0; do { var r = i.nextSibling; if (t.removeChild(i), r && r.nodeType === 8) if (i = r.data, i === "/$") { if (n === 0) { t.removeChild(r), Dn(e); return } n-- } else i !== "$" && i !== "$?" && i !== "$!" || n++; i = r } while (i); Dn(e) } function Vt(t) { for (; t != null; t = t.nextSibling) { var e = t.nodeType; if (e === 1 || e === 3) break; if (e === 8) { if (e = t.data, e === "$" || e === "$!" || e === "$?") break; if (e === "/$") return null } } return t } function wa(t) { t = t.previousSibling; for (var e = 0; t;) { if (t.nodeType === 8) { var i = t.data; if (i === "$" || i === "$!" || i === "$?") { if (e === 0) return t; e-- } else i === "/$" && e++ } t = t.previousSibling } return null } var Bi = Math.random().toString(36).slice(2), st = "__reactFiber$" + Bi, kn = "__reactProps$" + Bi, _t = "__reactContainer$" + Bi, fs = "__reactEvents$" + Bi, Ip = "__reactListeners$" + Bi, Np = "__reactHandles$" + Bi; function Xt(t) { var e = t[st]; if (e) return e; for (var i = t.parentNode; i;) { if (e = i[_t] || i[st]) { if (i = e.alternate, e.child !== null || i !== null && i.child !== null) for (t = wa(t); t !== null;) { if (i = t[st]) return i; t = wa(t) } return e } t = i, i = t.parentNode } return null } function bn(t) { return t = t[st] || t[_t], !t || t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3 ? null : t } function yi(t) { if (t.tag === 5 || t.tag === 6) return t.stateNode; throw Error(D(33)) } function qr(t) { return t[kn] || null } var ms = [], Di = -1; function $t(t) { return { current: t } } function J(t) { 0 > Di || (t.current = ms[Di], ms[Di] = null, Di--) } function j(t, e) { Di++, ms[Di] = t.current, t.current = e } var jt = {}, _e = $t(jt), Pe = $t(!1), ri = jt; function Ri(t, e) { var i = t.type.contextTypes; if (!i) return jt; var n = t.stateNode; if (n && n.__reactInternalMemoizedUnmaskedChildContext === e) return n.__reactInternalMemoizedMaskedChildContext; var r = {}, o; for (o in i) r[o] = e[o]; return n && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = e, t.__reactInternalMemoizedMaskedChildContext = r), r } function ze(t) { return t = t.childContextTypes, t != null } function Ir() { J(Pe), J(_e) } function _a(t, e, i) { if (_e.current !== jt) throw Error(D(168)); j(_e, e), j(Pe, i) } function vd(t, e, i) { var n = t.stateNode; if (e = e.childContextTypes, typeof n.getChildContext != "function") return i; n = n.getChildContext(); for (var r in n) if (!(r in e)) throw Error(D(108, mc(t) || "Unknown", r)); return K({}, i, n) } function Nr(t) { return t = (t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext || jt, ri = _e.current, j(_e, t), j(Pe, Pe.current), !0 } function ya(t, e, i) { var n = t.stateNode; if (!n) throw Error(D(169)); i ? (t = vd(t, e, ri), n.__reactInternalMemoizedMergedChildContext = t, J(Pe), J(_e), j(_e, t)) : J(Pe), j(Pe, i) } var ht = null, eo = !1, No = !1; function gd(t) { ht === null ? ht = [t] : ht.push(t) } function Op(t) { eo = !0, gd(t) } function Jt() { if (!No && ht !== null) { No = !0; var t = 0, e = H; try { var i = ht; for (H = 1; t < i.length; t++) { var n = i[t]; do n = n(!0); while (n !== null) } ht = null, eo = !1 } catch (r) { throw ht !== null && (ht = ht.slice(t + 1)), Fu(Zs, Jt), r } finally { H = e, No = !1 } } return null } var Ci = [], Si = 0, Or = null, Lr = 0, We = [], He = 0, oi = null, pt = 1, ft = ""; function Yt(t, e) { Ci[Si++] = Lr, Ci[Si++] = Or, Or = t, Lr = e } function wd(t, e, i) { We[He++] = pt, We[He++] = ft, We[He++] = oi, oi = t; var n = pt; t = ft; var r = 32 - et(n) - 1; n &= ~(1 << r), i += 1; var o = 32 - et(e) + r; if (30 < o) { var s = r - r % 5; o = (n & (1 << s) - 1).toString(32), n >>= s, r -= s, pt = 1 << 32 - et(e) + r | i << r | n, ft = o + t } else pt = 1 << o | i << r | n, ft = t } function rl(t) { t.return !== null && (Yt(t, 1), wd(t, 1, 0)) } function ol(t) { for (; t === Or;)Or = Ci[--Si], Ci[Si] = null, Lr = Ci[--Si], Ci[Si] = null; for (; t === oi;)oi = We[--He], We[He] = null, ft = We[--He], We[He] = null, pt = We[--He], We[He] = null } var Re = null, Ne = null, Q = !1, qe = null; function _d(t, e) { var i = Be(5, null, null, 0); i.elementType = "DELETED", i.stateNode = e, i.return = t, e = t.deletions, e === null ? (t.deletions = [i], t.flags |= 16) : e.push(i) } function Da(t, e) { switch (t.tag) { case 5: var i = t.type; return e = e.nodeType !== 1 || i.toLowerCase() !== e.nodeName.toLowerCase() ? null : e, e !== null ? (t.stateNode = e, Re = t, Ne = Vt(e.firstChild), !0) : !1; case 6: return e = t.pendingProps === "" || e.nodeType !== 3 ? null : e, e !== null ? (t.stateNode = e, Re = t, Ne = null, !0) : !1; case 13: return e = e.nodeType !== 8 ? null : e, e !== null ? (i = oi !== null ? { id: pt, overflow: ft } : null, t.memoizedState = { dehydrated: e, treeContext: i, retryLane: 1073741824 }, i = Be(18, null, null, 0), i.stateNode = e, i.return = t, t.child = i, Re = t, Ne = null, !0) : !1; default: return !1 } } function vs(t) { return (t.mode & 1) !== 0 && (t.flags & 128) === 0 } function gs(t) { if (Q) { var e = Ne; if (e) { var i = e; if (!Da(t, e)) { if (vs(t)) throw Error(D(418)); e = Vt(i.nextSibling); var n = Re; e && Da(t, e) ? _d(n, i) : (t.flags = t.flags & -4097 | 2, Q = !1, Re = t) } } else { if (vs(t)) throw Error(D(418)); t.flags = t.flags & -4097 | 2, Q = !1, Re = t } } } function Ca(t) { for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13;)t = t.return; Re = t } function er(t) { if (t !== Re) return !1; if (!Q) return Ca(t), Q = !0, !1; var e; if ((e = t.tag !== 3) && !(e = t.tag !== 5) && (e = t.type, e = e !== "head" && e !== "body" && !cs(t.type, t.memoizedProps)), e && (e = Ne)) { if (vs(t)) throw yd(), Error(D(418)); for (; e;)_d(t, e), e = Vt(e.nextSibling) } if (Ca(t), t.tag === 13) { if (t = t.memoizedState, t = t !== null ? t.dehydrated : null, !t) throw Error(D(317)); e: { for (t = t.nextSibling, e = 0; t;) { if (t.nodeType === 8) { var i = t.data; if (i === "/$") { if (e === 0) { Ne = Vt(t.nextSibling); break e } e-- } else i !== "$" && i !== "$!" && i !== "$?" || e++ } t = t.nextSibling } Ne = null } } else Ne = Re ? Vt(t.stateNode.nextSibling) : null; return !0 } function yd() { for (var t = Ne; t;)t = Vt(t.nextSibling) } function Ti() { Ne = Re = null, Q = !1 } function sl(t) { qe === null ? qe = [t] : qe.push(t) } var Lp = St.ReactCurrentBatchConfig; function Ke(t, e) { if (t && t.defaultProps) { e = K({}, e), t = t.defaultProps; for (var i in t) e[i] === void 0 && (e[i] = t[i]); return e } return e } var Rr = $t(null), Tr = null, Ei = null, ll = null; function al() { ll = Ei = Tr = null } function ul(t) { var e = Rr.current; J(Rr), t._currentValue = e } function ws(t, e, i) { for (; t !== null;) { var n = t.alternate; if ((t.childLanes & e) !== e ? (t.childLanes |= e, n !== null && (n.childLanes |= e)) : n !== null && (n.childLanes & e) !== e && (n.childLanes |= e), t === i) break; t = t.return } } function Ni(t, e) { Tr = t, ll = Ei = null, t = t.dependencies, t !== null && t.firstContext !== null && (t.lanes & e && (ke = !0), t.firstContext = null) } function $e(t) { var e = t._currentValue; if (ll !== t) if (t = { context: t, memoizedValue: e, next: null }, Ei === null) { if (Tr === null) throw Error(D(308)); Ei = t, Tr.dependencies = { lanes: 0, firstContext: t } } else Ei = Ei.next = t; return e } var qt = null; function dl(t) { qt === null ? qt = [t] : qt.push(t) } function Dd(t, e, i, n) { var r = e.interleaved; return r === null ? (i.next = i, dl(e)) : (i.next = r.next, r.next = i), e.interleaved = i, yt(t, n) } function yt(t, e) { t.lanes |= e; var i = t.alternate; for (i !== null && (i.lanes |= e), i = t, t = t.return; t !== null;)t.childLanes |= e, i = t.alternate, i !== null && (i.childLanes |= e), i = t, t = t.return; return i.tag === 3 ? i.stateNode : null } var kt = !1; function hl(t) { t.updateQueue = { baseState: t.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function Cd(t, e) { t = t.updateQueue, e.updateQueue === t && (e.updateQueue = { baseState: t.baseState, firstBaseUpdate: t.firstBaseUpdate, lastBaseUpdate: t.lastBaseUpdate, shared: t.shared, effects: t.effects }) } function gt(t, e) { return { eventTime: t, lane: e, tag: 0, payload: null, callback: null, next: null } } function Mt(t, e, i) { var n = t.updateQueue; if (n === null) return null; if (n = n.shared, W & 2) { var r = n.pending; return r === null ? e.next = e : (e.next = r.next, r.next = e), n.pending = e, yt(t, i) } return r = n.interleaved, r === null ? (e.next = e, dl(n)) : (e.next = r.next, r.next = e), n.interleaved = e, yt(t, i) } function fr(t, e, i) { if (e = e.updateQueue, e !== null && (e = e.shared, (i & 4194240) !== 0)) { var n = e.lanes; n &= t.pendingLanes, i |= n, e.lanes = i, Ys(t, i) } } function Sa(t, e) { var i = t.updateQueue, n = t.alternate; if (n !== null && (n = n.updateQueue, i === n)) { var r = null, o = null; if (i = i.firstBaseUpdate, i !== null) { do { var s = { eventTime: i.eventTime, lane: i.lane, tag: i.tag, payload: i.payload, callback: i.callback, next: null }; o === null ? r = o = s : o = o.next = s, i = i.next } while (i !== null); o === null ? r = o = e : o = o.next = e } else r = o = e; i = { baseState: n.baseState, firstBaseUpdate: r, lastBaseUpdate: o, shared: n.shared, effects: n.effects }, t.updateQueue = i; return } t = i.lastBaseUpdate, t === null ? i.firstBaseUpdate = e : t.next = e, i.lastBaseUpdate = e } function Gr(t, e, i, n) { var r = t.updateQueue; kt = !1; var o = r.firstBaseUpdate, s = r.lastBaseUpdate, l = r.shared.pending; if (l !== null) { r.shared.pending = null; var a = l, u = a.next; a.next = null, s === null ? o = u : s.next = u, s = a; var m = t.alternate; m !== null && (m = m.updateQueue, l = m.lastBaseUpdate, l !== s && (l === null ? m.firstBaseUpdate = u : l.next = u, m.lastBaseUpdate = a)) } if (o !== null) { var d = r.baseState; s = 0, m = u = a = null, l = o; do { var c = l.lane, v = l.eventTime; if ((n & c) === c) { m !== null && (m = m.next = { eventTime: v, lane: 0, tag: l.tag, payload: l.payload, callback: l.callback, next: null }); e: { var g = t, w = l; switch (c = e, v = i, w.tag) { case 1: if (g = w.payload, typeof g == "function") { d = g.call(v, d, c); break e } d = g; break e; case 3: g.flags = g.flags & -65537 | 128; case 0: if (g = w.payload, c = typeof g == "function" ? g.call(v, d, c) : g, c == null) break e; d = K({}, d, c); break e; case 2: kt = !0 } } l.callback !== null && l.lane !== 0 && (t.flags |= 64, c = r.effects, c === null ? r.effects = [l] : c.push(l)) } else v = { eventTime: v, lane: c, tag: l.tag, payload: l.payload, callback: l.callback, next: null }, m === null ? (u = m = v, a = d) : m = m.next = v, s |= c; if (l = l.next, l === null) { if (l = r.shared.pending, l === null) break; c = l, l = c.next, c.next = null, r.lastBaseUpdate = c, r.shared.pending = null } } while (!0); if (m === null && (a = d), r.baseState = a, r.firstBaseUpdate = u, r.lastBaseUpdate = m, e = r.shared.interleaved, e !== null) { r = e; do s |= r.lane, r = r.next; while (r !== e) } else o === null && (r.shared.lanes = 0); li |= s, t.lanes = s, t.memoizedState = d } } function Ea(t, e, i) { if (t = e.effects, e.effects = null, t !== null) for (e = 0; e < t.length; e++) { var n = t[e], r = n.callback; if (r !== null) { if (n.callback = null, n = i, typeof r != "function") throw Error(D(191, r)); r.call(n) } } } var Sd = new Du.Component().refs; function _s(t, e, i, n) { e = t.memoizedState, i = i(n, e), i = i == null ? e : K({}, e, i), t.memoizedState = i, t.lanes === 0 && (t.updateQueue.baseState = i) } var to = { isMounted: function (t) { return (t = t._reactInternals) ? di(t) === t : !1 }, enqueueSetState: function (t, e, i) { t = t._reactInternals; var n = Ce(), r = Wt(t), o = gt(n, r); o.payload = e, i != null && (o.callback = i), e = Mt(t, o, r), e !== null && (tt(e, t, r, n), fr(e, t, r)) }, enqueueReplaceState: function (t, e, i) { t = t._reactInternals; var n = Ce(), r = Wt(t), o = gt(n, r); o.tag = 1, o.payload = e, i != null && (o.callback = i), e = Mt(t, o, r), e !== null && (tt(e, t, r, n), fr(e, t, r)) }, enqueueForceUpdate: function (t, e) { t = t._reactInternals; var i = Ce(), n = Wt(t), r = gt(i, n); r.tag = 2, e != null && (r.callback = e), e = Mt(t, r, n), e !== null && (tt(e, t, n, i), fr(e, t, n)) } }; function xa(t, e, i, n, r, o, s) { return t = t.stateNode, typeof t.shouldComponentUpdate == "function" ? t.shouldComponentUpdate(n, o, s) : e.prototype && e.prototype.isPureReactComponent ? !Sn(i, n) || !Sn(r, o) : !0 } function Ed(t, e, i) { var n = !1, r = jt, o = e.contextType; return typeof o == "object" && o !== null ? o = $e(o) : (r = ze(e) ? ri : _e.current, n = e.contextTypes, o = (n = n != null) ? Ri(t, r) : jt), e = new e(i, o), t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, e.updater = to, t.stateNode = e, e._reactInternals = t, n && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = r, t.__reactInternalMemoizedMaskedChildContext = o), e } function ka(t, e, i, n) { t = e.state, typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(i, n), typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(i, n), e.state !== t && to.enqueueReplaceState(e, e.state, null) } function ys(t, e, i, n) { var r = t.stateNode; r.props = i, r.state = t.memoizedState, r.refs = Sd, hl(t); var o = e.contextType; typeof o == "object" && o !== null ? r.context = $e(o) : (o = ze(e) ? ri : _e.current, r.context = Ri(t, o)), r.state = t.memoizedState, o = e.getDerivedStateFromProps, typeof o == "function" && (_s(t, e, o, i), r.state = t.memoizedState), typeof e.getDerivedStateFromProps == "function" || typeof r.getSnapshotBeforeUpdate == "function" || typeof r.UNSAFE_componentWillMount != "function" && typeof r.componentWillMount != "function" || (e = r.state, typeof r.componentWillMount == "function" && r.componentWillMount(), typeof r.UNSAFE_componentWillMount == "function" && r.UNSAFE_componentWillMount(), e !== r.state && to.enqueueReplaceState(r, r.state, null), Gr(t, i, r, n), r.state = t.memoizedState), typeof r.componentDidMount == "function" && (t.flags |= 4194308) } function Yi(t, e, i) { if (t = i.ref, t !== null && typeof t != "function" && typeof t != "object") { if (i._owner) { if (i = i._owner, i) { if (i.tag !== 1) throw Error(D(309)); var n = i.stateNode } if (!n) throw Error(D(147, t)); var r = n, o = "" + t; return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === o ? e.ref : (e = function (s) { var l = r.refs; l === Sd && (l = r.refs = {}), s === null ? delete l[o] : l[o] = s }, e._stringRef = o, e) } if (typeof t != "string") throw Error(D(284)); if (!i._owner) throw Error(D(290, t)) } return t } function tr(t, e) { throw t = Object.prototype.toString.call(e), Error(D(31, t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t)) } function Pa(t) { var e = t._init; return e(t._payload) } function xd(t) { function e(p, h) { if (t) { var f = p.deletions; f === null ? (p.deletions = [h], p.flags |= 16) : f.push(h) } } function i(p, h) { if (!t) return null; for (; h !== null;)e(p, h), h = h.sibling; return null } function n(p, h) { for (p = new Map; h !== null;)h.key !== null ? p.set(h.key, h) : p.set(h.index, h), h = h.sibling; return p } function r(p, h) { return p = Ht(p, h), p.index = 0, p.sibling = null, p } function o(p, h, f) { return p.index = f, t ? (f = p.alternate, f !== null ? (f = f.index, f < h ? (p.flags |= 2, h) : f) : (p.flags |= 2, h)) : (p.flags |= 1048576, h) } function s(p) { return t && p.alternate === null && (p.flags |= 2), p } function l(p, h, f, y) { return h === null || h.tag !== 6 ? (h = Mo(f, p.mode, y), h.return = p, h) : (h = r(h, f), h.return = p, h) } function a(p, h, f, y) { var S = f.type; return S === vi ? m(p, h, f.props.children, y, f.key) : h !== null && (h.elementType === S || typeof S == "object" && S !== null && S.$$typeof === xt && Pa(S) === h.type) ? (y = r(h, f.props), y.ref = Yi(p, h, f), y.return = p, y) : (y = yr(f.type, f.key, f.props, null, p.mode, y), y.ref = Yi(p, h, f), y.return = p, y) } function u(p, h, f, y) { return h === null || h.tag !== 4 || h.stateNode.containerInfo !== f.containerInfo || h.stateNode.implementation !== f.implementation ? (h = bo(f, p.mode, y), h.return = p, h) : (h = r(h, f.children || []), h.return = p, h) } function m(p, h, f, y, S) { return h === null || h.tag !== 7 ? (h = ii(f, p.mode, y, S), h.return = p, h) : (h = r(h, f), h.return = p, h) } function d(p, h, f) { if (typeof h == "string" && h !== "" || typeof h == "number") return h = Mo("" + h, p.mode, f), h.return = p, h; if (typeof h == "object" && h !== null) { switch (h.$$typeof) { case jn: return f = yr(h.type, h.key, h.props, null, p.mode, f), f.ref = Yi(p, null, h), f.return = p, f; case mi: return h = bo(h, p.mode, f), h.return = p, h; case xt: var y = h._init; return d(p, y(h._payload), f) }if (nn(h) || Ui(h)) return h = ii(h, p.mode, f, null), h.return = p, h; tr(p, h) } return null } function c(p, h, f, y) { var S = h !== null ? h.key : null; if (typeof f == "string" && f !== "" || typeof f == "number") return S !== null ? null : l(p, h, "" + f, y); if (typeof f == "object" && f !== null) { switch (f.$$typeof) { case jn: return f.key === S ? a(p, h, f, y) : null; case mi: return f.key === S ? u(p, h, f, y) : null; case xt: return S = f._init, c(p, h, S(f._payload), y) }if (nn(f) || Ui(f)) return S !== null ? null : m(p, h, f, y, null); tr(p, f) } return null } function v(p, h, f, y, S) { if (typeof y == "string" && y !== "" || typeof y == "number") return p = p.get(f) || null, l(h, p, "" + y, S); if (typeof y == "object" && y !== null) { switch (y.$$typeof) { case jn: return p = p.get(y.key === null ? f : y.key) || null, a(h, p, y, S); case mi: return p = p.get(y.key === null ? f : y.key) || null, u(h, p, y, S); case xt: var E = y._init; return v(p, h, f, E(y._payload), S) }if (nn(y) || Ui(y)) return p = p.get(f) || null, m(h, p, y, S, null); tr(h, y) } return null } function g(p, h, f, y) { for (var S = null, E = null, x = h, z = h = 0, F = null; x !== null && z < f.length; z++) { x.index > z ? (F = x, x = null) : F = x.sibling; var O = c(p, x, f[z], y); if (O === null) { x === null && (x = F); break } t && x && O.alternate === null && e(p, x), h = o(O, h, z), E === null ? S = O : E.sibling = O, E = O, x = F } if (z === f.length) return i(p, x), Q && Yt(p, z), S; if (x === null) { for (; z < f.length; z++)x = d(p, f[z], y), x !== null && (h = o(x, h, z), E === null ? S = x : E.sibling = x, E = x); return Q && Yt(p, z), S } for (x = n(p, x); z < f.length; z++)F = v(x, p, z, f[z], y), F !== null && (t && F.alternate !== null && x.delete(F.key === null ? z : F.key), h = o(F, h, z), E === null ? S = F : E.sibling = F, E = F); return t && x.forEach(function (ue) { return e(p, ue) }), Q && Yt(p, z), S } function w(p, h, f, y) { var S = Ui(f); if (typeof S != "function") throw Error(D(150)); if (f = S.call(f), f == null) throw Error(D(151)); for (var E = S = null, x = h, z = h = 0, F = null, O = f.next(); x !== null && !O.done; z++, O = f.next()) { x.index > z ? (F = x, x = null) : F = x.sibling; var ue = c(p, x, O.value, y); if (ue === null) { x === null && (x = F); break } t && x && ue.alternate === null && e(p, x), h = o(ue, h, z), E === null ? S = ue : E.sibling = ue, E = ue, x = F } if (O.done) return i(p, x), Q && Yt(p, z), S; if (x === null) { for (; !O.done; z++, O = f.next())O = d(p, O.value, y), O !== null && (h = o(O, h, z), E === null ? S = O : E.sibling = O, E = O); return Q && Yt(p, z), S } for (x = n(p, x); !O.done; z++, O = f.next())O = v(x, p, z, O.value, y), O !== null && (t && O.alternate !== null && x.delete(O.key === null ? z : O.key), h = o(O, h, z), E === null ? S = O : E.sibling = O, E = O); return t && x.forEach(function (Me) { return e(p, Me) }), Q && Yt(p, z), S } function C(p, h, f, y) { if (typeof f == "object" && f !== null && f.type === vi && f.key === null && (f = f.props.children), typeof f == "object" && f !== null) { switch (f.$$typeof) { case jn: e: { for (var S = f.key, E = h; E !== null;) { if (E.key === S) { if (S = f.type, S === vi) { if (E.tag === 7) { i(p, E.sibling), h = r(E, f.props.children), h.return = p, p = h; break e } } else if (E.elementType === S || typeof S == "object" && S !== null && S.$$typeof === xt && Pa(S) === E.type) { i(p, E.sibling), h = r(E, f.props), h.ref = Yi(p, E, f), h.return = p, p = h; break e } i(p, E); break } else e(p, E); E = E.sibling } f.type === vi ? (h = ii(f.props.children, p.mode, y, f.key), h.return = p, p = h) : (y = yr(f.type, f.key, f.props, null, p.mode, y), y.ref = Yi(p, h, f), y.return = p, p = y) } return s(p); case mi: e: { for (E = f.key; h !== null;) { if (h.key === E) if (h.tag === 4 && h.stateNode.containerInfo === f.containerInfo && h.stateNode.implementation === f.implementation) { i(p, h.sibling), h = r(h, f.children || []), h.return = p, p = h; break e } else { i(p, h); break } else e(p, h); h = h.sibling } h = bo(f, p.mode, y), h.return = p, p = h } return s(p); case xt: return E = f._init, C(p, h, E(f._payload), y) }if (nn(f)) return g(p, h, f, y); if (Ui(f)) return w(p, h, f, y); tr(p, f) } return typeof f == "string" && f !== "" || typeof f == "number" ? (f = "" + f, h !== null && h.tag === 6 ? (i(p, h.sibling), h = r(h, f), h.return = p, p = h) : (i(p, h), h = Mo(f, p.mode, y), h.return = p, p = h), s(p)) : i(p, h) } return C } var Gi = xd(!0), kd = xd(!1), Wn = {}, at = $t(Wn), Pn = $t(Wn), zn = $t(Wn); function ei(t) { if (t === Wn) throw Error(D(174)); return t } function cl(t, e) { switch (j(zn, e), j(Pn, t), j(at, Wn), t = e.nodeType, t) { case 9: case 11: e = (e = e.documentElement) ? e.namespaceURI : Xo(null, ""); break; default: t = t === 8 ? e.parentNode : e, e = t.namespaceURI || null, t = t.tagName, e = Xo(e, t) }J(at), j(at, e) } function Vi() { J(at), J(Pn), J(zn) } function Pd(t) { ei(zn.current); var e = ei(at.current), i = Xo(e, t.type); e !== i && (j(Pn, t), j(at, i)) } function pl(t) { Pn.current === t && (J(at), J(Pn)) } var Z = $t(0); function Vr(t) { for (var e = t; e !== null;) { if (e.tag === 13) { var i = e.memoizedState; if (i !== null && (i = i.dehydrated, i === null || i.data === "$?" || i.data === "$!")) return e } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) { if (e.flags & 128) return e } else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === t) break; for (; e.sibling === null;) { if (e.return === null || e.return === t) return null; e = e.return } e.sibling.return = e.return, e = e.sibling } return null } var Oo = []; function fl() { for (var t = 0; t < Oo.length; t++)Oo[t]._workInProgressVersionPrimary = null; Oo.length = 0 } var mr = St.ReactCurrentDispatcher, Lo = St.ReactCurrentBatchConfig, si = 0, Y = null, le = null, he = null, Mr = !1, hn = !1, An = 0, Rp = 0; function ve() { throw Error(D(321)) } function ml(t, e) { if (e === null) return !1; for (var i = 0; i < e.length && i < t.length; i++)if (!it(t[i], e[i])) return !1; return !0 } function vl(t, e, i, n, r, o) { if (si = o, Y = e, e.memoizedState = null, e.updateQueue = null, e.lanes = 0, mr.current = t === null || t.memoizedState === null ? Mp : bp, t = i(n, r), hn) { o = 0; do { if (hn = !1, An = 0, 25 <= o) throw Error(D(301)); o += 1, he = le = null, e.updateQueue = null, mr.current = Wp, t = i(n, r) } while (hn) } if (mr.current = br, e = le !== null && le.next !== null, si = 0, he = le = Y = null, Mr = !1, e) throw Error(D(300)); return t } function gl() { var t = An !== 0; return An = 0, t } function rt() { var t = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return he === null ? Y.memoizedState = he = t : he = he.next = t, he } function Je() { if (le === null) { var t = Y.alternate; t = t !== null ? t.memoizedState : null } else t = le.next; var e = he === null ? Y.memoizedState : he.next; if (e !== null) he = e, le = t; else { if (t === null) throw Error(D(310)); le = t, t = { memoizedState: le.memoizedState, baseState: le.baseState, baseQueue: le.baseQueue, queue: le.queue, next: null }, he === null ? Y.memoizedState = he = t : he = he.next = t } return he } function In(t, e) { return typeof e == "function" ? e(t) : e } function Ro(t) { var e = Je(), i = e.queue; if (i === null) throw Error(D(311)); i.lastRenderedReducer = t; var n = le, r = n.baseQueue, o = i.pending; if (o !== null) { if (r !== null) { var s = r.next; r.next = o.next, o.next = s } n.baseQueue = r = o, i.pending = null } if (r !== null) { o = r.next, n = n.baseState; var l = s = null, a = null, u = o; do { var m = u.lane; if ((si & m) === m) a !== null && (a = a.next = { lane: 0, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }), n = u.hasEagerState ? u.eagerState : t(n, u.action); else { var d = { lane: m, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }; a === null ? (l = a = d, s = n) : a = a.next = d, Y.lanes |= m, li |= m } u = u.next } while (u !== null && u !== o); a === null ? s = n : a.next = l, it(n, e.memoizedState) || (ke = !0), e.memoizedState = n, e.baseState = s, e.baseQueue = a, i.lastRenderedState = n } if (t = i.interleaved, t !== null) { r = t; do o = r.lane, Y.lanes |= o, li |= o, r = r.next; while (r !== t) } else r === null && (i.lanes = 0); return [e.memoizedState, i.dispatch] } function To(t) { var e = Je(), i = e.queue; if (i === null) throw Error(D(311)); i.lastRenderedReducer = t; var n = i.dispatch, r = i.pending, o = e.memoizedState; if (r !== null) { i.pending = null; var s = r = r.next; do o = t(o, s.action), s = s.next; while (s !== r); it(o, e.memoizedState) || (ke = !0), e.memoizedState = o, e.baseQueue === null && (e.baseState = o), i.lastRenderedState = o } return [o, n] } function zd() { } function Ad(t, e) { var i = Y, n = Je(), r = e(), o = !it(n.memoizedState, r); if (o && (n.memoizedState = r, ke = !0), n = n.queue, wl(Od.bind(null, i, n, t), [t]), n.getSnapshot !== e || o || he !== null && he.memoizedState.tag & 1) { if (i.flags |= 2048, Nn(9, Nd.bind(null, i, n, r, e), void 0, null), ce === null) throw Error(D(349)); si & 30 || Id(i, e, r) } return r } function Id(t, e, i) { t.flags |= 16384, t = { getSnapshot: e, value: i }, e = Y.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, Y.updateQueue = e, e.stores = [t]) : (i = e.stores, i === null ? e.stores = [t] : i.push(t)) } function Nd(t, e, i, n) { e.value = i, e.getSnapshot = n, Ld(e) && Rd(t) } function Od(t, e, i) { return i(function () { Ld(e) && Rd(t) }) } function Ld(t) { var e = t.getSnapshot; t = t.value; try { var i = e(); return !it(t, i) } catch { return !0 } } function Rd(t) { var e = yt(t, 1); e !== null && tt(e, t, 1, -1) } function za(t) { var e = rt(); return typeof t == "function" && (t = t()), e.memoizedState = e.baseState = t, t = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: In, lastRenderedState: t }, e.queue = t, t = t.dispatch = Vp.bind(null, Y, t), [e.memoizedState, t] } function Nn(t, e, i, n) { return t = { tag: t, create: e, destroy: i, deps: n, next: null }, e = Y.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, Y.updateQueue = e, e.lastEffect = t.next = t) : (i = e.lastEffect, i === null ? e.lastEffect = t.next = t : (n = i.next, i.next = t, t.next = n, e.lastEffect = t)), t } function Td() { return Je().memoizedState } function vr(t, e, i, n) { var r = rt(); Y.flags |= t, r.memoizedState = Nn(1 | e, i, void 0, n === void 0 ? null : n) } function io(t, e, i, n) { var r = Je(); n = n === void 0 ? null : n; var o = void 0; if (le !== null) { var s = le.memoizedState; if (o = s.destroy, n !== null && ml(n, s.deps)) { r.memoizedState = Nn(e, i, o, n); return } } Y.flags |= t, r.memoizedState = Nn(1 | e, i, o, n) } function Aa(t, e) { return vr(8390656, 8, t, e) } function wl(t, e) { return io(2048, 8, t, e) } function Gd(t, e) { return io(4, 2, t, e) } function Vd(t, e) { return io(4, 4, t, e) } function Md(t, e) { if (typeof e == "function") return t = t(), e(t), function () { e(null) }; if (e != null) return t = t(), e.current = t, function () { e.current = null } } function bd(t, e, i) { return i = i != null ? i.concat([t]) : null, io(4, 4, Md.bind(null, e, t), i) } function _l() { } function Wd(t, e) { var i = Je(); e = e === void 0 ? null : e; var n = i.memoizedState; return n !== null && e !== null && ml(e, n[1]) ? n[0] : (i.memoizedState = [t, e], t) } function Hd(t, e) { var i = Je(); e = e === void 0 ? null : e; var n = i.memoizedState; return n !== null && e !== null && ml(e, n[1]) ? n[0] : (t = t(), i.memoizedState = [t, e], t) } function Fd(t, e, i) { return si & 21 ? (it(i, e) || (i = Uu(), Y.lanes |= i, li |= i, t.baseState = !0), e) : (t.baseState && (t.baseState = !1, ke = !0), t.memoizedState = i) } function Tp(t, e) { var i = H; H = i !== 0 && 4 > i ? i : 4, t(!0); var n = Lo.transition; Lo.transition = {}; try { t(!1), e() } finally { H = i, Lo.transition = n } } function Bd() { return Je().memoizedState } function Gp(t, e, i) { var n = Wt(t); if (i = { lane: n, action: i, hasEagerState: !1, eagerState: null, next: null }, jd(t)) Ud(e, i); else if (i = Dd(t, e, i, n), i !== null) { var r = Ce(); tt(i, t, n, r), $d(i, e, n) } } function Vp(t, e, i) { var n = Wt(t), r = { lane: n, action: i, hasEagerState: !1, eagerState: null, next: null }; if (jd(t)) Ud(e, r); else { var o = t.alternate; if (t.lanes === 0 && (o === null || o.lanes === 0) && (o = e.lastRenderedReducer, o !== null)) try { var s = e.lastRenderedState, l = o(s, i); if (r.hasEagerState = !0, r.eagerState = l, it(l, s)) { var a = e.interleaved; a === null ? (r.next = r, dl(e)) : (r.next = a.next, a.next = r), e.interleaved = r; return } } catch { } finally { } i = Dd(t, e, r, n), i !== null && (r = Ce(), tt(i, t, n, r), $d(i, e, n)) } } function jd(t) { var e = t.alternate; return t === Y || e !== null && e === Y } function Ud(t, e) { hn = Mr = !0; var i = t.pending; i === null ? e.next = e : (e.next = i.next, i.next = e), t.pending = e } function $d(t, e, i) { if (i & 4194240) { var n = e.lanes; n &= t.pendingLanes, i |= n, e.lanes = i, Ys(t, i) } } var br = { readContext: $e, useCallback: ve, useContext: ve, useEffect: ve, useImperativeHandle: ve, useInsertionEffect: ve, useLayoutEffect: ve, useMemo: ve, useReducer: ve, useRef: ve, useState: ve, useDebugValue: ve, useDeferredValue: ve, useTransition: ve, useMutableSource: ve, useSyncExternalStore: ve, useId: ve, unstable_isNewReconciler: !1 }, Mp = { readContext: $e, useCallback: function (t, e) { return rt().memoizedState = [t, e === void 0 ? null : e], t }, useContext: $e, useEffect: Aa, useImperativeHandle: function (t, e, i) { return i = i != null ? i.concat([t]) : null, vr(4194308, 4, Md.bind(null, e, t), i) }, useLayoutEffect: function (t, e) { return vr(4194308, 4, t, e) }, useInsertionEffect: function (t, e) { return vr(4, 2, t, e) }, useMemo: function (t, e) { var i = rt(); return e = e === void 0 ? null : e, t = t(), i.memoizedState = [t, e], t }, useReducer: function (t, e, i) { var n = rt(); return e = i !== void 0 ? i(e) : e, n.memoizedState = n.baseState = e, t = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: t, lastRenderedState: e }, n.queue = t, t = t.dispatch = Gp.bind(null, Y, t), [n.memoizedState, t] }, useRef: function (t) { var e = rt(); return t = { current: t }, e.memoizedState = t }, useState: za, useDebugValue: _l, useDeferredValue: function (t) { return rt().memoizedState = t }, useTransition: function () { var t = za(!1), e = t[0]; return t = Tp.bind(null, t[1]), rt().memoizedState = t, [e, t] }, useMutableSource: function () { }, useSyncExternalStore: function (t, e, i) { var n = Y, r = rt(); if (Q) { if (i === void 0) throw Error(D(407)); i = i() } else { if (i = e(), ce === null) throw Error(D(349)); si & 30 || Id(n, e, i) } r.memoizedState = i; var o = { value: i, getSnapshot: e }; return r.queue = o, Aa(Od.bind(null, n, o, t), [t]), n.flags |= 2048, Nn(9, Nd.bind(null, n, o, i, e), void 0, null), i }, useId: function () { var t = rt(), e = ce.identifierPrefix; if (Q) { var i = ft, n = pt; i = (n & ~(1 << 32 - et(n) - 1)).toString(32) + i, e = ":" + e + "R" + i, i = An++, 0 < i && (e += "H" + i.toString(32)), e += ":" } else i = Rp++, e = ":" + e + "r" + i.toString(32) + ":"; return t.memoizedState = e }, unstable_isNewReconciler: !1 }, bp = { readContext: $e, useCallback: Wd, useContext: $e, useEffect: wl, useImperativeHandle: bd, useInsertionEffect: Gd, useLayoutEffect: Vd, useMemo: Hd, useReducer: Ro, useRef: Td, useState: function () { return Ro(In) }, useDebugValue: _l, useDeferredValue: function (t) { var e = Je(); return Fd(e, le.memoizedState, t) }, useTransition: function () { var t = Ro(In)[0], e = Je().memoizedState; return [t, e] }, useMutableSource: zd, useSyncExternalStore: Ad, useId: Bd, unstable_isNewReconciler: !1 }, Wp = { readContext: $e, useCallback: Wd, useContext: $e, useEffect: wl, useImperativeHandle: bd, useInsertionEffect: Gd, useLayoutEffect: Vd, useMemo: Hd, useReducer: To, useRef: Td, useState: function () { return To(In) }, useDebugValue: _l, useDeferredValue: function (t) { var e = Je(); return le === null ? e.memoizedState = t : Fd(e, le.memoizedState, t) }, useTransition: function () { var t = To(In)[0], e = Je().memoizedState; return [t, e] }, useMutableSource: zd, useSyncExternalStore: Ad, useId: Bd, unstable_isNewReconciler: !1 }; function Mi(t, e) {
    try { var i = "", n = e; do i += fc(n), n = n.return; while (n); var r = i } catch (o) {
        r = `
Error generating stack: `+ o.message + `
`+ o.stack
    } return { value: t, source: e, stack: r, digest: null }
} function Go(t, e, i) { return { value: t, source: null, stack: i ?? null, digest: e ?? null } } function Ds(t, e) { try { console.error(e.value) } catch (i) { setTimeout(function () { throw i }) } } var Hp = typeof WeakMap == "function" ? WeakMap : Map; function Jd(t, e, i) { i = gt(-1, i), i.tag = 3, i.payload = { element: null }; var n = e.value; return i.callback = function () { Hr || (Hr = !0, Ns = n), Ds(t, e) }, i } function Qd(t, e, i) { i = gt(-1, i), i.tag = 3; var n = t.type.getDerivedStateFromError; if (typeof n == "function") { var r = e.value; i.payload = function () { return n(r) }, i.callback = function () { Ds(t, e) } } var o = t.stateNode; return o !== null && typeof o.componentDidCatch == "function" && (i.callback = function () { Ds(t, e), typeof n != "function" && (bt === null ? bt = new Set([this]) : bt.add(this)); var s = e.stack; this.componentDidCatch(e.value, { componentStack: s !== null ? s : "" }) }), i } function Ia(t, e, i) { var n = t.pingCache; if (n === null) { n = t.pingCache = new Hp; var r = new Set; n.set(e, r) } else r = n.get(e), r === void 0 && (r = new Set, n.set(e, r)); r.has(i) || (r.add(i), t = tf.bind(null, t, e, i), e.then(t, t)) } function Na(t) { do { var e; if ((e = t.tag === 13) && (e = t.memoizedState, e = e !== null ? e.dehydrated !== null : !0), e) return t; t = t.return } while (t !== null); return null } function Oa(t, e, i, n, r) { return t.mode & 1 ? (t.flags |= 65536, t.lanes = r, t) : (t === e ? t.flags |= 65536 : (t.flags |= 128, i.flags |= 131072, i.flags &= -52805, i.tag === 1 && (i.alternate === null ? i.tag = 17 : (e = gt(-1, 1), e.tag = 2, Mt(i, e, 1))), i.lanes |= 1), t) } var Fp = St.ReactCurrentOwner, ke = !1; function De(t, e, i, n) { e.child = t === null ? kd(e, null, i, n) : Gi(e, t.child, i, n) } function La(t, e, i, n, r) { i = i.render; var o = e.ref; return Ni(e, r), n = vl(t, e, i, n, o, r), i = gl(), t !== null && !ke ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~r, Dt(t, e, r)) : (Q && i && rl(e), e.flags |= 1, De(t, e, n, r), e.child) } function Ra(t, e, i, n, r) { if (t === null) { var o = i.type; return typeof o == "function" && !Pl(o) && o.defaultProps === void 0 && i.compare === null && i.defaultProps === void 0 ? (e.tag = 15, e.type = o, Zd(t, e, o, n, r)) : (t = yr(i.type, null, n, e, e.mode, r), t.ref = e.ref, t.return = e, e.child = t) } if (o = t.child, !(t.lanes & r)) { var s = o.memoizedProps; if (i = i.compare, i = i !== null ? i : Sn, i(s, n) && t.ref === e.ref) return Dt(t, e, r) } return e.flags |= 1, t = Ht(o, n), t.ref = e.ref, t.return = e, e.child = t } function Zd(t, e, i, n, r) { if (t !== null) { var o = t.memoizedProps; if (Sn(o, n) && t.ref === e.ref) if (ke = !1, e.pendingProps = n = o, (t.lanes & r) !== 0) t.flags & 131072 && (ke = !0); else return e.lanes = t.lanes, Dt(t, e, r) } return Cs(t, e, i, n, r) } function Yd(t, e, i) { var n = e.pendingProps, r = n.children, o = t !== null ? t.memoizedState : null; if (n.mode === "hidden") if (!(e.mode & 1)) e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, j(ki, Ie), Ie |= i; else { if (!(i & 1073741824)) return t = o !== null ? o.baseLanes | i : i, e.lanes = e.childLanes = 1073741824, e.memoizedState = { baseLanes: t, cachePool: null, transitions: null }, e.updateQueue = null, j(ki, Ie), Ie |= t, null; e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, n = o !== null ? o.baseLanes : i, j(ki, Ie), Ie |= n } else o !== null ? (n = o.baseLanes | i, e.memoizedState = null) : n = i, j(ki, Ie), Ie |= n; return De(t, e, r, i), e.child } function Kd(t, e) { var i = e.ref; (t === null && i !== null || t !== null && t.ref !== i) && (e.flags |= 512, e.flags |= 2097152) } function Cs(t, e, i, n, r) { var o = ze(i) ? ri : _e.current; return o = Ri(e, o), Ni(e, r), i = vl(t, e, i, n, o, r), n = gl(), t !== null && !ke ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~r, Dt(t, e, r)) : (Q && n && rl(e), e.flags |= 1, De(t, e, i, r), e.child) } function Ta(t, e, i, n, r) { if (ze(i)) { var o = !0; Nr(e) } else o = !1; if (Ni(e, r), e.stateNode === null) gr(t, e), Ed(e, i, n), ys(e, i, n, r), n = !0; else if (t === null) { var s = e.stateNode, l = e.memoizedProps; s.props = l; var a = s.context, u = i.contextType; typeof u == "object" && u !== null ? u = $e(u) : (u = ze(i) ? ri : _e.current, u = Ri(e, u)); var m = i.getDerivedStateFromProps, d = typeof m == "function" || typeof s.getSnapshotBeforeUpdate == "function"; d || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (l !== n || a !== u) && ka(e, s, n, u), kt = !1; var c = e.memoizedState; s.state = c, Gr(e, n, s, r), a = e.memoizedState, l !== n || c !== a || Pe.current || kt ? (typeof m == "function" && (_s(e, i, m, n), a = e.memoizedState), (l = kt || xa(e, i, l, n, c, a, u)) ? (d || typeof s.UNSAFE_componentWillMount != "function" && typeof s.componentWillMount != "function" || (typeof s.componentWillMount == "function" && s.componentWillMount(), typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount()), typeof s.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof s.componentDidMount == "function" && (e.flags |= 4194308), e.memoizedProps = n, e.memoizedState = a), s.props = n, s.state = a, s.context = u, n = l) : (typeof s.componentDidMount == "function" && (e.flags |= 4194308), n = !1) } else { s = e.stateNode, Cd(t, e), l = e.memoizedProps, u = e.type === e.elementType ? l : Ke(e.type, l), s.props = u, d = e.pendingProps, c = s.context, a = i.contextType, typeof a == "object" && a !== null ? a = $e(a) : (a = ze(i) ? ri : _e.current, a = Ri(e, a)); var v = i.getDerivedStateFromProps; (m = typeof v == "function" || typeof s.getSnapshotBeforeUpdate == "function") || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (l !== d || c !== a) && ka(e, s, n, a), kt = !1, c = e.memoizedState, s.state = c, Gr(e, n, s, r); var g = e.memoizedState; l !== d || c !== g || Pe.current || kt ? (typeof v == "function" && (_s(e, i, v, n), g = e.memoizedState), (u = kt || xa(e, i, u, n, c, g, a) || !1) ? (m || typeof s.UNSAFE_componentWillUpdate != "function" && typeof s.componentWillUpdate != "function" || (typeof s.componentWillUpdate == "function" && s.componentWillUpdate(n, g, a), typeof s.UNSAFE_componentWillUpdate == "function" && s.UNSAFE_componentWillUpdate(n, g, a)), typeof s.componentDidUpdate == "function" && (e.flags |= 4), typeof s.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof s.componentDidUpdate != "function" || l === t.memoizedProps && c === t.memoizedState || (e.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || l === t.memoizedProps && c === t.memoizedState || (e.flags |= 1024), e.memoizedProps = n, e.memoizedState = g), s.props = n, s.state = g, s.context = a, n = u) : (typeof s.componentDidUpdate != "function" || l === t.memoizedProps && c === t.memoizedState || (e.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || l === t.memoizedProps && c === t.memoizedState || (e.flags |= 1024), n = !1) } return Ss(t, e, i, n, o, r) } function Ss(t, e, i, n, r, o) { Kd(t, e); var s = (e.flags & 128) !== 0; if (!n && !s) return r && ya(e, i, !1), Dt(t, e, o); n = e.stateNode, Fp.current = e; var l = s && typeof i.getDerivedStateFromError != "function" ? null : n.render(); return e.flags |= 1, t !== null && s ? (e.child = Gi(e, t.child, null, o), e.child = Gi(e, null, l, o)) : De(t, e, l, o), e.memoizedState = n.state, r && ya(e, i, !0), e.child } function Xd(t) { var e = t.stateNode; e.pendingContext ? _a(t, e.pendingContext, e.pendingContext !== e.context) : e.context && _a(t, e.context, !1), cl(t, e.containerInfo) } function Ga(t, e, i, n, r) { return Ti(), sl(r), e.flags |= 256, De(t, e, i, n), e.child } var Es = { dehydrated: null, treeContext: null, retryLane: 0 }; function xs(t) { return { baseLanes: t, cachePool: null, transitions: null } } function qd(t, e, i) { var n = e.pendingProps, r = Z.current, o = !1, s = (e.flags & 128) !== 0, l; if ((l = s) || (l = t !== null && t.memoizedState === null ? !1 : (r & 2) !== 0), l ? (o = !0, e.flags &= -129) : (t === null || t.memoizedState !== null) && (r |= 1), j(Z, r & 1), t === null) return gs(e), t = e.memoizedState, t !== null && (t = t.dehydrated, t !== null) ? (e.mode & 1 ? t.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1, null) : (s = n.children, t = n.fallback, o ? (n = e.mode, o = e.child, s = { mode: "hidden", children: s }, !(n & 1) && o !== null ? (o.childLanes = 0, o.pendingProps = s) : o = oo(s, n, 0, null), t = ii(t, n, i, null), o.return = e, t.return = e, o.sibling = t, e.child = o, e.child.memoizedState = xs(i), e.memoizedState = Es, t) : yl(e, s)); if (r = t.memoizedState, r !== null && (l = r.dehydrated, l !== null)) return Bp(t, e, s, n, l, r, i); if (o) { o = n.fallback, s = e.mode, r = t.child, l = r.sibling; var a = { mode: "hidden", children: n.children }; return !(s & 1) && e.child !== r ? (n = e.child, n.childLanes = 0, n.pendingProps = a, e.deletions = null) : (n = Ht(r, a), n.subtreeFlags = r.subtreeFlags & 14680064), l !== null ? o = Ht(l, o) : (o = ii(o, s, i, null), o.flags |= 2), o.return = e, n.return = e, n.sibling = o, e.child = n, n = o, o = e.child, s = t.child.memoizedState, s = s === null ? xs(i) : { baseLanes: s.baseLanes | i, cachePool: null, transitions: s.transitions }, o.memoizedState = s, o.childLanes = t.childLanes & ~i, e.memoizedState = Es, n } return o = t.child, t = o.sibling, n = Ht(o, { mode: "visible", children: n.children }), !(e.mode & 1) && (n.lanes = i), n.return = e, n.sibling = null, t !== null && (i = e.deletions, i === null ? (e.deletions = [t], e.flags |= 16) : i.push(t)), e.child = n, e.memoizedState = null, n } function yl(t, e) { return e = oo({ mode: "visible", children: e }, t.mode, 0, null), e.return = t, t.child = e } function ir(t, e, i, n) { return n !== null && sl(n), Gi(e, t.child, null, i), t = yl(e, e.pendingProps.children), t.flags |= 2, e.memoizedState = null, t } function Bp(t, e, i, n, r, o, s) { if (i) return e.flags & 256 ? (e.flags &= -257, n = Go(Error(D(422))), ir(t, e, s, n)) : e.memoizedState !== null ? (e.child = t.child, e.flags |= 128, null) : (o = n.fallback, r = e.mode, n = oo({ mode: "visible", children: n.children }, r, 0, null), o = ii(o, r, s, null), o.flags |= 2, n.return = e, o.return = e, n.sibling = o, e.child = n, e.mode & 1 && Gi(e, t.child, null, s), e.child.memoizedState = xs(s), e.memoizedState = Es, o); if (!(e.mode & 1)) return ir(t, e, s, null); if (r.data === "$!") { if (n = r.nextSibling && r.nextSibling.dataset, n) var l = n.dgst; return n = l, o = Error(D(419)), n = Go(o, n, void 0), ir(t, e, s, n) } if (l = (s & t.childLanes) !== 0, ke || l) { if (n = ce, n !== null) { switch (s & -s) { case 4: r = 2; break; case 16: r = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: r = 32; break; case 536870912: r = 268435456; break; default: r = 0 }r = r & (n.suspendedLanes | s) ? 0 : r, r !== 0 && r !== o.retryLane && (o.retryLane = r, yt(t, r), tt(n, t, r, -1)) } return kl(), n = Go(Error(D(421))), ir(t, e, s, n) } return r.data === "$?" ? (e.flags |= 128, e.child = t.child, e = nf.bind(null, t), r._reactRetry = e, null) : (t = o.treeContext, Ne = Vt(r.nextSibling), Re = e, Q = !0, qe = null, t !== null && (We[He++] = pt, We[He++] = ft, We[He++] = oi, pt = t.id, ft = t.overflow, oi = e), e = yl(e, n.children), e.flags |= 4096, e) } function Va(t, e, i) { t.lanes |= e; var n = t.alternate; n !== null && (n.lanes |= e), ws(t.return, e, i) } function Vo(t, e, i, n, r) { var o = t.memoizedState; o === null ? t.memoizedState = { isBackwards: e, rendering: null, renderingStartTime: 0, last: n, tail: i, tailMode: r } : (o.isBackwards = e, o.rendering = null, o.renderingStartTime = 0, o.last = n, o.tail = i, o.tailMode = r) } function eh(t, e, i) { var n = e.pendingProps, r = n.revealOrder, o = n.tail; if (De(t, e, n.children, i), n = Z.current, n & 2) n = n & 1 | 2, e.flags |= 128; else { if (t !== null && t.flags & 128) e: for (t = e.child; t !== null;) { if (t.tag === 13) t.memoizedState !== null && Va(t, i, e); else if (t.tag === 19) Va(t, i, e); else if (t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break e; for (; t.sibling === null;) { if (t.return === null || t.return === e) break e; t = t.return } t.sibling.return = t.return, t = t.sibling } n &= 1 } if (j(Z, n), !(e.mode & 1)) e.memoizedState = null; else switch (r) { case "forwards": for (i = e.child, r = null; i !== null;)t = i.alternate, t !== null && Vr(t) === null && (r = i), i = i.sibling; i = r, i === null ? (r = e.child, e.child = null) : (r = i.sibling, i.sibling = null), Vo(e, !1, r, i, o); break; case "backwards": for (i = null, r = e.child, e.child = null; r !== null;) { if (t = r.alternate, t !== null && Vr(t) === null) { e.child = r; break } t = r.sibling, r.sibling = i, i = r, r = t } Vo(e, !0, i, null, o); break; case "together": Vo(e, !1, null, null, void 0); break; default: e.memoizedState = null }return e.child } function gr(t, e) { !(e.mode & 1) && t !== null && (t.alternate = null, e.alternate = null, e.flags |= 2) } function Dt(t, e, i) { if (t !== null && (e.dependencies = t.dependencies), li |= e.lanes, !(i & e.childLanes)) return null; if (t !== null && e.child !== t.child) throw Error(D(153)); if (e.child !== null) { for (t = e.child, i = Ht(t, t.pendingProps), e.child = i, i.return = e; t.sibling !== null;)t = t.sibling, i = i.sibling = Ht(t, t.pendingProps), i.return = e; i.sibling = null } return e.child } function jp(t, e, i) { switch (e.tag) { case 3: Xd(e), Ti(); break; case 5: Pd(e); break; case 1: ze(e.type) && Nr(e); break; case 4: cl(e, e.stateNode.containerInfo); break; case 10: var n = e.type._context, r = e.memoizedProps.value; j(Rr, n._currentValue), n._currentValue = r; break; case 13: if (n = e.memoizedState, n !== null) return n.dehydrated !== null ? (j(Z, Z.current & 1), e.flags |= 128, null) : i & e.child.childLanes ? qd(t, e, i) : (j(Z, Z.current & 1), t = Dt(t, e, i), t !== null ? t.sibling : null); j(Z, Z.current & 1); break; case 19: if (n = (i & e.childLanes) !== 0, t.flags & 128) { if (n) return eh(t, e, i); e.flags |= 128 } if (r = e.memoizedState, r !== null && (r.rendering = null, r.tail = null, r.lastEffect = null), j(Z, Z.current), n) break; return null; case 22: case 23: return e.lanes = 0, Yd(t, e, i) }return Dt(t, e, i) } var th, ks, ih, nh; th = function (t, e) { for (var i = e.child; i !== null;) { if (i.tag === 5 || i.tag === 6) t.appendChild(i.stateNode); else if (i.tag !== 4 && i.child !== null) { i.child.return = i, i = i.child; continue } if (i === e) break; for (; i.sibling === null;) { if (i.return === null || i.return === e) return; i = i.return } i.sibling.return = i.return, i = i.sibling } }; ks = function () { }; ih = function (t, e, i, n) { var r = t.memoizedProps; if (r !== n) { t = e.stateNode, ei(at.current); var o = null; switch (i) { case "input": r = Qo(t, r), n = Qo(t, n), o = []; break; case "select": r = K({}, r, { value: void 0 }), n = K({}, n, { value: void 0 }), o = []; break; case "textarea": r = Ko(t, r), n = Ko(t, n), o = []; break; default: typeof r.onClick != "function" && typeof n.onClick == "function" && (t.onclick = Ar) }qo(i, n); var s; i = null; for (u in r) if (!n.hasOwnProperty(u) && r.hasOwnProperty(u) && r[u] != null) if (u === "style") { var l = r[u]; for (s in l) l.hasOwnProperty(s) && (i || (i = {}), i[s] = "") } else u !== "dangerouslySetInnerHTML" && u !== "children" && u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && u !== "autoFocus" && (vn.hasOwnProperty(u) ? o || (o = []) : (o = o || []).push(u, null)); for (u in n) { var a = n[u]; if (l = r != null ? r[u] : void 0, n.hasOwnProperty(u) && a !== l && (a != null || l != null)) if (u === "style") if (l) { for (s in l) !l.hasOwnProperty(s) || a && a.hasOwnProperty(s) || (i || (i = {}), i[s] = ""); for (s in a) a.hasOwnProperty(s) && l[s] !== a[s] && (i || (i = {}), i[s] = a[s]) } else i || (o || (o = []), o.push(u, i)), i = a; else u === "dangerouslySetInnerHTML" ? (a = a ? a.__html : void 0, l = l ? l.__html : void 0, a != null && l !== a && (o = o || []).push(u, a)) : u === "children" ? typeof a != "string" && typeof a != "number" || (o = o || []).push(u, "" + a) : u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && (vn.hasOwnProperty(u) ? (a != null && u === "onScroll" && U("scroll", t), o || l === a || (o = [])) : (o = o || []).push(u, a)) } i && (o = o || []).push("style", i); var u = o; (e.updateQueue = u) && (e.flags |= 4) } }; nh = function (t, e, i, n) { i !== n && (e.flags |= 4) }; function Ki(t, e) { if (!Q) switch (t.tailMode) { case "hidden": e = t.tail; for (var i = null; e !== null;)e.alternate !== null && (i = e), e = e.sibling; i === null ? t.tail = null : i.sibling = null; break; case "collapsed": i = t.tail; for (var n = null; i !== null;)i.alternate !== null && (n = i), i = i.sibling; n === null ? e || t.tail === null ? t.tail = null : t.tail.sibling = null : n.sibling = null } } function ge(t) { var e = t.alternate !== null && t.alternate.child === t.child, i = 0, n = 0; if (e) for (var r = t.child; r !== null;)i |= r.lanes | r.childLanes, n |= r.subtreeFlags & 14680064, n |= r.flags & 14680064, r.return = t, r = r.sibling; else for (r = t.child; r !== null;)i |= r.lanes | r.childLanes, n |= r.subtreeFlags, n |= r.flags, r.return = t, r = r.sibling; return t.subtreeFlags |= n, t.childLanes = i, e } function Up(t, e, i) { var n = e.pendingProps; switch (ol(e), e.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return ge(e), null; case 1: return ze(e.type) && Ir(), ge(e), null; case 3: return n = e.stateNode, Vi(), J(Pe), J(_e), fl(), n.pendingContext && (n.context = n.pendingContext, n.pendingContext = null), (t === null || t.child === null) && (er(e) ? e.flags |= 4 : t === null || t.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024, qe !== null && (Rs(qe), qe = null))), ks(t, e), ge(e), null; case 5: pl(e); var r = ei(zn.current); if (i = e.type, t !== null && e.stateNode != null) ih(t, e, i, n, r), t.ref !== e.ref && (e.flags |= 512, e.flags |= 2097152); else { if (!n) { if (e.stateNode === null) throw Error(D(166)); return ge(e), null } if (t = ei(at.current), er(e)) { n = e.stateNode, i = e.type; var o = e.memoizedProps; switch (n[st] = e, n[kn] = o, t = (e.mode & 1) !== 0, i) { case "dialog": U("cancel", n), U("close", n); break; case "iframe": case "object": case "embed": U("load", n); break; case "video": case "audio": for (r = 0; r < on.length; r++)U(on[r], n); break; case "source": U("error", n); break; case "img": case "image": case "link": U("error", n), U("load", n); break; case "details": U("toggle", n); break; case "input": $l(n, o), U("invalid", n); break; case "select": n._wrapperState = { wasMultiple: !!o.multiple }, U("invalid", n); break; case "textarea": Ql(n, o), U("invalid", n) }qo(i, o), r = null; for (var s in o) if (o.hasOwnProperty(s)) { var l = o[s]; s === "children" ? typeof l == "string" ? n.textContent !== l && (o.suppressHydrationWarning !== !0 && qn(n.textContent, l, t), r = ["children", l]) : typeof l == "number" && n.textContent !== "" + l && (o.suppressHydrationWarning !== !0 && qn(n.textContent, l, t), r = ["children", "" + l]) : vn.hasOwnProperty(s) && l != null && s === "onScroll" && U("scroll", n) } switch (i) { case "input": Un(n), Jl(n, o, !0); break; case "textarea": Un(n), Zl(n); break; case "select": case "option": break; default: typeof o.onClick == "function" && (n.onclick = Ar) }n = r, e.updateQueue = n, n !== null && (e.flags |= 4) } else { s = r.nodeType === 9 ? r : r.ownerDocument, t === "http://www.w3.org/1999/xhtml" && (t = Iu(i)), t === "http://www.w3.org/1999/xhtml" ? i === "script" ? (t = s.createElement("div"), t.innerHTML = "<script><\/script>", t = t.removeChild(t.firstChild)) : typeof n.is == "string" ? t = s.createElement(i, { is: n.is }) : (t = s.createElement(i), i === "select" && (s = t, n.multiple ? s.multiple = !0 : n.size && (s.size = n.size))) : t = s.createElementNS(t, i), t[st] = e, t[kn] = n, th(t, e, !1, !1), e.stateNode = t; e: { switch (s = es(i, n), i) { case "dialog": U("cancel", t), U("close", t), r = n; break; case "iframe": case "object": case "embed": U("load", t), r = n; break; case "video": case "audio": for (r = 0; r < on.length; r++)U(on[r], t); r = n; break; case "source": U("error", t), r = n; break; case "img": case "image": case "link": U("error", t), U("load", t), r = n; break; case "details": U("toggle", t), r = n; break; case "input": $l(t, n), r = Qo(t, n), U("invalid", t); break; case "option": r = n; break; case "select": t._wrapperState = { wasMultiple: !!n.multiple }, r = K({}, n, { value: void 0 }), U("invalid", t); break; case "textarea": Ql(t, n), r = Ko(t, n), U("invalid", t); break; default: r = n }qo(i, r), l = r; for (o in l) if (l.hasOwnProperty(o)) { var a = l[o]; o === "style" ? Lu(t, a) : o === "dangerouslySetInnerHTML" ? (a = a ? a.__html : void 0, a != null && Nu(t, a)) : o === "children" ? typeof a == "string" ? (i !== "textarea" || a !== "") && gn(t, a) : typeof a == "number" && gn(t, "" + a) : o !== "suppressContentEditableWarning" && o !== "suppressHydrationWarning" && o !== "autoFocus" && (vn.hasOwnProperty(o) ? a != null && o === "onScroll" && U("scroll", t) : a != null && js(t, o, a, s)) } switch (i) { case "input": Un(t), Jl(t, n, !1); break; case "textarea": Un(t), Zl(t); break; case "option": n.value != null && t.setAttribute("value", "" + Bt(n.value)); break; case "select": t.multiple = !!n.multiple, o = n.value, o != null ? Pi(t, !!n.multiple, o, !1) : n.defaultValue != null && Pi(t, !!n.multiple, n.defaultValue, !0); break; default: typeof r.onClick == "function" && (t.onclick = Ar) }switch (i) { case "button": case "input": case "select": case "textarea": n = !!n.autoFocus; break e; case "img": n = !0; break e; default: n = !1 } } n && (e.flags |= 4) } e.ref !== null && (e.flags |= 512, e.flags |= 2097152) } return ge(e), null; case 6: if (t && e.stateNode != null) nh(t, e, t.memoizedProps, n); else { if (typeof n != "string" && e.stateNode === null) throw Error(D(166)); if (i = ei(zn.current), ei(at.current), er(e)) { if (n = e.stateNode, i = e.memoizedProps, n[st] = e, (o = n.nodeValue !== i) && (t = Re, t !== null)) switch (t.tag) { case 3: qn(n.nodeValue, i, (t.mode & 1) !== 0); break; case 5: t.memoizedProps.suppressHydrationWarning !== !0 && qn(n.nodeValue, i, (t.mode & 1) !== 0) }o && (e.flags |= 4) } else n = (i.nodeType === 9 ? i : i.ownerDocument).createTextNode(n), n[st] = e, e.stateNode = n } return ge(e), null; case 13: if (J(Z), n = e.memoizedState, t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) { if (Q && Ne !== null && e.mode & 1 && !(e.flags & 128)) yd(), Ti(), e.flags |= 98560, o = !1; else if (o = er(e), n !== null && n.dehydrated !== null) { if (t === null) { if (!o) throw Error(D(318)); if (o = e.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(D(317)); o[st] = e } else Ti(), !(e.flags & 128) && (e.memoizedState = null), e.flags |= 4; ge(e), o = !1 } else qe !== null && (Rs(qe), qe = null), o = !0; if (!o) return e.flags & 65536 ? e : null } return e.flags & 128 ? (e.lanes = i, e) : (n = n !== null, n !== (t !== null && t.memoizedState !== null) && n && (e.child.flags |= 8192, e.mode & 1 && (t === null || Z.current & 1 ? ae === 0 && (ae = 3) : kl())), e.updateQueue !== null && (e.flags |= 4), ge(e), null); case 4: return Vi(), ks(t, e), t === null && En(e.stateNode.containerInfo), ge(e), null; case 10: return ul(e.type._context), ge(e), null; case 17: return ze(e.type) && Ir(), ge(e), null; case 19: if (J(Z), o = e.memoizedState, o === null) return ge(e), null; if (n = (e.flags & 128) !== 0, s = o.rendering, s === null) if (n) Ki(o, !1); else { if (ae !== 0 || t !== null && t.flags & 128) for (t = e.child; t !== null;) { if (s = Vr(t), s !== null) { for (e.flags |= 128, Ki(o, !1), n = s.updateQueue, n !== null && (e.updateQueue = n, e.flags |= 4), e.subtreeFlags = 0, n = i, i = e.child; i !== null;)o = i, t = n, o.flags &= 14680066, s = o.alternate, s === null ? (o.childLanes = 0, o.lanes = t, o.child = null, o.subtreeFlags = 0, o.memoizedProps = null, o.memoizedState = null, o.updateQueue = null, o.dependencies = null, o.stateNode = null) : (o.childLanes = s.childLanes, o.lanes = s.lanes, o.child = s.child, o.subtreeFlags = 0, o.deletions = null, o.memoizedProps = s.memoizedProps, o.memoizedState = s.memoizedState, o.updateQueue = s.updateQueue, o.type = s.type, t = s.dependencies, o.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }), i = i.sibling; return j(Z, Z.current & 1 | 2), e.child } t = t.sibling } o.tail !== null && te() > bi && (e.flags |= 128, n = !0, Ki(o, !1), e.lanes = 4194304) } else { if (!n) if (t = Vr(s), t !== null) { if (e.flags |= 128, n = !0, i = t.updateQueue, i !== null && (e.updateQueue = i, e.flags |= 4), Ki(o, !0), o.tail === null && o.tailMode === "hidden" && !s.alternate && !Q) return ge(e), null } else 2 * te() - o.renderingStartTime > bi && i !== 1073741824 && (e.flags |= 128, n = !0, Ki(o, !1), e.lanes = 4194304); o.isBackwards ? (s.sibling = e.child, e.child = s) : (i = o.last, i !== null ? i.sibling = s : e.child = s, o.last = s) } return o.tail !== null ? (e = o.tail, o.rendering = e, o.tail = e.sibling, o.renderingStartTime = te(), e.sibling = null, i = Z.current, j(Z, n ? i & 1 | 2 : i & 1), e) : (ge(e), null); case 22: case 23: return xl(), n = e.memoizedState !== null, t !== null && t.memoizedState !== null !== n && (e.flags |= 8192), n && e.mode & 1 ? Ie & 1073741824 && (ge(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : ge(e), null; case 24: return null; case 25: return null }throw Error(D(156, e.tag)) } function $p(t, e) { switch (ol(e), e.tag) { case 1: return ze(e.type) && Ir(), t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null; case 3: return Vi(), J(Pe), J(_e), fl(), t = e.flags, t & 65536 && !(t & 128) ? (e.flags = t & -65537 | 128, e) : null; case 5: return pl(e), null; case 13: if (J(Z), t = e.memoizedState, t !== null && t.dehydrated !== null) { if (e.alternate === null) throw Error(D(340)); Ti() } return t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null; case 19: return J(Z), null; case 4: return Vi(), null; case 10: return ul(e.type._context), null; case 22: case 23: return xl(), null; case 24: return null; default: return null } } var nr = !1, we = !1, Jp = typeof WeakSet == "function" ? WeakSet : Set, k = null; function xi(t, e) { var i = t.ref; if (i !== null) if (typeof i == "function") try { i(null) } catch (n) { X(t, e, n) } else i.current = null } function Ps(t, e, i) { try { i() } catch (n) { X(t, e, n) } } var Ma = !1; function Qp(t, e) { if (ds = kr, t = ld(), nl(t)) { if ("selectionStart" in t) var i = { start: t.selectionStart, end: t.selectionEnd }; else e: { i = (i = t.ownerDocument) && i.defaultView || window; var n = i.getSelection && i.getSelection(); if (n && n.rangeCount !== 0) { i = n.anchorNode; var r = n.anchorOffset, o = n.focusNode; n = n.focusOffset; try { i.nodeType, o.nodeType } catch { i = null; break e } var s = 0, l = -1, a = -1, u = 0, m = 0, d = t, c = null; t: for (; ;) { for (var v; d !== i || r !== 0 && d.nodeType !== 3 || (l = s + r), d !== o || n !== 0 && d.nodeType !== 3 || (a = s + n), d.nodeType === 3 && (s += d.nodeValue.length), (v = d.firstChild) !== null;)c = d, d = v; for (; ;) { if (d === t) break t; if (c === i && ++u === r && (l = s), c === o && ++m === n && (a = s), (v = d.nextSibling) !== null) break; d = c, c = d.parentNode } d = v } i = l === -1 || a === -1 ? null : { start: l, end: a } } else i = null } i = i || { start: 0, end: 0 } } else i = null; for (hs = { focusedElem: t, selectionRange: i }, kr = !1, k = e; k !== null;)if (e = k, t = e.child, (e.subtreeFlags & 1028) !== 0 && t !== null) t.return = e, k = t; else for (; k !== null;) { e = k; try { var g = e.alternate; if (e.flags & 1024) switch (e.tag) { case 0: case 11: case 15: break; case 1: if (g !== null) { var w = g.memoizedProps, C = g.memoizedState, p = e.stateNode, h = p.getSnapshotBeforeUpdate(e.elementType === e.type ? w : Ke(e.type, w), C); p.__reactInternalSnapshotBeforeUpdate = h } break; case 3: var f = e.stateNode.containerInfo; f.nodeType === 1 ? f.textContent = "" : f.nodeType === 9 && f.documentElement && f.removeChild(f.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(D(163)) } } catch (y) { X(e, e.return, y) } if (t = e.sibling, t !== null) { t.return = e.return, k = t; break } k = e.return } return g = Ma, Ma = !1, g } function cn(t, e, i) { var n = e.updateQueue; if (n = n !== null ? n.lastEffect : null, n !== null) { var r = n = n.next; do { if ((r.tag & t) === t) { var o = r.destroy; r.destroy = void 0, o !== void 0 && Ps(e, i, o) } r = r.next } while (r !== n) } } function no(t, e) { if (e = e.updateQueue, e = e !== null ? e.lastEffect : null, e !== null) { var i = e = e.next; do { if ((i.tag & t) === t) { var n = i.create; i.destroy = n() } i = i.next } while (i !== e) } } function zs(t) { var e = t.ref; if (e !== null) { var i = t.stateNode; switch (t.tag) { case 5: t = i; break; default: t = i }typeof e == "function" ? e(t) : e.current = t } } function rh(t) { var e = t.alternate; e !== null && (t.alternate = null, rh(e)), t.child = null, t.deletions = null, t.sibling = null, t.tag === 5 && (e = t.stateNode, e !== null && (delete e[st], delete e[kn], delete e[fs], delete e[Ip], delete e[Np])), t.stateNode = null, t.return = null, t.dependencies = null, t.memoizedProps = null, t.memoizedState = null, t.pendingProps = null, t.stateNode = null, t.updateQueue = null } function oh(t) { return t.tag === 5 || t.tag === 3 || t.tag === 4 } function ba(t) { e: for (; ;) { for (; t.sibling === null;) { if (t.return === null || oh(t.return)) return null; t = t.return } for (t.sibling.return = t.return, t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18;) { if (t.flags & 2 || t.child === null || t.tag === 4) continue e; t.child.return = t, t = t.child } if (!(t.flags & 2)) return t.stateNode } } function As(t, e, i) { var n = t.tag; if (n === 5 || n === 6) t = t.stateNode, e ? i.nodeType === 8 ? i.parentNode.insertBefore(t, e) : i.insertBefore(t, e) : (i.nodeType === 8 ? (e = i.parentNode, e.insertBefore(t, i)) : (e = i, e.appendChild(t)), i = i._reactRootContainer, i != null || e.onclick !== null || (e.onclick = Ar)); else if (n !== 4 && (t = t.child, t !== null)) for (As(t, e, i), t = t.sibling; t !== null;)As(t, e, i), t = t.sibling } function Is(t, e, i) { var n = t.tag; if (n === 5 || n === 6) t = t.stateNode, e ? i.insertBefore(t, e) : i.appendChild(t); else if (n !== 4 && (t = t.child, t !== null)) for (Is(t, e, i), t = t.sibling; t !== null;)Is(t, e, i), t = t.sibling } var pe = null, Xe = !1; function Et(t, e, i) { for (i = i.child; i !== null;)sh(t, e, i), i = i.sibling } function sh(t, e, i) { if (lt && typeof lt.onCommitFiberUnmount == "function") try { lt.onCommitFiberUnmount(Zr, i) } catch { } switch (i.tag) { case 5: we || xi(i, e); case 6: var n = pe, r = Xe; pe = null, Et(t, e, i), pe = n, Xe = r, pe !== null && (Xe ? (t = pe, i = i.stateNode, t.nodeType === 8 ? t.parentNode.removeChild(i) : t.removeChild(i)) : pe.removeChild(i.stateNode)); break; case 18: pe !== null && (Xe ? (t = pe, i = i.stateNode, t.nodeType === 8 ? Io(t.parentNode, i) : t.nodeType === 1 && Io(t, i), Dn(t)) : Io(pe, i.stateNode)); break; case 4: n = pe, r = Xe, pe = i.stateNode.containerInfo, Xe = !0, Et(t, e, i), pe = n, Xe = r; break; case 0: case 11: case 14: case 15: if (!we && (n = i.updateQueue, n !== null && (n = n.lastEffect, n !== null))) { r = n = n.next; do { var o = r, s = o.destroy; o = o.tag, s !== void 0 && (o & 2 || o & 4) && Ps(i, e, s), r = r.next } while (r !== n) } Et(t, e, i); break; case 1: if (!we && (xi(i, e), n = i.stateNode, typeof n.componentWillUnmount == "function")) try { n.props = i.memoizedProps, n.state = i.memoizedState, n.componentWillUnmount() } catch (l) { X(i, e, l) } Et(t, e, i); break; case 21: Et(t, e, i); break; case 22: i.mode & 1 ? (we = (n = we) || i.memoizedState !== null, Et(t, e, i), we = n) : Et(t, e, i); break; default: Et(t, e, i) } } function Wa(t) { var e = t.updateQueue; if (e !== null) { t.updateQueue = null; var i = t.stateNode; i === null && (i = t.stateNode = new Jp), e.forEach(function (n) { var r = rf.bind(null, t, n); i.has(n) || (i.add(n), n.then(r, r)) }) } } function Ze(t, e) { var i = e.deletions; if (i !== null) for (var n = 0; n < i.length; n++) { var r = i[n]; try { var o = t, s = e, l = s; e: for (; l !== null;) { switch (l.tag) { case 5: pe = l.stateNode, Xe = !1; break e; case 3: pe = l.stateNode.containerInfo, Xe = !0; break e; case 4: pe = l.stateNode.containerInfo, Xe = !0; break e }l = l.return } if (pe === null) throw Error(D(160)); sh(o, s, r), pe = null, Xe = !1; var a = r.alternate; a !== null && (a.return = null), r.return = null } catch (u) { X(r, e, u) } } if (e.subtreeFlags & 12854) for (e = e.child; e !== null;)lh(e, t), e = e.sibling } function lh(t, e) { var i = t.alternate, n = t.flags; switch (t.tag) { case 0: case 11: case 14: case 15: if (Ze(e, t), nt(t), n & 4) { try { cn(3, t, t.return), no(3, t) } catch (w) { X(t, t.return, w) } try { cn(5, t, t.return) } catch (w) { X(t, t.return, w) } } break; case 1: Ze(e, t), nt(t), n & 512 && i !== null && xi(i, i.return); break; case 5: if (Ze(e, t), nt(t), n & 512 && i !== null && xi(i, i.return), t.flags & 32) { var r = t.stateNode; try { gn(r, "") } catch (w) { X(t, t.return, w) } } if (n & 4 && (r = t.stateNode, r != null)) { var o = t.memoizedProps, s = i !== null ? i.memoizedProps : o, l = t.type, a = t.updateQueue; if (t.updateQueue = null, a !== null) try { l === "input" && o.type === "radio" && o.name != null && zu(r, o), es(l, s); var u = es(l, o); for (s = 0; s < a.length; s += 2) { var m = a[s], d = a[s + 1]; m === "style" ? Lu(r, d) : m === "dangerouslySetInnerHTML" ? Nu(r, d) : m === "children" ? gn(r, d) : js(r, m, d, u) } switch (l) { case "input": Zo(r, o); break; case "textarea": Au(r, o); break; case "select": var c = r._wrapperState.wasMultiple; r._wrapperState.wasMultiple = !!o.multiple; var v = o.value; v != null ? Pi(r, !!o.multiple, v, !1) : c !== !!o.multiple && (o.defaultValue != null ? Pi(r, !!o.multiple, o.defaultValue, !0) : Pi(r, !!o.multiple, o.multiple ? [] : "", !1)) }r[kn] = o } catch (w) { X(t, t.return, w) } } break; case 6: if (Ze(e, t), nt(t), n & 4) { if (t.stateNode === null) throw Error(D(162)); r = t.stateNode, o = t.memoizedProps; try { r.nodeValue = o } catch (w) { X(t, t.return, w) } } break; case 3: if (Ze(e, t), nt(t), n & 4 && i !== null && i.memoizedState.isDehydrated) try { Dn(e.containerInfo) } catch (w) { X(t, t.return, w) } break; case 4: Ze(e, t), nt(t); break; case 13: Ze(e, t), nt(t), r = t.child, r.flags & 8192 && (o = r.memoizedState !== null, r.stateNode.isHidden = o, !o || r.alternate !== null && r.alternate.memoizedState !== null || (Sl = te())), n & 4 && Wa(t); break; case 22: if (m = i !== null && i.memoizedState !== null, t.mode & 1 ? (we = (u = we) || m, Ze(e, t), we = u) : Ze(e, t), nt(t), n & 8192) { if (u = t.memoizedState !== null, (t.stateNode.isHidden = u) && !m && t.mode & 1) for (k = t, m = t.child; m !== null;) { for (d = k = m; k !== null;) { switch (c = k, v = c.child, c.tag) { case 0: case 11: case 14: case 15: cn(4, c, c.return); break; case 1: xi(c, c.return); var g = c.stateNode; if (typeof g.componentWillUnmount == "function") { n = c, i = c.return; try { e = n, g.props = e.memoizedProps, g.state = e.memoizedState, g.componentWillUnmount() } catch (w) { X(n, i, w) } } break; case 5: xi(c, c.return); break; case 22: if (c.memoizedState !== null) { Fa(d); continue } }v !== null ? (v.return = c, k = v) : Fa(d) } m = m.sibling } e: for (m = null, d = t; ;) { if (d.tag === 5) { if (m === null) { m = d; try { r = d.stateNode, u ? (o = r.style, typeof o.setProperty == "function" ? o.setProperty("display", "none", "important") : o.display = "none") : (l = d.stateNode, a = d.memoizedProps.style, s = a != null && a.hasOwnProperty("display") ? a.display : null, l.style.display = Ou("display", s)) } catch (w) { X(t, t.return, w) } } } else if (d.tag === 6) { if (m === null) try { d.stateNode.nodeValue = u ? "" : d.memoizedProps } catch (w) { X(t, t.return, w) } } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === t) && d.child !== null) { d.child.return = d, d = d.child; continue } if (d === t) break e; for (; d.sibling === null;) { if (d.return === null || d.return === t) break e; m === d && (m = null), d = d.return } m === d && (m = null), d.sibling.return = d.return, d = d.sibling } } break; case 19: Ze(e, t), nt(t), n & 4 && Wa(t); break; case 21: break; default: Ze(e, t), nt(t) } } function nt(t) { var e = t.flags; if (e & 2) { try { e: { for (var i = t.return; i !== null;) { if (oh(i)) { var n = i; break e } i = i.return } throw Error(D(160)) } switch (n.tag) { case 5: var r = n.stateNode; n.flags & 32 && (gn(r, ""), n.flags &= -33); var o = ba(t); Is(t, o, r); break; case 3: case 4: var s = n.stateNode.containerInfo, l = ba(t); As(t, l, s); break; default: throw Error(D(161)) } } catch (a) { X(t, t.return, a) } t.flags &= -3 } e & 4096 && (t.flags &= -4097) } function Zp(t, e, i) { k = t, ah(t) } function ah(t, e, i) { for (var n = (t.mode & 1) !== 0; k !== null;) { var r = k, o = r.child; if (r.tag === 22 && n) { var s = r.memoizedState !== null || nr; if (!s) { var l = r.alternate, a = l !== null && l.memoizedState !== null || we; l = nr; var u = we; if (nr = s, (we = a) && !u) for (k = r; k !== null;)s = k, a = s.child, s.tag === 22 && s.memoizedState !== null ? Ba(r) : a !== null ? (a.return = s, k = a) : Ba(r); for (; o !== null;)k = o, ah(o), o = o.sibling; k = r, nr = l, we = u } Ha(t) } else r.subtreeFlags & 8772 && o !== null ? (o.return = r, k = o) : Ha(t) } } function Ha(t) { for (; k !== null;) { var e = k; if (e.flags & 8772) { var i = e.alternate; try { if (e.flags & 8772) switch (e.tag) { case 0: case 11: case 15: we || no(5, e); break; case 1: var n = e.stateNode; if (e.flags & 4 && !we) if (i === null) n.componentDidMount(); else { var r = e.elementType === e.type ? i.memoizedProps : Ke(e.type, i.memoizedProps); n.componentDidUpdate(r, i.memoizedState, n.__reactInternalSnapshotBeforeUpdate) } var o = e.updateQueue; o !== null && Ea(e, o, n); break; case 3: var s = e.updateQueue; if (s !== null) { if (i = null, e.child !== null) switch (e.child.tag) { case 5: i = e.child.stateNode; break; case 1: i = e.child.stateNode }Ea(e, s, i) } break; case 5: var l = e.stateNode; if (i === null && e.flags & 4) { i = l; var a = e.memoizedProps; switch (e.type) { case "button": case "input": case "select": case "textarea": a.autoFocus && i.focus(); break; case "img": a.src && (i.src = a.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (e.memoizedState === null) { var u = e.alternate; if (u !== null) { var m = u.memoizedState; if (m !== null) { var d = m.dehydrated; d !== null && Dn(d) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(D(163)) }we || e.flags & 512 && zs(e) } catch (c) { X(e, e.return, c) } } if (e === t) { k = null; break } if (i = e.sibling, i !== null) { i.return = e.return, k = i; break } k = e.return } } function Fa(t) { for (; k !== null;) { var e = k; if (e === t) { k = null; break } var i = e.sibling; if (i !== null) { i.return = e.return, k = i; break } k = e.return } } function Ba(t) { for (; k !== null;) { var e = k; try { switch (e.tag) { case 0: case 11: case 15: var i = e.return; try { no(4, e) } catch (a) { X(e, i, a) } break; case 1: var n = e.stateNode; if (typeof n.componentDidMount == "function") { var r = e.return; try { n.componentDidMount() } catch (a) { X(e, r, a) } } var o = e.return; try { zs(e) } catch (a) { X(e, o, a) } break; case 5: var s = e.return; try { zs(e) } catch (a) { X(e, s, a) } } } catch (a) { X(e, e.return, a) } if (e === t) { k = null; break } var l = e.sibling; if (l !== null) { l.return = e.return, k = l; break } k = e.return } } var Yp = Math.ceil, Wr = St.ReactCurrentDispatcher, Dl = St.ReactCurrentOwner, Ue = St.ReactCurrentBatchConfig, W = 0, ce = null, re = null, fe = 0, Ie = 0, ki = $t(0), ae = 0, On = null, li = 0, ro = 0, Cl = 0, pn = null, xe = null, Sl = 0, bi = 1 / 0, dt = null, Hr = !1, Ns = null, bt = null, rr = !1, Nt = null, Fr = 0, fn = 0, Os = null, wr = -1, _r = 0; function Ce() { return W & 6 ? te() : wr !== -1 ? wr : wr = te() } function Wt(t) { return t.mode & 1 ? W & 2 && fe !== 0 ? fe & -fe : Lp.transition !== null ? (_r === 0 && (_r = Uu()), _r) : (t = H, t !== 0 || (t = window.event, t = t === void 0 ? 16 : Xu(t.type)), t) : 1 } function tt(t, e, i, n) { if (50 < fn) throw fn = 0, Os = null, Error(D(185)); Vn(t, i, n), (!(W & 2) || t !== ce) && (t === ce && (!(W & 2) && (ro |= i), ae === 4 && zt(t, fe)), Ae(t, n), i === 1 && W === 0 && !(e.mode & 1) && (bi = te() + 500, eo && Jt())) } function Ae(t, e) { var i = t.callbackNode; Lc(t, e); var n = xr(t, t === ce ? fe : 0); if (n === 0) i !== null && Xl(i), t.callbackNode = null, t.callbackPriority = 0; else if (e = n & -n, t.callbackPriority !== e) { if (i != null && Xl(i), e === 1) t.tag === 0 ? Op(ja.bind(null, t)) : gd(ja.bind(null, t)), zp(function () { !(W & 6) && Jt() }), i = null; else { switch ($u(n)) { case 1: i = Zs; break; case 4: i = Bu; break; case 16: i = Er; break; case 536870912: i = ju; break; default: i = Er }i = vh(i, uh.bind(null, t)) } t.callbackPriority = e, t.callbackNode = i } } function uh(t, e) { if (wr = -1, _r = 0, W & 6) throw Error(D(327)); var i = t.callbackNode; if (Oi() && t.callbackNode !== i) return null; var n = xr(t, t === ce ? fe : 0); if (n === 0) return null; if (n & 30 || n & t.expiredLanes || e) e = Br(t, n); else { e = n; var r = W; W |= 2; var o = hh(); (ce !== t || fe !== e) && (dt = null, bi = te() + 500, ti(t, e)); do try { qp(); break } catch (l) { dh(t, l) } while (!0); al(), Wr.current = o, W = r, re !== null ? e = 0 : (ce = null, fe = 0, e = ae) } if (e !== 0) { if (e === 2 && (r = os(t), r !== 0 && (n = r, e = Ls(t, r))), e === 1) throw i = On, ti(t, 0), zt(t, n), Ae(t, te()), i; if (e === 6) zt(t, n); else { if (r = t.current.alternate, !(n & 30) && !Kp(r) && (e = Br(t, n), e === 2 && (o = os(t), o !== 0 && (n = o, e = Ls(t, o))), e === 1)) throw i = On, ti(t, 0), zt(t, n), Ae(t, te()), i; switch (t.finishedWork = r, t.finishedLanes = n, e) { case 0: case 1: throw Error(D(345)); case 2: Kt(t, xe, dt); break; case 3: if (zt(t, n), (n & 130023424) === n && (e = Sl + 500 - te(), 10 < e)) { if (xr(t, 0) !== 0) break; if (r = t.suspendedLanes, (r & n) !== n) { Ce(), t.pingedLanes |= t.suspendedLanes & r; break } t.timeoutHandle = ps(Kt.bind(null, t, xe, dt), e); break } Kt(t, xe, dt); break; case 4: if (zt(t, n), (n & 4194240) === n) break; for (e = t.eventTimes, r = -1; 0 < n;) { var s = 31 - et(n); o = 1 << s, s = e[s], s > r && (r = s), n &= ~o } if (n = r, n = te() - n, n = (120 > n ? 120 : 480 > n ? 480 : 1080 > n ? 1080 : 1920 > n ? 1920 : 3e3 > n ? 3e3 : 4320 > n ? 4320 : 1960 * Yp(n / 1960)) - n, 10 < n) { t.timeoutHandle = ps(Kt.bind(null, t, xe, dt), n); break } Kt(t, xe, dt); break; case 5: Kt(t, xe, dt); break; default: throw Error(D(329)) } } } return Ae(t, te()), t.callbackNode === i ? uh.bind(null, t) : null } function Ls(t, e) { var i = pn; return t.current.memoizedState.isDehydrated && (ti(t, e).flags |= 256), t = Br(t, e), t !== 2 && (e = xe, xe = i, e !== null && Rs(e)), t } function Rs(t) { xe === null ? xe = t : xe.push.apply(xe, t) } function Kp(t) { for (var e = t; ;) { if (e.flags & 16384) { var i = e.updateQueue; if (i !== null && (i = i.stores, i !== null)) for (var n = 0; n < i.length; n++) { var r = i[n], o = r.getSnapshot; r = r.value; try { if (!it(o(), r)) return !1 } catch { return !1 } } } if (i = e.child, e.subtreeFlags & 16384 && i !== null) i.return = e, e = i; else { if (e === t) break; for (; e.sibling === null;) { if (e.return === null || e.return === t) return !0; e = e.return } e.sibling.return = e.return, e = e.sibling } } return !0 } function zt(t, e) { for (e &= ~Cl, e &= ~ro, t.suspendedLanes |= e, t.pingedLanes &= ~e, t = t.expirationTimes; 0 < e;) { var i = 31 - et(e), n = 1 << i; t[i] = -1, e &= ~n } } function ja(t) { if (W & 6) throw Error(D(327)); Oi(); var e = xr(t, 0); if (!(e & 1)) return Ae(t, te()), null; var i = Br(t, e); if (t.tag !== 0 && i === 2) { var n = os(t); n !== 0 && (e = n, i = Ls(t, n)) } if (i === 1) throw i = On, ti(t, 0), zt(t, e), Ae(t, te()), i; if (i === 6) throw Error(D(345)); return t.finishedWork = t.current.alternate, t.finishedLanes = e, Kt(t, xe, dt), Ae(t, te()), null } function El(t, e) { var i = W; W |= 1; try { return t(e) } finally { W = i, W === 0 && (bi = te() + 500, eo && Jt()) } } function ai(t) { Nt !== null && Nt.tag === 0 && !(W & 6) && Oi(); var e = W; W |= 1; var i = Ue.transition, n = H; try { if (Ue.transition = null, H = 1, t) return t() } finally { H = n, Ue.transition = i, W = e, !(W & 6) && Jt() } } function xl() { Ie = ki.current, J(ki) } function ti(t, e) { t.finishedWork = null, t.finishedLanes = 0; var i = t.timeoutHandle; if (i !== -1 && (t.timeoutHandle = -1, Pp(i)), re !== null) for (i = re.return; i !== null;) { var n = i; switch (ol(n), n.tag) { case 1: n = n.type.childContextTypes, n != null && Ir(); break; case 3: Vi(), J(Pe), J(_e), fl(); break; case 5: pl(n); break; case 4: Vi(); break; case 13: J(Z); break; case 19: J(Z); break; case 10: ul(n.type._context); break; case 22: case 23: xl() }i = i.return } if (ce = t, re = t = Ht(t.current, null), fe = Ie = e, ae = 0, On = null, Cl = ro = li = 0, xe = pn = null, qt !== null) { for (e = 0; e < qt.length; e++)if (i = qt[e], n = i.interleaved, n !== null) { i.interleaved = null; var r = n.next, o = i.pending; if (o !== null) { var s = o.next; o.next = r, n.next = s } i.pending = n } qt = null } return t } function dh(t, e) { do { var i = re; try { if (al(), mr.current = br, Mr) { for (var n = Y.memoizedState; n !== null;) { var r = n.queue; r !== null && (r.pending = null), n = n.next } Mr = !1 } if (si = 0, he = le = Y = null, hn = !1, An = 0, Dl.current = null, i === null || i.return === null) { ae = 1, On = e, re = null; break } e: { var o = t, s = i.return, l = i, a = e; if (e = fe, l.flags |= 32768, a !== null && typeof a == "object" && typeof a.then == "function") { var u = a, m = l, d = m.tag; if (!(m.mode & 1) && (d === 0 || d === 11 || d === 15)) { var c = m.alternate; c ? (m.updateQueue = c.updateQueue, m.memoizedState = c.memoizedState, m.lanes = c.lanes) : (m.updateQueue = null, m.memoizedState = null) } var v = Na(s); if (v !== null) { v.flags &= -257, Oa(v, s, l, o, e), v.mode & 1 && Ia(o, u, e), e = v, a = u; var g = e.updateQueue; if (g === null) { var w = new Set; w.add(a), e.updateQueue = w } else g.add(a); break e } else { if (!(e & 1)) { Ia(o, u, e), kl(); break e } a = Error(D(426)) } } else if (Q && l.mode & 1) { var C = Na(s); if (C !== null) { !(C.flags & 65536) && (C.flags |= 256), Oa(C, s, l, o, e), sl(Mi(a, l)); break e } } o = a = Mi(a, l), ae !== 4 && (ae = 2), pn === null ? pn = [o] : pn.push(o), o = s; do { switch (o.tag) { case 3: o.flags |= 65536, e &= -e, o.lanes |= e; var p = Jd(o, a, e); Sa(o, p); break e; case 1: l = a; var h = o.type, f = o.stateNode; if (!(o.flags & 128) && (typeof h.getDerivedStateFromError == "function" || f !== null && typeof f.componentDidCatch == "function" && (bt === null || !bt.has(f)))) { o.flags |= 65536, e &= -e, o.lanes |= e; var y = Qd(o, l, e); Sa(o, y); break e } }o = o.return } while (o !== null) } ph(i) } catch (S) { e = S, re === i && i !== null && (re = i = i.return); continue } break } while (!0) } function hh() { var t = Wr.current; return Wr.current = br, t === null ? br : t } function kl() { (ae === 0 || ae === 3 || ae === 2) && (ae = 4), ce === null || !(li & 268435455) && !(ro & 268435455) || zt(ce, fe) } function Br(t, e) { var i = W; W |= 2; var n = hh(); (ce !== t || fe !== e) && (dt = null, ti(t, e)); do try { Xp(); break } catch (r) { dh(t, r) } while (!0); if (al(), W = i, Wr.current = n, re !== null) throw Error(D(261)); return ce = null, fe = 0, ae } function Xp() { for (; re !== null;)ch(re) } function qp() { for (; re !== null && !Ec();)ch(re) } function ch(t) { var e = mh(t.alternate, t, Ie); t.memoizedProps = t.pendingProps, e === null ? ph(t) : re = e, Dl.current = null } function ph(t) { var e = t; do { var i = e.alternate; if (t = e.return, e.flags & 32768) { if (i = $p(i, e), i !== null) { i.flags &= 32767, re = i; return } if (t !== null) t.flags |= 32768, t.subtreeFlags = 0, t.deletions = null; else { ae = 6, re = null; return } } else if (i = Up(i, e, Ie), i !== null) { re = i; return } if (e = e.sibling, e !== null) { re = e; return } re = e = t } while (e !== null); ae === 0 && (ae = 5) } function Kt(t, e, i) { var n = H, r = Ue.transition; try { Ue.transition = null, H = 1, ef(t, e, i, n) } finally { Ue.transition = r, H = n } return null } function ef(t, e, i, n) { do Oi(); while (Nt !== null); if (W & 6) throw Error(D(327)); i = t.finishedWork; var r = t.finishedLanes; if (i === null) return null; if (t.finishedWork = null, t.finishedLanes = 0, i === t.current) throw Error(D(177)); t.callbackNode = null, t.callbackPriority = 0; var o = i.lanes | i.childLanes; if (Rc(t, o), t === ce && (re = ce = null, fe = 0), !(i.subtreeFlags & 2064) && !(i.flags & 2064) || rr || (rr = !0, vh(Er, function () { return Oi(), null })), o = (i.flags & 15990) !== 0, i.subtreeFlags & 15990 || o) { o = Ue.transition, Ue.transition = null; var s = H; H = 1; var l = W; W |= 4, Dl.current = null, Qp(t, i), lh(i, t), yp(hs), kr = !!ds, hs = ds = null, t.current = i, Zp(i), xc(), W = l, H = s, Ue.transition = o } else t.current = i; if (rr && (rr = !1, Nt = t, Fr = r), o = t.pendingLanes, o === 0 && (bt = null), zc(i.stateNode), Ae(t, te()), e !== null) for (n = t.onRecoverableError, i = 0; i < e.length; i++)r = e[i], n(r.value, { componentStack: r.stack, digest: r.digest }); if (Hr) throw Hr = !1, t = Ns, Ns = null, t; return Fr & 1 && t.tag !== 0 && Oi(), o = t.pendingLanes, o & 1 ? t === Os ? fn++ : (fn = 0, Os = t) : fn = 0, Jt(), null } function Oi() { if (Nt !== null) { var t = $u(Fr), e = Ue.transition, i = H; try { if (Ue.transition = null, H = 16 > t ? 16 : t, Nt === null) var n = !1; else { if (t = Nt, Nt = null, Fr = 0, W & 6) throw Error(D(331)); var r = W; for (W |= 4, k = t.current; k !== null;) { var o = k, s = o.child; if (k.flags & 16) { var l = o.deletions; if (l !== null) { for (var a = 0; a < l.length; a++) { var u = l[a]; for (k = u; k !== null;) { var m = k; switch (m.tag) { case 0: case 11: case 15: cn(8, m, o) }var d = m.child; if (d !== null) d.return = m, k = d; else for (; k !== null;) { m = k; var c = m.sibling, v = m.return; if (rh(m), m === u) { k = null; break } if (c !== null) { c.return = v, k = c; break } k = v } } } var g = o.alternate; if (g !== null) { var w = g.child; if (w !== null) { g.child = null; do { var C = w.sibling; w.sibling = null, w = C } while (w !== null) } } k = o } } if (o.subtreeFlags & 2064 && s !== null) s.return = o, k = s; else e: for (; k !== null;) { if (o = k, o.flags & 2048) switch (o.tag) { case 0: case 11: case 15: cn(9, o, o.return) }var p = o.sibling; if (p !== null) { p.return = o.return, k = p; break e } k = o.return } } var h = t.current; for (k = h; k !== null;) { s = k; var f = s.child; if (s.subtreeFlags & 2064 && f !== null) f.return = s, k = f; else e: for (s = h; k !== null;) { if (l = k, l.flags & 2048) try { switch (l.tag) { case 0: case 11: case 15: no(9, l) } } catch (S) { X(l, l.return, S) } if (l === s) { k = null; break e } var y = l.sibling; if (y !== null) { y.return = l.return, k = y; break e } k = l.return } } if (W = r, Jt(), lt && typeof lt.onPostCommitFiberRoot == "function") try { lt.onPostCommitFiberRoot(Zr, t) } catch { } n = !0 } return n } finally { H = i, Ue.transition = e } } return !1 } function Ua(t, e, i) { e = Mi(i, e), e = Jd(t, e, 1), t = Mt(t, e, 1), e = Ce(), t !== null && (Vn(t, 1, e), Ae(t, e)) } function X(t, e, i) { if (t.tag === 3) Ua(t, t, i); else for (; e !== null;) { if (e.tag === 3) { Ua(e, t, i); break } else if (e.tag === 1) { var n = e.stateNode; if (typeof e.type.getDerivedStateFromError == "function" || typeof n.componentDidCatch == "function" && (bt === null || !bt.has(n))) { t = Mi(i, t), t = Qd(e, t, 1), e = Mt(e, t, 1), t = Ce(), e !== null && (Vn(e, 1, t), Ae(e, t)); break } } e = e.return } } function tf(t, e, i) { var n = t.pingCache; n !== null && n.delete(e), e = Ce(), t.pingedLanes |= t.suspendedLanes & i, ce === t && (fe & i) === i && (ae === 4 || ae === 3 && (fe & 130023424) === fe && 500 > te() - Sl ? ti(t, 0) : Cl |= i), Ae(t, e) } function fh(t, e) { e === 0 && (t.mode & 1 ? (e = Qn, Qn <<= 1, !(Qn & 130023424) && (Qn = 4194304)) : e = 1); var i = Ce(); t = yt(t, e), t !== null && (Vn(t, e, i), Ae(t, i)) } function nf(t) { var e = t.memoizedState, i = 0; e !== null && (i = e.retryLane), fh(t, i) } function rf(t, e) { var i = 0; switch (t.tag) { case 13: var n = t.stateNode, r = t.memoizedState; r !== null && (i = r.retryLane); break; case 19: n = t.stateNode; break; default: throw Error(D(314)) }n !== null && n.delete(e), fh(t, i) } var mh; mh = function (t, e, i) { if (t !== null) if (t.memoizedProps !== e.pendingProps || Pe.current) ke = !0; else { if (!(t.lanes & i) && !(e.flags & 128)) return ke = !1, jp(t, e, i); ke = !!(t.flags & 131072) } else ke = !1, Q && e.flags & 1048576 && wd(e, Lr, e.index); switch (e.lanes = 0, e.tag) { case 2: var n = e.type; gr(t, e), t = e.pendingProps; var r = Ri(e, _e.current); Ni(e, i), r = vl(null, e, n, t, r, i); var o = gl(); return e.flags |= 1, typeof r == "object" && r !== null && typeof r.render == "function" && r.$$typeof === void 0 ? (e.tag = 1, e.memoizedState = null, e.updateQueue = null, ze(n) ? (o = !0, Nr(e)) : o = !1, e.memoizedState = r.state !== null && r.state !== void 0 ? r.state : null, hl(e), r.updater = to, e.stateNode = r, r._reactInternals = e, ys(e, n, t, i), e = Ss(null, e, n, !0, o, i)) : (e.tag = 0, Q && o && rl(e), De(null, e, r, i), e = e.child), e; case 16: n = e.elementType; e: { switch (gr(t, e), t = e.pendingProps, r = n._init, n = r(n._payload), e.type = n, r = e.tag = sf(n), t = Ke(n, t), r) { case 0: e = Cs(null, e, n, t, i); break e; case 1: e = Ta(null, e, n, t, i); break e; case 11: e = La(null, e, n, t, i); break e; case 14: e = Ra(null, e, n, Ke(n.type, t), i); break e }throw Error(D(306, n, "")) } return e; case 0: return n = e.type, r = e.pendingProps, r = e.elementType === n ? r : Ke(n, r), Cs(t, e, n, r, i); case 1: return n = e.type, r = e.pendingProps, r = e.elementType === n ? r : Ke(n, r), Ta(t, e, n, r, i); case 3: e: { if (Xd(e), t === null) throw Error(D(387)); n = e.pendingProps, o = e.memoizedState, r = o.element, Cd(t, e), Gr(e, n, null, i); var s = e.memoizedState; if (n = s.element, o.isDehydrated) if (o = { element: n, isDehydrated: !1, cache: s.cache, pendingSuspenseBoundaries: s.pendingSuspenseBoundaries, transitions: s.transitions }, e.updateQueue.baseState = o, e.memoizedState = o, e.flags & 256) { r = Mi(Error(D(423)), e), e = Ga(t, e, n, i, r); break e } else if (n !== r) { r = Mi(Error(D(424)), e), e = Ga(t, e, n, i, r); break e } else for (Ne = Vt(e.stateNode.containerInfo.firstChild), Re = e, Q = !0, qe = null, i = kd(e, null, n, i), e.child = i; i;)i.flags = i.flags & -3 | 4096, i = i.sibling; else { if (Ti(), n === r) { e = Dt(t, e, i); break e } De(t, e, n, i) } e = e.child } return e; case 5: return Pd(e), t === null && gs(e), n = e.type, r = e.pendingProps, o = t !== null ? t.memoizedProps : null, s = r.children, cs(n, r) ? s = null : o !== null && cs(n, o) && (e.flags |= 32), Kd(t, e), De(t, e, s, i), e.child; case 6: return t === null && gs(e), null; case 13: return qd(t, e, i); case 4: return cl(e, e.stateNode.containerInfo), n = e.pendingProps, t === null ? e.child = Gi(e, null, n, i) : De(t, e, n, i), e.child; case 11: return n = e.type, r = e.pendingProps, r = e.elementType === n ? r : Ke(n, r), La(t, e, n, r, i); case 7: return De(t, e, e.pendingProps, i), e.child; case 8: return De(t, e, e.pendingProps.children, i), e.child; case 12: return De(t, e, e.pendingProps.children, i), e.child; case 10: e: { if (n = e.type._context, r = e.pendingProps, o = e.memoizedProps, s = r.value, j(Rr, n._currentValue), n._currentValue = s, o !== null) if (it(o.value, s)) { if (o.children === r.children && !Pe.current) { e = Dt(t, e, i); break e } } else for (o = e.child, o !== null && (o.return = e); o !== null;) { var l = o.dependencies; if (l !== null) { s = o.child; for (var a = l.firstContext; a !== null;) { if (a.context === n) { if (o.tag === 1) { a = gt(-1, i & -i), a.tag = 2; var u = o.updateQueue; if (u !== null) { u = u.shared; var m = u.pending; m === null ? a.next = a : (a.next = m.next, m.next = a), u.pending = a } } o.lanes |= i, a = o.alternate, a !== null && (a.lanes |= i), ws(o.return, i, e), l.lanes |= i; break } a = a.next } } else if (o.tag === 10) s = o.type === e.type ? null : o.child; else if (o.tag === 18) { if (s = o.return, s === null) throw Error(D(341)); s.lanes |= i, l = s.alternate, l !== null && (l.lanes |= i), ws(s, i, e), s = o.sibling } else s = o.child; if (s !== null) s.return = o; else for (s = o; s !== null;) { if (s === e) { s = null; break } if (o = s.sibling, o !== null) { o.return = s.return, s = o; break } s = s.return } o = s } De(t, e, r.children, i), e = e.child } return e; case 9: return r = e.type, n = e.pendingProps.children, Ni(e, i), r = $e(r), n = n(r), e.flags |= 1, De(t, e, n, i), e.child; case 14: return n = e.type, r = Ke(n, e.pendingProps), r = Ke(n.type, r), Ra(t, e, n, r, i); case 15: return Zd(t, e, e.type, e.pendingProps, i); case 17: return n = e.type, r = e.pendingProps, r = e.elementType === n ? r : Ke(n, r), gr(t, e), e.tag = 1, ze(n) ? (t = !0, Nr(e)) : t = !1, Ni(e, i), Ed(e, n, r), ys(e, n, r, i), Ss(null, e, n, !0, t, i); case 19: return eh(t, e, i); case 22: return Yd(t, e, i) }throw Error(D(156, e.tag)) }; function vh(t, e) { return Fu(t, e) } function of(t, e, i, n) { this.tag = t, this.key = i, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = n, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Be(t, e, i, n) { return new of(t, e, i, n) } function Pl(t) { return t = t.prototype, !(!t || !t.isReactComponent) } function sf(t) { if (typeof t == "function") return Pl(t) ? 1 : 0; if (t != null) { if (t = t.$$typeof, t === $s) return 11; if (t === Js) return 14 } return 2 } function Ht(t, e) { var i = t.alternate; return i === null ? (i = Be(t.tag, e, t.key, t.mode), i.elementType = t.elementType, i.type = t.type, i.stateNode = t.stateNode, i.alternate = t, t.alternate = i) : (i.pendingProps = e, i.type = t.type, i.flags = 0, i.subtreeFlags = 0, i.deletions = null), i.flags = t.flags & 14680064, i.childLanes = t.childLanes, i.lanes = t.lanes, i.child = t.child, i.memoizedProps = t.memoizedProps, i.memoizedState = t.memoizedState, i.updateQueue = t.updateQueue, e = t.dependencies, i.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }, i.sibling = t.sibling, i.index = t.index, i.ref = t.ref, i } function yr(t, e, i, n, r, o) { var s = 2; if (n = t, typeof t == "function") Pl(t) && (s = 1); else if (typeof t == "string") s = 5; else e: switch (t) { case vi: return ii(i.children, r, o, e); case Us: s = 8, r |= 8; break; case jo: return t = Be(12, i, e, r | 2), t.elementType = jo, t.lanes = o, t; case Uo: return t = Be(13, i, e, r), t.elementType = Uo, t.lanes = o, t; case $o: return t = Be(19, i, e, r), t.elementType = $o, t.lanes = o, t; case xu: return oo(i, r, o, e); default: if (typeof t == "object" && t !== null) switch (t.$$typeof) { case Su: s = 10; break e; case Eu: s = 9; break e; case $s: s = 11; break e; case Js: s = 14; break e; case xt: s = 16, n = null; break e }throw Error(D(130, t == null ? t : typeof t, "")) }return e = Be(s, i, e, r), e.elementType = t, e.type = n, e.lanes = o, e } function ii(t, e, i, n) { return t = Be(7, t, n, e), t.lanes = i, t } function oo(t, e, i, n) { return t = Be(22, t, n, e), t.elementType = xu, t.lanes = i, t.stateNode = { isHidden: !1 }, t } function Mo(t, e, i) { return t = Be(6, t, null, e), t.lanes = i, t } function bo(t, e, i) { return e = Be(4, t.children !== null ? t.children : [], t.key, e), e.lanes = i, e.stateNode = { containerInfo: t.containerInfo, pendingChildren: null, implementation: t.implementation }, e } function lf(t, e, i, n, r) { this.tag = e, this.containerInfo = t, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = _o(0), this.expirationTimes = _o(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = _o(0), this.identifierPrefix = n, this.onRecoverableError = r, this.mutableSourceEagerHydrationData = null } function zl(t, e, i, n, r, o, s, l, a) { return t = new lf(t, e, i, l, a), e === 1 ? (e = 1, o === !0 && (e |= 8)) : e = 0, o = Be(3, null, null, e), t.current = o, o.stateNode = t, o.memoizedState = { element: n, isDehydrated: i, cache: null, transitions: null, pendingSuspenseBoundaries: null }, hl(o), t } function af(t, e, i) { var n = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: mi, key: n == null ? null : "" + n, children: t, containerInfo: e, implementation: i } } function gh(t) { if (!t) return jt; t = t._reactInternals; e: { if (di(t) !== t || t.tag !== 1) throw Error(D(170)); var e = t; do { switch (e.tag) { case 3: e = e.stateNode.context; break e; case 1: if (ze(e.type)) { e = e.stateNode.__reactInternalMemoizedMergedChildContext; break e } }e = e.return } while (e !== null); throw Error(D(171)) } if (t.tag === 1) { var i = t.type; if (ze(i)) return vd(t, i, e) } return e } function wh(t, e, i, n, r, o, s, l, a) { return t = zl(i, n, !0, t, r, o, s, l, a), t.context = gh(null), i = t.current, n = Ce(), r = Wt(i), o = gt(n, r), o.callback = e ?? null, Mt(i, o, r), t.current.lanes = r, Vn(t, r, n), Ae(t, n), t } function so(t, e, i, n) { var r = e.current, o = Ce(), s = Wt(r); return i = gh(i), e.context === null ? e.context = i : e.pendingContext = i, e = gt(o, s), e.payload = { element: t }, n = n === void 0 ? null : n, n !== null && (e.callback = n), t = Mt(r, e, s), t !== null && (tt(t, r, s, o), fr(t, r, s)), s } function jr(t) { if (t = t.current, !t.child) return null; switch (t.child.tag) { case 5: return t.child.stateNode; default: return t.child.stateNode } } function $a(t, e) { if (t = t.memoizedState, t !== null && t.dehydrated !== null) { var i = t.retryLane; t.retryLane = i !== 0 && i < e ? i : e } } function Al(t, e) { $a(t, e), (t = t.alternate) && $a(t, e) } function uf() { return null } var _h = typeof reportError == "function" ? reportError : function (t) { console.error(t) }; function Il(t) { this._internalRoot = t } lo.prototype.render = Il.prototype.render = function (t) { var e = this._internalRoot; if (e === null) throw Error(D(409)); so(t, e, null, null) }; lo.prototype.unmount = Il.prototype.unmount = function () { var t = this._internalRoot; if (t !== null) { this._internalRoot = null; var e = t.containerInfo; ai(function () { so(null, t, null, null) }), e[_t] = null } }; function lo(t) { this._internalRoot = t } lo.prototype.unstable_scheduleHydration = function (t) { if (t) { var e = Zu(); t = { blockedOn: null, target: t, priority: e }; for (var i = 0; i < Pt.length && e !== 0 && e < Pt[i].priority; i++); Pt.splice(i, 0, t), i === 0 && Ku(t) } }; function Nl(t) { return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11) } function ao(t) { return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11 && (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable ")) } function Ja() { } function df(t, e, i, n, r) { if (r) { if (typeof n == "function") { var o = n; n = function () { var u = jr(s); o.call(u) } } var s = wh(e, n, t, 0, null, !1, !1, "", Ja); return t._reactRootContainer = s, t[_t] = s.current, En(t.nodeType === 8 ? t.parentNode : t), ai(), s } for (; r = t.lastChild;)t.removeChild(r); if (typeof n == "function") { var l = n; n = function () { var u = jr(a); l.call(u) } } var a = zl(t, 0, !1, null, null, !1, !1, "", Ja); return t._reactRootContainer = a, t[_t] = a.current, En(t.nodeType === 8 ? t.parentNode : t), ai(function () { so(e, a, i, n) }), a } function uo(t, e, i, n, r) { var o = i._reactRootContainer; if (o) { var s = o; if (typeof r == "function") { var l = r; r = function () { var a = jr(s); l.call(a) } } so(e, s, t, r) } else s = df(i, e, t, r, n); return jr(s) } Ju = function (t) { switch (t.tag) { case 3: var e = t.stateNode; if (e.current.memoizedState.isDehydrated) { var i = rn(e.pendingLanes); i !== 0 && (Ys(e, i | 1), Ae(e, te()), !(W & 6) && (bi = te() + 500, Jt())) } break; case 13: ai(function () { var n = yt(t, 1); if (n !== null) { var r = Ce(); tt(n, t, 1, r) } }), Al(t, 1) } }; Ks = function (t) { if (t.tag === 13) { var e = yt(t, 134217728); if (e !== null) { var i = Ce(); tt(e, t, 134217728, i) } Al(t, 134217728) } }; Qu = function (t) { if (t.tag === 13) { var e = Wt(t), i = yt(t, e); if (i !== null) { var n = Ce(); tt(i, t, e, n) } Al(t, e) } }; Zu = function () { return H }; Yu = function (t, e) { var i = H; try { return H = t, e() } finally { H = i } }; is = function (t, e, i) { switch (e) { case "input": if (Zo(t, i), e = i.name, i.type === "radio" && e != null) { for (i = t; i.parentNode;)i = i.parentNode; for (i = i.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'), e = 0; e < i.length; e++) { var n = i[e]; if (n !== t && n.form === t.form) { var r = qr(n); if (!r) throw Error(D(90)); Pu(n), Zo(n, r) } } } break; case "textarea": Au(t, i); break; case "select": e = i.value, e != null && Pi(t, !!i.multiple, e, !1) } }; Gu = El; Vu = ai; var hf = { usingClientEntryPoint: !1, Events: [bn, yi, qr, Ru, Tu, El] }, Xi = { findFiberByHostInstance: Xt, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, cf = { bundleType: Xi.bundleType, version: Xi.version, rendererPackageName: Xi.rendererPackageName, rendererConfig: Xi.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: St.ReactCurrentDispatcher, findHostInstanceByFiber: function (t) { return t = Wu(t), t === null ? null : t.stateNode }, findFiberByHostInstance: Xi.findFiberByHostInstance || uf, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var or = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!or.isDisabled && or.supportsFiber) try { Zr = or.inject(cf), lt = or } catch { } } Ge.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = hf; Ge.createPortal = function (t, e) { var i = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!Nl(e)) throw Error(D(200)); return af(t, e, null, i) }; Ge.createRoot = function (t, e) { if (!Nl(t)) throw Error(D(299)); var i = !1, n = "", r = _h; return e != null && (e.unstable_strictMode === !0 && (i = !0), e.identifierPrefix !== void 0 && (n = e.identifierPrefix), e.onRecoverableError !== void 0 && (r = e.onRecoverableError)), e = zl(t, 1, !1, null, null, i, !1, n, r), t[_t] = e.current, En(t.nodeType === 8 ? t.parentNode : t), new Il(e) }; Ge.findDOMNode = function (t) { if (t == null) return null; if (t.nodeType === 1) return t; var e = t._reactInternals; if (e === void 0) throw typeof t.render == "function" ? Error(D(188)) : (t = Object.keys(t).join(","), Error(D(268, t))); return t = Wu(e), t = t === null ? null : t.stateNode, t }; Ge.flushSync = function (t) { return ai(t) }; Ge.hydrate = function (t, e, i) { if (!ao(e)) throw Error(D(200)); return uo(null, t, e, !0, i) }; Ge.hydrateRoot = function (t, e, i) { if (!Nl(t)) throw Error(D(405)); var n = i != null && i.hydratedSources || null, r = !1, o = "", s = _h; if (i != null && (i.unstable_strictMode === !0 && (r = !0), i.identifierPrefix !== void 0 && (o = i.identifierPrefix), i.onRecoverableError !== void 0 && (s = i.onRecoverableError)), e = wh(e, null, t, 1, i ?? null, r, !1, o, s), t[_t] = e.current, En(t), n) for (t = 0; t < n.length; t++)i = n[t], r = i._getVersion, r = r(i._source), e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [i, r] : e.mutableSourceEagerHydrationData.push(i, r); return new lo(e) }; Ge.render = function (t, e, i) { if (!ao(e)) throw Error(D(200)); return uo(null, t, e, !1, i) }; Ge.unmountComponentAtNode = function (t) { if (!ao(t)) throw Error(D(40)); return t._reactRootContainer ? (ai(function () { uo(null, null, t, !1, function () { t._reactRootContainer = null, t[_t] = null }) }), !0) : !1 }; Ge.unstable_batchedUpdates = El; Ge.unstable_renderSubtreeIntoContainer = function (t, e, i, n) { if (!ao(i)) throw Error(D(200)); if (t == null || t._reactInternals === void 0) throw Error(D(38)); return uo(t, e, i, !1, n) }; Ge.version = "18.2.0-next-9e3b772b8-20220608"; function yh() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(yh) } catch (t) { console.error(t) } } yh(), wu.exports = Ge; var Dh = wu.exports; const pf = lu(Dh); var Ch, Qa = Dh; Ch = Qa.createRoot, Qa.hydrateRoot; class Sh { } class Ft extends Sh { constructor(e, i, n) { super(), this.viewId = e, this.groupId = i, this.panelId = n } } class mn extends Sh { constructor(e, i) { super(), this.viewId = e, this.paneId = i } } class ut { constructor() { } static getInstance() { return ut.INSTANCE } hasData(e) { return e && e === this.proto } clearData(e) { this.hasData(e) && (this.proto = void 0, this.data = void 0) } getData(e) { if (this.hasData(e)) return this.data } setData(e, i) { i && (this.data = e, this.proto = i) } } ut.INSTANCE = new ut; function Fe() { const t = ut.getInstance(); if (t.hasData(Ft.prototype)) return t.getData(Ft.prototype)[0] } function qi() { const t = ut.getInstance(); if (t.hasData(mn.prototype)) return t.getData(mn.prototype)[0] } var ni; (function (t) { t.any = (...e) => i => { const n = e.map(r => r(i)); return { dispose: () => { n.forEach(r => { r.dispose() }) } } } })(ni || (ni = {})); class Ol { constructor() { this._defaultPrevented = !1 } get defaultPrevented() { return this._defaultPrevented } preventDefault() { this._defaultPrevented = !0 } } class ff { constructor() { this.events = new Map } get size() { return this.events.size } add(e, i) { this.events.set(e, i) } delete(e) { this.events.delete(e) } clear() { this.events.clear() } } class Ur { static create() { var e; return new Ur((e = new Error().stack) !== null && e !== void 0 ? e : "") } constructor(e) { this.value = e } print() { console.warn(this.value) } } class mf { constructor(e, i) { this.callback = e, this.stacktrace = i } } class _ { static setLeakageMonitorEnabled(e) { e !== _.ENABLE_TRACKING && _.MEMORY_LEAK_WATCHER.clear(), _.ENABLE_TRACKING = e } get value() { return this._last } constructor(e) { this.options = e, this._listeners = [], this._disposed = !1 } get event() { return this._event || (this._event = e => { var i; !((i = this.options) === null || i === void 0) && i.replay && this._last !== void 0 && e(this._last); const n = new mf(e, _.ENABLE_TRACKING ? Ur.create() : void 0); return this._listeners.push(n), { dispose: () => { const r = this._listeners.indexOf(n); r > -1 && this._listeners.splice(r, 1) } } }, _.ENABLE_TRACKING && _.MEMORY_LEAK_WATCHER.add(this._event, Ur.create())), this._event } fire(e) { this._last = e; for (const i of this._listeners) i.callback(e) } dispose() { this._disposed || (this._disposed = !0, this._listeners.length > 0 && (_.ENABLE_TRACKING && queueMicrotask(() => { var e; for (const i of this._listeners) console.warn((e = i.stacktrace) === null || e === void 0 ? void 0 : e.print()) }), this._listeners = []), _.ENABLE_TRACKING && this._event && _.MEMORY_LEAK_WATCHER.delete(this._event)) } } _.ENABLE_TRACKING = !1; _.MEMORY_LEAK_WATCHER = new ff; function mt(t, e, i, n) { return t.addEventListener(e, i, n), { dispose: () => { t.removeEventListener(e, i, n) } } } function $(t, e, i, n) { return t.addEventListener(e, i, n), { dispose: () => { t.removeEventListener(e, i, n) } } } class vf { constructor() { this._onFired = new _, this.onEvent = this._onFired.event } fire() { this.timer && clearTimeout(this.timer), this.timer = setTimeout(() => { this._onFired.fire(), clearTimeout(this.timer) }) } dispose() { this._onFired.dispose() } } var Oe; (function (t) { t.NONE = { dispose: () => { } }; function e(i) { return { dispose: () => { i() } } } t.from = e })(Oe || (Oe = {})); class V { get isDisposed() { return this._isDisposed } constructor(...e) { this._isDisposed = !1, this._disposables = e } addDisposables(...e) { e.forEach(i => this._disposables.push(i)) } dispose() { this._isDisposed || (this._isDisposed = !0, this._disposables.forEach(e => e.dispose()), this._disposables = []) } } class Qe { constructor() { this._disposable = Oe.NONE } set value(e) { this._disposable && this._disposable.dispose(), this._disposable = e } dispose() { this._disposable && (this._disposable.dispose(), this._disposable = Oe.NONE) } } function je(t, e, i = {}, n = {}, r, o) { const s = typeof e == "string" ? i[e] : void 0, l = typeof e == "string" ? n[e] : void 0; if (s && l) throw new Error(`Cannot create '${t}'. component '${e}' registered as both a component and frameworkComponent`); if (l) { if (!r) throw new Error(`Cannot create '${t}' for framework component '${e}'. you must register a frameworkPanelWrapper to use framework components`); return r.createComponent(t, e, l) } if (!s) { if (o) return o(); throw new Error(`Cannot create '${t}', no component '${e}' provided`) } return new s(t, e) } function Eh(t, e) { const i = new ResizeObserver(n => { requestAnimationFrame(() => { const r = n[0]; e(r) }) }); return i.observe(t), { dispose: () => { i.unobserve(t), i.disconnect() } } } const Ln = (t, ...e) => { for (const i of e) t.classList.contains(i) && t.classList.remove(i) }, ho = (t, ...e) => { for (const i of e) t.classList.contains(i) || t.classList.add(i) }, G = (t, e, i) => { const n = t.classList.contains(e); i && !n && t.classList.add(e), !i && n && t.classList.remove(e) }; function Ts(t, e) { for (; t;) { if (t === e) return !0; t = t.parentNode } return !1 } function Ot(t) { return Array.prototype.slice.call(document.getElementsByTagName(t), 0) } function xh(t) { return new gf(t) } class gf extends V { constructor(e) { super(), this._onDidFocus = new _, this.onDidFocus = this._onDidFocus.event, this._onDidBlur = new _, this.onDidBlur = this._onDidBlur.event, this.addDisposables(this._onDidFocus, this._onDidBlur); let i = Ts(document.activeElement, e), n = !1; const r = () => { n = !1, i || (i = !0, this._onDidFocus.fire()) }, o = () => { i && (n = !0, window.setTimeout(() => { n && (n = !1, i = !1, this._onDidBlur.fire()) }, 0)) }; this._refreshStateHandler = () => { Ts(document.activeElement, e) !== i && (i ? o() : r()) }, e instanceof HTMLElement ? (this.addDisposables($(e, "focus", r, !0)), this.addDisposables($(e, "blur", o, !0))) : (this.addDisposables(mt(e, "focus", r, !0)), this.addDisposables(mt(e, "blur", o, !0))) } refreshState() { this._refreshStateHandler() } } const kh = "dv-quasiPreventDefault"; function wf(t) { t[kh] = !0 } function Za(t) { return t[kh] } function _f(t, e) { const i = Array.from(e); for (const n of i) { if (n.href) { const o = t.createElement("link"); o.href = n.href, o.type = n.type, o.rel = "stylesheet", t.head.appendChild(o) } let r = []; try { n.cssRules && (r = Array.from(n.cssRules).map(o => o.cssText)) } catch { } for (const o of r) { const s = t.createElement("style"); s.appendChild(t.createTextNode(o)), t.head.appendChild(s) } } } function Ya(t) { const { left: e, top: i, width: n, height: r } = t.getBoundingClientRect(); return { left: e + window.scrollX, top: i + window.scrollY, width: n, height: r } } function yf(t) { let e = t; for (; e != null && e.parentNode;) { if (e.parentNode === document) return !0; e.parentNode instanceof DocumentFragment ? e = e.parentNode.host : e = e.parentNode } return !1 } function vt(t) { if (t.length === 0) throw new Error("Invalid tail call"); return [t.slice(0, t.length - 1), t[t.length - 1]] } function Df(t) { return t.length > 0 ? t[t.length - 1] : void 0 } function Ph(t, e) { if (t.length !== e.length) return !1; for (let i = 0; i < t.length; i++)if (t[i] !== e[i]) return !1; return !0 } function Wo(t, e) { const i = t.indexOf(e); i > -1 && (t.splice(i, 1), t.unshift(e)) } function sr(t, e) { const i = t.indexOf(e); i > -1 && (t.splice(i, 1), t.push(e)) } function Cf(t, e) { for (let i = 0; i < t.length; i++) { const n = t[i]; if (e(n)) return i } return -1 } function Ka(t, e) { const i = t.findIndex(n => n === e); return i > -1 ? (t.splice(i, 1), !0) : !1 } const ne = (t, e, i) => { if (e > i) throw new Error(`${e} > ${i} is an invalid condition`); return Math.min(i, Math.max(t, e)) }, Ll = () => { let t = 1; return { next: () => (t++).toString() } }, Ye = (t, e) => { const i = []; if (typeof e != "number" && (e = t, t = 0), t <= e) for (let n = t; n < e; n++)i.push(n); else for (let n = t; n > e; n--)i.push(n); return i }; class Sf { set size(e) { this._size = e } get size() { return this._size } get cachedVisibleSize() { return this._cachedVisibleSize } get visible() { return typeof this._cachedVisibleSize > "u" } get minimumSize() { return this.visible ? this.view.minimumSize : 0 } get viewMinimumSize() { return this.view.minimumSize } get maximumSize() { return this.visible ? this.view.maximumSize : 0 } get viewMaximumSize() { return this.view.maximumSize } get priority() { return this.view.priority } get snap() { return !!this.view.snap } set enabled(e) { this.container.style.pointerEvents = e ? "" : "none" } constructor(e, i, n, r) { this.container = e, this.view = i, this.disposable = r, this._cachedVisibleSize = void 0, typeof n == "number" ? (this._size = n, this._cachedVisibleSize = void 0, e.classList.add("visible")) : (this._size = 0, this._cachedVisibleSize = n.cachedVisibleSize) } setVisible(e, i) { var n; e !== this.visible && (e ? (this.size = ne((n = this._cachedVisibleSize) !== null && n !== void 0 ? n : 0, this.viewMinimumSize, this.viewMaximumSize), this._cachedVisibleSize = void 0) : (this._cachedVisibleSize = typeof i == "number" ? i : this.size, this.size = 0), this.container.classList.toggle("visible", e), this.view.setVisible && this.view.setVisible(e)) } dispose() { return this.disposable.dispose(), this.view } } var I; (function (t) { t.HORIZONTAL = "HORIZONTAL", t.VERTICAL = "VERTICAL" })(I || (I = {})); var be; (function (t) { t[t.MAXIMUM = 0] = "MAXIMUM", t[t.MINIMUM = 1] = "MINIMUM", t[t.DISABLED = 2] = "DISABLED", t[t.ENABLED = 3] = "ENABLED" })(be || (be = {})); var se; (function (t) { t.Low = "low", t.High = "high", t.Normal = "normal" })(se || (se = {})); var Le; (function (t) { t.Distribute = { type: "distribute" }; function e(n) { return { type: "split", index: n } } t.Split = e; function i(n) { return { type: "invisible", cachedVisibleSize: n } } t.Invisible = i })(Le || (Le = {})); class Rn { get contentSize() { return this._contentSize } get size() { return this._size } set size(e) { this._size = e } get orthogonalSize() { return this._orthogonalSize } set orthogonalSize(e) { this._orthogonalSize = e } get length() { return this.viewItems.length } get proportions() { return this._proportions ? [...this._proportions] : void 0 } get orientation() { return this._orientation } set orientation(e) { this._orientation = e; const i = this.size; this.size = this.orthogonalSize, this.orthogonalSize = i, Ln(this.element, "horizontal", "vertical"), this.element.classList.add(this.orientation == I.HORIZONTAL ? "horizontal" : "vertical") } get minimumSize() { return this.viewItems.reduce((e, i) => e + i.minimumSize, 0) } get maximumSize() { return this.length === 0 ? Number.POSITIVE_INFINITY : this.viewItems.reduce((e, i) => e + i.maximumSize, 0) } get startSnappingEnabled() { return this._startSnappingEnabled } set startSnappingEnabled(e) { this._startSnappingEnabled !== e && (this._startSnappingEnabled = e, this.updateSashEnablement()) } get endSnappingEnabled() { return this._endSnappingEnabled } set endSnappingEnabled(e) { this._endSnappingEnabled !== e && (this._endSnappingEnabled = e, this.updateSashEnablement()) } get disabled() { return this._disabled } set disabled(e) { this._disabled = e, G(this.element, "dv-splitview-disabled", e) } constructor(e, i) { this.container = e, this.viewItems = [], this.sashes = [], this._size = 0, this._orthogonalSize = 0, this._contentSize = 0, this._proportions = void 0, this._startSnappingEnabled = !0, this._endSnappingEnabled = !0, this._disabled = !1, this._onDidSashEnd = new _, this.onDidSashEnd = this._onDidSashEnd.event, this._onDidAddView = new _, this.onDidAddView = this._onDidAddView.event, this._onDidRemoveView = new _, this.onDidRemoveView = this._onDidRemoveView.event, this.resize = (n, r, o = this.viewItems.map(c => c.size), s, l, a = Number.NEGATIVE_INFINITY, u = Number.POSITIVE_INFINITY, m, d) => { if (n < 0 || n > this.viewItems.length) return 0; const c = Ye(n, -1), v = Ye(n + 1, this.viewItems.length); if (l) for (const N of l) Wo(c, N), Wo(v, N); if (s) for (const N of s) sr(c, N), sr(v, N); const g = c.map(N => this.viewItems[N]), w = c.map(N => o[N]), C = v.map(N => this.viewItems[N]), p = v.map(N => o[N]), h = c.reduce((N, b) => N + this.viewItems[b].minimumSize - o[b], 0), f = c.reduce((N, b) => N + this.viewItems[b].maximumSize - o[b], 0), y = v.length === 0 ? Number.POSITIVE_INFINITY : v.reduce((N, b) => N + o[b] - this.viewItems[b].minimumSize, 0), S = v.length === 0 ? Number.NEGATIVE_INFINITY : v.reduce((N, b) => N + o[b] - this.viewItems[b].maximumSize, 0), E = Math.max(h, S), x = Math.min(y, f); let z = !1; if (m) { const N = this.viewItems[m.index], b = r >= m.limitDelta; z = b !== N.visible, N.setVisible(b, m.size) } if (!z && d) { const N = this.viewItems[d.index], b = r < d.limitDelta; z = b !== N.visible, N.setVisible(b, d.size) } if (z) return this.resize(n, r, o, s, l, a, u); const F = ne(r, E, x); let O = 0, ue = F; for (let N = 0; N < g.length; N++) { const b = g[N], R = ne(w[N] + ue, b.minimumSize, b.maximumSize), B = R - w[N]; O += B, ue -= B, b.size = R } let Me = O; for (let N = 0; N < C.length; N++) { const b = C[N], R = ne(p[N] - Me, b.minimumSize, b.maximumSize), B = R - p[N]; Me += B, b.size = R } return r }, this._orientation = i.orientation, this.element = this.createContainer(), this.proportionalLayout = i.proportionalLayout === void 0 ? !0 : !!i.proportionalLayout, this.viewContainer = this.createViewContainer(), this.sashContainer = this.createSashContainer(), this.element.appendChild(this.sashContainer), this.element.appendChild(this.viewContainer), this.container.appendChild(this.element), this.style(i.styles), i.descriptor && (this._size = i.descriptor.size, i.descriptor.views.forEach((n, r) => { const o = n.visible === void 0 || n.visible ? n.size : { type: "invisible", cachedVisibleSize: n.size }, s = n.view; this.addView(s, o, r, !0) }), this._contentSize = this.viewItems.reduce((n, r) => n + r.size, 0), this.saveProportions()) } style(e) { (e == null ? void 0 : e.separatorBorder) === "transparent" ? (Ln(this.element, "separator-border"), this.element.style.removeProperty("--dv-separator-border")) : (ho(this.element, "separator-border"), e != null && e.separatorBorder && this.element.style.setProperty("--dv-separator-border", e.separatorBorder)) } isViewVisible(e) { if (e < 0 || e >= this.viewItems.length) throw new Error("Index out of bounds"); return this.viewItems[e].visible } setViewVisible(e, i) { if (e < 0 || e >= this.viewItems.length) throw new Error("Index out of bounds"); G(this.container, "visible", i); const n = this.viewItems[e]; G(this.container, "visible", i), n.setVisible(i, n.size), this.distributeEmptySpace(e), this.layoutViews(), this.saveProportions() } getViewSize(e) { return e < 0 || e >= this.viewItems.length ? -1 : this.viewItems[e].size } resizeView(e, i) { if (e < 0 || e >= this.viewItems.length) return; const n = Ye(this.viewItems.length).filter(l => l !== e), r = [...n.filter(l => this.viewItems[l].priority === se.Low), e], o = n.filter(l => this.viewItems[l].priority === se.High), s = this.viewItems[e]; i = Math.round(i), i = ne(i, s.minimumSize, Math.min(s.maximumSize, this._size)), s.size = i, this.relayout(r, o) } getViews() { return this.viewItems.map(e => e.view) } onDidChange(e, i) { const n = this.viewItems.indexOf(e); if (n < 0 || n >= this.viewItems.length) return; i = typeof i == "number" ? i : e.size, i = ne(i, e.minimumSize, e.maximumSize), e.size = i; const r = Ye(this.viewItems.length).filter(l => l !== n), o = [...r.filter(l => this.viewItems[l].priority === se.Low), n], s = r.filter(l => this.viewItems[l].priority === se.High); this.relayout([...o, n], s) } addView(e, i = { type: "distribute" }, n = this.viewItems.length, r) { const o = document.createElement("div"); o.className = "view", o.appendChild(e.element); let s; typeof i == "number" ? s = i : i.type === "split" ? s = this.getViewSize(i.index) / 2 : i.type === "invisible" ? s = { cachedVisibleSize: i.cachedVisibleSize } : s = e.minimumSize; const l = e.onDidChange(u => this.onDidChange(a, u.size)), a = new Sf(o, e, s, { dispose: () => { l.dispose(), this.viewContainer.removeChild(o) } }); if (n === this.viewItems.length ? this.viewContainer.appendChild(o) : this.viewContainer.insertBefore(o, this.viewContainer.children.item(n)), this.viewItems.splice(n, 0, a), this.viewItems.length > 1) { const u = document.createElement("div"); u.className = "sash"; const m = c => { for (const R of this.viewItems) R.enabled = !1; const v = [...Ot("iframe"), ...Ot("webview")]; for (const R of v) R.style.pointerEvents = "none"; const g = this._orientation === I.HORIZONTAL ? c.clientX : c.clientY, w = Cf(this.sashes, R => R.container === u), C = this.viewItems.map(R => R.size); let p, h; const f = Ye(w, -1), y = Ye(w + 1, this.viewItems.length), S = f.reduce((R, B) => R + (this.viewItems[B].minimumSize - C[B]), 0), E = f.reduce((R, B) => R + (this.viewItems[B].viewMaximumSize - C[B]), 0), x = y.length === 0 ? Number.POSITIVE_INFINITY : y.reduce((R, B) => R + (C[B] - this.viewItems[B].minimumSize), 0), z = y.length === 0 ? Number.NEGATIVE_INFINITY : y.reduce((R, B) => R + (C[B] - this.viewItems[B].viewMaximumSize), 0), F = Math.max(S, z), O = Math.min(x, E), ue = this.findFirstSnapIndex(f), Me = this.findFirstSnapIndex(y); if (typeof ue == "number") { const R = this.viewItems[ue], B = Math.floor(R.viewMinimumSize / 2); p = { index: ue, limitDelta: R.visible ? F - B : F + B, size: R.size } } if (typeof Me == "number") { const R = this.viewItems[Me], B = Math.floor(R.viewMinimumSize / 2); h = { index: Me, limitDelta: R.visible ? O + B : O - B, size: R.size } } const N = R => { const ji = (this._orientation === I.HORIZONTAL ? R.clientX : R.clientY) - g; this.resize(w, ji, C, void 0, void 0, F, O, p, h), this.distributeEmptySpace(), this.layoutViews() }, b = () => { for (const R of this.viewItems) R.enabled = !0; for (const R of v) R.style.pointerEvents = "auto"; this.saveProportions(), document.removeEventListener("pointermove", N), document.removeEventListener("pointerup", b), document.removeEventListener("pointercancel", b), this._onDidSashEnd.fire(void 0) }; document.addEventListener("pointermove", N), document.addEventListener("pointerup", b), document.addEventListener("pointercancel", b) }; u.addEventListener("pointerdown", m); const d = { container: u, disposable: () => { u.removeEventListener("pointerdown", m), this.sashContainer.removeChild(u) } }; this.sashContainer.appendChild(u), this.sashes.push(d) } r || this.relayout([n]), !r && typeof i != "number" && i.type === "distribute" && this.distributeViewSizes(), this._onDidAddView.fire(e) } distributeViewSizes() { const e = []; let i = 0; for (const l of this.viewItems) l.maximumSize - l.minimumSize > 0 && (e.push(l), i += l.size); const n = Math.floor(i / e.length); for (const l of e) l.size = ne(n, l.minimumSize, l.maximumSize); const r = Ye(this.viewItems.length), o = r.filter(l => this.viewItems[l].priority === se.Low), s = r.filter(l => this.viewItems[l].priority === se.High); this.relayout(o, s) } removeView(e, i, n = !1) { const r = this.viewItems.splice(e, 1)[0]; if (r.dispose(), this.viewItems.length >= 1) { const o = Math.max(e - 1, 0); this.sashes.splice(o, 1)[0].disposable() } return n || this.relayout(), i && i.type === "distribute" && this.distributeViewSizes(), this._onDidRemoveView.fire(r.view), r.view } getViewCachedVisibleSize(e) { if (e < 0 || e >= this.viewItems.length) throw new Error("Index out of bounds"); return this.viewItems[e].cachedVisibleSize } moveView(e, i) { const n = this.getViewCachedVisibleSize(e), r = typeof n > "u" ? this.getViewSize(e) : Le.Invisible(n), o = this.removeView(e, void 0, !0); this.addView(o, r, i) } layout(e, i) { const n = Math.max(this.size, this._contentSize); if (this.size = e, this.orthogonalSize = i, this.proportions) { let r = 0; for (let o = 0; o < this.viewItems.length; o++) { const s = this.viewItems[o], l = this.proportions[o]; typeof l == "number" ? r += l : e -= s.size } for (let o = 0; o < this.viewItems.length; o++) { const s = this.viewItems[o], l = this.proportions[o]; typeof l == "number" && r > 0 && (s.size = ne(Math.round(l * e / r), s.minimumSize, s.maximumSize)) } } else { const r = Ye(this.viewItems.length), o = r.filter(l => this.viewItems[l].priority === se.Low), s = r.filter(l => this.viewItems[l].priority === se.High); this.resize(this.viewItems.length - 1, e - n, void 0, o, s) } this.distributeEmptySpace(), this.layoutViews() } relayout(e, i) { const n = this.viewItems.reduce((r, o) => r + o.size, 0); this.resize(this.viewItems.length - 1, this._size - n, void 0, e, i), this.distributeEmptySpace(), this.layoutViews(), this.saveProportions() } distributeEmptySpace(e) { const i = this.viewItems.reduce((l, a) => l + a.size, 0); let n = this.size - i; const r = Ye(this.viewItems.length - 1, -1), o = r.filter(l => this.viewItems[l].priority === se.Low), s = r.filter(l => this.viewItems[l].priority === se.High); for (const l of s) Wo(r, l); for (const l of o) sr(r, l); typeof e == "number" && sr(r, e); for (let l = 0; n !== 0 && l < r.length; l++) { const a = this.viewItems[r[l]], u = ne(a.size + n, a.minimumSize, a.maximumSize), m = u - a.size; n -= m, a.size = u } } saveProportions() { this.proportionalLayout && this._contentSize > 0 && (this._proportions = this.viewItems.map(e => e.visible ? e.size / this._contentSize : void 0)) } layoutViews() { this._contentSize = this.viewItems.reduce((n, r) => n + r.size, 0); let e = 0; const i = []; this.updateSashEnablement(); for (let n = 0; n < this.viewItems.length - 1; n++) { e += this.viewItems[n].size, i.push(e); const r = Math.min(Math.max(0, e - 2), this.size - 4); this._orientation === I.HORIZONTAL && (this.sashes[n].container.style.left = `${r}px`, this.sashes[n].container.style.top = "0px"), this._orientation === I.VERTICAL && (this.sashes[n].container.style.left = "0px", this.sashes[n].container.style.top = `${r}px`) } this.viewItems.forEach((n, r) => { this._orientation === I.HORIZONTAL && (n.container.style.width = `${n.size}px`, n.container.style.left = r == 0 ? "0px" : `${i[r - 1]}px`, n.container.style.top = "", n.container.style.height = ""), this._orientation === I.VERTICAL && (n.container.style.height = `${n.size}px`, n.container.style.top = r == 0 ? "0px" : `${i[r - 1]}px`, n.container.style.width = "", n.container.style.left = ""), n.view.layout(n.size, this._orthogonalSize) }) } findFirstSnapIndex(e) { for (const i of e) { const n = this.viewItems[i]; if (n.visible && n.snap) return i } for (const i of e) { const n = this.viewItems[i]; if (n.visible && n.maximumSize - n.minimumSize > 0) return; if (!n.visible && n.snap) return i } } updateSashEnablement() { let e = !1; const i = this.viewItems.map(a => e = a.size - a.minimumSize > 0 || e); e = !1; const n = this.viewItems.map(a => e = a.maximumSize - a.size > 0 || e), r = [...this.viewItems].reverse(); e = !1; const o = r.map(a => e = a.size - a.minimumSize > 0 || e).reverse(); e = !1; const s = r.map(a => e = a.maximumSize - a.size > 0 || e).reverse(); let l = 0; for (let a = 0; a < this.sashes.length; a++) { const u = this.sashes[a], m = this.viewItems[a]; l += m.size; const d = !(i[a] && s[a + 1]), c = !(n[a] && o[a + 1]); if (d && c) { const v = Ye(a, -1), g = Ye(a + 1, this.viewItems.length), w = this.findFirstSnapIndex(v), C = this.findFirstSnapIndex(g), p = typeof w == "number" && !this.viewItems[w].visible, h = typeof C == "number" && !this.viewItems[C].visible; p && o[a] && (l > 0 || this.startSnappingEnabled) ? this.updateSash(u, be.MINIMUM) : h && i[a] && (l < this._contentSize || this.endSnappingEnabled) ? this.updateSash(u, be.MAXIMUM) : this.updateSash(u, be.DISABLED) } else d && !c ? this.updateSash(u, be.MINIMUM) : !d && c ? this.updateSash(u, be.MAXIMUM) : this.updateSash(u, be.ENABLED) } } updateSash(e, i) { G(e.container, "disabled", i === be.DISABLED), G(e.container, "enabled", i === be.ENABLED), G(e.container, "maximum", i === be.MAXIMUM), G(e.container, "minimum", i === be.MINIMUM) } createViewContainer() { const e = document.createElement("div"); return e.className = "view-container", e } createSashContainer() { const e = document.createElement("div"); return e.className = "sash-container", e } createContainer() { const e = document.createElement("div"), i = this._orientation === I.HORIZONTAL ? "horizontal" : "vertical"; return e.className = `split-view-container ${i}`, e } dispose() { this._onDidSashEnd.dispose(), this._onDidAddView.dispose(), this._onDidRemoveView.dispose(); for (let e = 0; e < this.element.children.length; e++)if (this.element.children.item(e) === this.element) { this.element.removeChild(this.element); break } for (const e of this.viewItems) e.dispose(); this.element.remove() } } class Xa extends V { get onDidAddView() { return this.splitview.onDidAddView } get onDidRemoveView() { return this.splitview.onDidRemoveView } get minimumSize() { return this.splitview.minimumSize } get maximumSize() { return this.splitview.maximumSize } get orientation() { return this.splitview.orientation } get size() { return this.splitview.size } get orthogonalSize() { return this.splitview.orthogonalSize } constructor(e, i) { var n; super(), this.paneItems = [], this.skipAnimation = !1, this._onDidChange = new _, this.onDidChange = this._onDidChange.event, this._orientation = (n = i.orientation) !== null && n !== void 0 ? n : I.VERTICAL, this.element = document.createElement("div"), this.element.className = "pane-container", e.appendChild(this.element), this.splitview = new Rn(this.element, { orientation: this._orientation, proportionalLayout: !1, descriptor: i.descriptor }), this.getPanes().forEach(r => { const o = new V(r.onDidChangeExpansionState(() => { this.setupAnimation(), this._onDidChange.fire(void 0) })), s = { pane: r, disposable: { dispose: () => { o.dispose() } } }; this.paneItems.push(s), r.orthogonalSize = this.splitview.orthogonalSize }), this.addDisposables(this._onDidChange, this.splitview.onDidSashEnd(() => { this._onDidChange.fire(void 0) }), this.splitview.onDidAddView(() => { this._onDidChange.fire() }), this.splitview.onDidRemoveView(() => { this._onDidChange.fire() })) } setViewVisible(e, i) { this.splitview.setViewVisible(e, i) } addPane(e, i, n = this.splitview.length, r = !1) { const o = e.onDidChangeExpansionState(() => { this.setupAnimation(), this._onDidChange.fire(void 0) }), s = { pane: e, disposable: { dispose: () => { o.dispose() } } }; this.paneItems.splice(n, 0, s), e.orthogonalSize = this.splitview.orthogonalSize, this.splitview.addView(e, i, n, r) } getViewSize(e) { return this.splitview.getViewSize(e) } getPanes() { return this.splitview.getViews() } removePane(e, i = { skipDispose: !1 }) { const n = this.paneItems.splice(e, 1)[0]; return this.splitview.removeView(e), i.skipDispose || (n.disposable.dispose(), n.pane.dispose()), n } moveView(e, i) { if (e === i) return; const n = this.removePane(e, { skipDispose: !0 }); this.skipAnimation = !0; try { this.addPane(n.pane, n.pane.size, i, !1) } finally { this.skipAnimation = !1 } } layout(e, i) { this.splitview.layout(e, i) } setupAnimation() { this.skipAnimation || (this.animationTimer && (clearTimeout(this.animationTimer), this.animationTimer = void 0), ho(this.element, "animated"), this.animationTimer = setTimeout(() => { this.animationTimer = void 0, Ln(this.element, "animated") }, 200)) } dispose() { super.dispose(), this.animationTimer && (clearTimeout(this.animationTimer), this.animationTimer = void 0), this.paneItems.forEach(e => { e.disposable.dispose(), e.pane.dispose() }), this.paneItems = [], this.splitview.dispose(), this.element.remove() } } class ye { get minimumWidth() { return this.view.minimumWidth } get maximumWidth() { return this.view.maximumWidth } get minimumHeight() { return this.view.minimumHeight } get maximumHeight() { return this.view.maximumHeight } get priority() { return this.view.priority } get snap() { return this.view.snap } get minimumSize() { return this.orientation === I.HORIZONTAL ? this.minimumHeight : this.minimumWidth } get maximumSize() { return this.orientation === I.HORIZONTAL ? this.maximumHeight : this.maximumWidth } get minimumOrthogonalSize() { return this.orientation === I.HORIZONTAL ? this.minimumWidth : this.minimumHeight } get maximumOrthogonalSize() { return this.orientation === I.HORIZONTAL ? this.maximumWidth : this.maximumHeight } get orthogonalSize() { return this._orthogonalSize } get size() { return this._size } get element() { return this.view.element } get width() { return this.orientation === I.HORIZONTAL ? this.orthogonalSize : this.size } get height() { return this.orientation === I.HORIZONTAL ? this.size : this.orthogonalSize } constructor(e, i, n, r = 0) { this.view = e, this.orientation = i, this._onDidChange = new _, this.onDidChange = this._onDidChange.event, this._orthogonalSize = n, this._size = r, this._disposable = this.view.onDidChange(o => { o ? this._onDidChange.fire({ size: this.orientation === I.VERTICAL ? o.width : o.height, orthogonalSize: this.orientation === I.VERTICAL ? o.height : o.width }) : this._onDidChange.fire({}) }) } setVisible(e) { this.view.setVisible && this.view.setVisible(e) } layout(e, i) { this._size = e, this._orthogonalSize = i, this.view.layout(this.width, this.height) } dispose() { this._onDidChange.dispose(), this._disposable.dispose() } } class oe extends V { get width() { return this.orientation === I.HORIZONTAL ? this.size : this.orthogonalSize } get height() { return this.orientation === I.HORIZONTAL ? this.orthogonalSize : this.size } get minimumSize() { return this.children.length === 0 ? 0 : Math.max(...this.children.map((e, i) => this.splitview.isViewVisible(i) ? e.minimumOrthogonalSize : 0)) } get maximumSize() { return Math.min(...this.children.map((e, i) => this.splitview.isViewVisible(i) ? e.maximumOrthogonalSize : Number.POSITIVE_INFINITY)) } get minimumOrthogonalSize() { return this.splitview.minimumSize } get maximumOrthogonalSize() { return this.splitview.maximumSize } get orthogonalSize() { return this._orthogonalSize } get size() { return this._size } get minimumWidth() { return this.orientation === I.HORIZONTAL ? this.minimumOrthogonalSize : this.minimumSize } get minimumHeight() { return this.orientation === I.HORIZONTAL ? this.minimumSize : this.minimumOrthogonalSize } get maximumWidth() { return this.orientation === I.HORIZONTAL ? this.maximumOrthogonalSize : this.maximumSize } get maximumHeight() { return this.orientation === I.HORIZONTAL ? this.maximumSize : this.maximumOrthogonalSize } get priority() { if (this.children.length === 0) return se.Normal; const e = this.children.map(i => typeof i.priority > "u" ? se.Normal : i.priority); return e.some(i => i === se.High) ? se.High : e.some(i => i === se.Low) ? se.Low : se.Normal } get disabled() { return this.splitview.disabled } set disabled(e) { this.splitview.disabled = e } constructor(e, i, n, r, o, s, l) { if (super(), this.orientation = e, this.proportionalLayout = i, this.styles = n, this._childrenDisposable = Oe.NONE, this.children = [], this._onDidChange = new _, this.onDidChange = this._onDidChange.event, this._onDidVisibilityChange = new _, this.onDidVisibilityChange = this._onDidVisibilityChange.event, this._orthogonalSize = o, this._size = r, this.element = document.createElement("div"), this.element.className = "branch-node", !l) this.splitview = new Rn(this.element, { orientation: this.orientation, proportionalLayout: i, styles: n }), this.splitview.layout(this.size, this.orthogonalSize); else { const a = { views: l.map(u => ({ view: u.node, size: u.node.size, visible: u.node instanceof ye && u.visible !== void 0 ? u.visible : !0 })), size: this.orthogonalSize }; this.children = l.map(u => u.node), this.splitview = new Rn(this.element, { orientation: this.orientation, descriptor: a, proportionalLayout: i, styles: n }) } this.disabled = s, this.addDisposables(this._onDidChange, this._onDidVisibilityChange, this.splitview.onDidSashEnd(() => { this._onDidChange.fire({}) })), this.setupChildrenEvents() } setVisible(e) { for (const i of this.children) i.setVisible(e) } isChildVisible(e) { if (e < 0 || e >= this.children.length) throw new Error("Invalid index"); return this.splitview.isViewVisible(e) } setChildVisible(e, i) { if (e < 0 || e >= this.children.length) throw new Error("Invalid index"); if (this.splitview.isViewVisible(e) === i) return; const n = this.splitview.contentSize === 0; this.splitview.setViewVisible(e, i); const r = this.splitview.contentSize === 0; (i && n || !i && r) && this._onDidVisibilityChange.fire(i) } moveChild(e, i) { if (e === i) return; if (e < 0 || e >= this.children.length) throw new Error("Invalid from index"); e < i && i--, this.splitview.moveView(e, i); const n = this._removeChild(e); this._addChild(n, i) } getChildSize(e) { if (e < 0 || e >= this.children.length) throw new Error("Invalid index"); return this.splitview.getViewSize(e) } resizeChild(e, i) { if (e < 0 || e >= this.children.length) throw new Error("Invalid index"); this.splitview.resizeView(e, i) } layout(e, i) { this._size = i, this._orthogonalSize = e, this.splitview.layout(i, e) } addChild(e, i, n, r) { if (n < 0 || n > this.children.length) throw new Error("Invalid index"); this.splitview.addView(e, i, n, r), this._addChild(e, n) } getChildCachedVisibleSize(e) { if (e < 0 || e >= this.children.length) throw new Error("Invalid index"); return this.splitview.getViewCachedVisibleSize(e) } removeChild(e, i) { if (e < 0 || e >= this.children.length) throw new Error("Invalid index"); return this.splitview.removeView(e, i), this._removeChild(e) } _addChild(e, i) { this.children.splice(i, 0, e), this.setupChildrenEvents() } _removeChild(e) { const [i] = this.children.splice(e, 1); return this.setupChildrenEvents(), i } setupChildrenEvents() { this._childrenDisposable.dispose(), this._childrenDisposable = new V(ni.any(...this.children.map(e => e.onDidChange))(e => { this._onDidChange.fire({ size: e.orthogonalSize }) }), ...this.children.map((e, i) => e instanceof oe ? e.onDidVisibilityChange(n => { this.setChildVisible(i, n) }) : Oe.NONE)) } dispose() { this._childrenDisposable.dispose(), this.splitview.dispose(), this.children.forEach(e => e.dispose()), super.dispose() } } function Gs(t, e) { if (t instanceof ye) return t; if (t instanceof oe) return Gs(t.children[e ? t.children.length - 1 : 0], e); throw new Error("invalid node") } function Vs(t, e, i) { if (t instanceof oe) { const n = new oe(ct(t.orientation), t.proportionalLayout, t.styles, e, i, t.disabled); let r = 0; for (let o = t.children.length - 1; o >= 0; o--) { const s = t.children[o], l = s instanceof oe ? s.orthogonalSize : s.size; let a = t.size === 0 ? 0 : Math.round(e * l / t.size); r += a, o === 0 && (a += e - r), n.addChild(Vs(s, i, a), a, 0, !0) } return n } else return new ye(t.view, ct(t.orientation), i) } function Ef(t) { const e = t.parentElement; if (!e) throw new Error("Invalid grid element"); let i = e.firstElementChild, n = 0; for (; i !== t && i !== e.lastElementChild && i;)i = i.nextElementSibling, n++; return n } function q(t) { const e = t.parentElement; if (!e) throw new Error("Invalid grid element"); if (/\bgrid-view\b/.test(e.className)) return []; const i = Ef(e), n = e.parentElement.parentElement.parentElement; return [...q(n), i] } function ot(t, e, i) { const n = kf(t, e), r = xf(i); if (n === r) { const [o, s] = vt(e); let l = s; return (i === "right" || i === "bottom") && (l += 1), [...o, l] } else { const o = i === "right" || i === "bottom" ? 1 : 0; return [...e, o] } } function xf(t) { return t === "top" || t === "bottom" ? I.VERTICAL : I.HORIZONTAL } function kf(t, e) { return e.length % 2 === 0 ? ct(t) : t } const ct = t => t === I.HORIZONTAL ? I.VERTICAL : I.HORIZONTAL; function Pf(t) { return !!t.children } const zh = (t, e) => { const i = e === I.VERTICAL ? t.box.width : t.box.height; return Pf(t) ? { type: "branch", data: t.children.map(n => zh(n, ct(e))), size: i } : typeof t.cachedVisibleSize == "number" ? { type: "leaf", data: t.view.toJSON(), size: t.cachedVisibleSize, visible: !1 } : { type: "leaf", data: t.view.toJSON(), size: i } }; class zf { get length() { return this._root ? this._root.children.length : 0 } get orientation() { return this.root.orientation } set orientation(e) { if (this.root.orientation === e) return; const { size: i, orthogonalSize: n } = this.root; this.root = Vs(this.root, n, i), this.root.layout(i, n) } get width() { return this.root.width } get height() { return this.root.height } get minimumWidth() { return this.root.minimumWidth } get minimumHeight() { return this.root.minimumHeight } get maximumWidth() { return this.root.maximumHeight } get maximumHeight() { return this.root.maximumHeight } get locked() { return this._locked } set locked(e) { this._locked = e; const i = [this.root]; for (; i.length > 0;) { const n = i.pop(); n instanceof oe && (n.disabled = e, i.push(...n.children)) } } maximizedView() { var e; return (e = this._maximizedNode) === null || e === void 0 ? void 0 : e.leaf.view } hasMaximizedView() { return this._maximizedNode !== void 0 } maximizeView(e) { var i; const n = q(e.element), [r, o] = this.getNode(n); if (!(o instanceof ye) || ((i = this._maximizedNode) === null || i === void 0 ? void 0 : i.leaf) === o) return; this.hasMaximizedView() && this.exitMaximizedView(); const s = []; function l(a, u) { for (let m = 0; m < a.children.length; m++) { const d = a.children[m]; d instanceof ye ? d !== u && (a.isChildVisible(m) ? a.setChildVisible(m, !1) : s.push(d)) : l(d, u) } } l(this.root, o), this._maximizedNode = { leaf: o, hiddenOnMaximize: s }, this._onDidMaximizedNodeChange.fire() } exitMaximizedView() { if (!this._maximizedNode) return; const e = this._maximizedNode.hiddenOnMaximize; function i(n) { for (let r = n.children.length - 1; r >= 0; r--) { const o = n.children[r]; o instanceof ye ? e.includes(o) || n.setChildVisible(r, !0) : i(o) } } i(this.root), this._maximizedNode = void 0, this._onDidMaximizedNodeChange.fire() } serialize() { return this.hasMaximizedView() && this.exitMaximizedView(), { root: zh(this.getView(), this.orientation), width: this.width, height: this.height, orientation: this.orientation } } dispose() { this.disposable.dispose(), this._onDidChange.dispose(), this._onDidMaximizedNodeChange.dispose(), this.root.dispose(), this._maximizedNode = void 0, this.element.remove() } clear() { const e = this.root.orientation; this.root = new oe(e, this.proportionalLayout, this.styles, this.root.size, this.root.orthogonalSize, this._locked) } deserialize(e, i) { const n = e.orientation, r = n === I.VERTICAL ? e.height : e.width; this._deserialize(e.root, n, i, r) } _deserialize(e, i, n, r) { this.root = this._deserializeNode(e, i, n, r) } _deserializeNode(e, i, n, r) { let o; if (e.type === "branch") { const l = e.data.map(a => ({ node: this._deserializeNode(a, ct(i), n, e.size), visible: a.visible })); o = new oe(i, this.proportionalLayout, this.styles, e.size, r, this._locked, l) } else o = new ye(n.fromJSON(e), i, r, e.size); return o } get root() { return this._root } set root(e) { const i = this._root; i && (i.dispose(), this._maximizedNode = void 0, this.element.removeChild(i.element)), this._root = e, this.element.appendChild(this._root.element), this.disposable.value = this._root.onDidChange(n => { this._onDidChange.fire(n) }) } insertOrthogonalSplitviewAtRoot() { if (!this._root) return; const e = this.root; if (e.element.remove(), this._root = new oe(ct(e.orientation), this.proportionalLayout, this.styles, this.root.orthogonalSize, this.root.size, this._locked), e.children.length !== 0) if (e.children.length === 1) { const i = e.children[0]; e.removeChild(0).dispose(), e.dispose(), this._root.addChild(Vs(i, i.orthogonalSize, i.size), Le.Distribute, 0) } else this._root.addChild(e, Le.Distribute, 0); this.element.appendChild(this._root.element), this.disposable.value = this._root.onDidChange(i => { this._onDidChange.fire(i) }) } next(e) { return this.progmaticSelect(e) } previous(e) { return this.progmaticSelect(e, !0) } getView(e) { const i = e ? this.getNode(e)[1] : this.root; return this._getViews(i, this.orientation) } _getViews(e, i, n) { const r = { height: e.height, width: e.width }; if (e instanceof ye) return { box: r, view: e.view, cachedVisibleSize: n }; const o = []; for (let s = 0; s < e.children.length; s++) { const l = e.children[s], a = e.getChildCachedVisibleSize(s); o.push(this._getViews(l, ct(i), a)) } return { box: r, children: o } } progmaticSelect(e, i = !1) { const [n, r] = this.getNode(e); if (!(r instanceof ye)) throw new Error("invalid location"); for (let o = n.length - 1; o > -1; o--) { const s = n[o], l = e[o] || 0; if (i ? l - 1 > -1 : l + 1 < s.children.length) return Gs(s.children[i ? l - 1 : l + 1], i) } return Gs(this.root, i) } constructor(e, i, n) { this.proportionalLayout = e, this.styles = i, this._locked = !1, this._maximizedNode = void 0, this.disposable = new Qe, this._onDidChange = new _, this.onDidChange = this._onDidChange.event, this._onDidMaximizedNodeChange = new _, this.onDidMaximizedNodeChange = this._onDidMaximizedNodeChange.event, this.element = document.createElement("div"), this.element.className = "grid-view", this.root = new oe(n, e, i, 0, 0, this._locked) } isViewVisible(e) { const [i, n] = vt(e), [, r] = this.getNode(i); if (!(r instanceof oe)) throw new Error("Invalid from location"); return r.isChildVisible(n) } setViewVisible(e, i) { this.hasMaximizedView() && this.exitMaximizedView(); const [n, r] = vt(e), [, o] = this.getNode(n); if (!(o instanceof oe)) throw new Error("Invalid from location"); o.setChildVisible(r, i) } moveView(e, i, n) { this.hasMaximizedView() && this.exitMaximizedView(); const [, r] = this.getNode(e); if (!(r instanceof oe)) throw new Error("Invalid location"); r.moveChild(i, n) } addView(e, i, n) { this.hasMaximizedView() && this.exitMaximizedView(); const [r, o] = vt(n), [s, l] = this.getNode(r); if (l instanceof oe) { const a = new ye(e, ct(l.orientation), l.orthogonalSize); l.addChild(a, i, o) } else { const [a, ...u] = [...s].reverse(), [m, ...d] = [...r].reverse(); let c = 0; const v = a.getChildCachedVisibleSize(m); typeof v == "number" && (c = Le.Invisible(v)), a.removeChild(m).dispose(); const w = new oe(l.orientation, this.proportionalLayout, this.styles, l.size, l.orthogonalSize, this._locked); a.addChild(w, l.size, m); const C = new ye(l.view, a.orientation, l.size); w.addChild(C, c, 0), typeof i != "number" && i.type === "split" && (i = { type: "split", index: 0 }); const p = new ye(e, a.orientation, l.size); w.addChild(p, i, o) } } remove(e, i) { const n = q(e.element); return this.removeView(n, i) } removeView(e, i) { this.hasMaximizedView() && this.exitMaximizedView(); const [n, r] = vt(e), [o, s] = this.getNode(n); if (!(s instanceof oe)) throw new Error("Invalid location"); const l = s.children[r]; if (!(l instanceof ye)) throw new Error("Invalid location"); if (s.removeChild(r, i), l.dispose(), s.children.length !== 1) return l.view; const a = s.children[0]; if (o.length === 0) return a instanceof ye || (s.removeChild(0, i), this.root = a), l.view; const [u, ...m] = [...o].reverse(), [d, ...c] = [...n].reverse(), v = s.isChildVisible(0); s.removeChild(0, i); const g = u.children.map((w, C) => u.getChildSize(C)); if (u.removeChild(d, i).dispose(), a instanceof oe) { g.splice(d, 1, ...a.children.map(w => w.size)); for (let w = 0; w < a.children.length; w++) { const C = a.children[w]; u.addChild(C, C.size, d + w) } for (; a.children.length > 0;)a.removeChild(0) } else { const w = new ye(a.view, ct(a.orientation), a.size), C = v ? a.orthogonalSize : Le.Invisible(a.orthogonalSize); u.addChild(w, C, d) } a.dispose(); for (let w = 0; w < g.length; w++)u.resizeChild(w, g[w]); return l.view } layout(e, i) { const [n, r] = this.root.orientation === I.HORIZONTAL ? [i, e] : [e, i]; this.root.layout(n, r) } getNode(e, i = this.root, n = []) { if (e.length === 0) return [n, i]; if (!(i instanceof oe)) throw new Error("Invalid location"); const [r, ...o] = e; if (r < 0 || r >= i.children.length) throw new Error("Invalid location"); const s = i.children[r]; return n.push(i), this.getNode(o, s, n) } } class Ah { get minimumSize() { return this.component.minimumSize } get maximumSize() { return this.component.maximumSize } get width() { return this.component.width } get height() { return this.component.height } get length() { return this.component.length } get orientation() { return this.component.orientation } get panels() { return this.component.panels } get onDidLayoutFromJSON() { return this.component.onDidLayoutFromJSON } get onDidLayoutChange() { return this.component.onDidLayoutChange } get onDidAddView() { return this.component.onDidAddView } get onDidRemoveView() { return this.component.onDidRemoveView } constructor(e) { this.component = e } updateOptions(e) { this.component.updateOptions(e) } removePanel(e, i) { this.component.removePanel(e, i) } focus() { this.component.focus() } getPanel(e) { return this.component.getPanel(e) } layout(e, i) { return this.component.layout(e, i) } addPanel(e) { return this.component.addPanel(e) } movePanel(e, i) { this.component.movePanel(e, i) } fromJSON(e) { this.component.fromJSON(e) } toJSON() { return this.component.toJSON() } clear() { this.component.clear() } } class Wi { get minimumSize() { return this.component.minimumSize } get maximumSize() { return this.component.maximumSize } get width() { return this.component.width } get height() { return this.component.height } get panels() { return this.component.panels } get onDidLayoutChange() { return this.component.onDidLayoutChange } get onDidLayoutFromJSON() { return this.component.onDidLayoutFromJSON } get onDidAddView() { return this.component.onDidAddView } get onDidRemoveView() { return this.component.onDidRemoveView } get onDidDrop() { const e = new _, i = this.component.onDidDrop(n => { e.fire(Object.assign(Object.assign({}, n), { api: this })) }); return e.dispose = () => { i.dispose(), e.dispose() }, e.event } constructor(e) { this.component = e } removePanel(e) { this.component.removePanel(e) } getPanel(e) { return this.component.getPanel(e) } movePanel(e, i) { this.component.movePanel(e, i) } focus() { this.component.focus() } layout(e, i) { this.component.layout(e, i) } addPanel(e) { return this.component.addPanel(e) } fromJSON(e) { this.component.fromJSON(e) } toJSON() { return this.component.toJSON() } clear() { this.component.clear() } } class Ih { get width() { return this.component.width } get height() { return this.component.height } get minimumHeight() { return this.component.minimumHeight } get maximumHeight() { return this.component.maximumHeight } get minimumWidth() { return this.component.minimumWidth } get maximumWidth() { return this.component.maximumWidth } get onDidLayoutChange() { return this.component.onDidLayoutChange } get onDidAddPanel() { return this.component.onDidAddGroup } get onDidRemovePanel() { return this.component.onDidRemoveGroup } get onDidActivePanelChange() { return this.component.onDidActiveGroupChange } get onDidLayoutFromJSON() { return this.component.onDidLayoutFromJSON } get panels() { return this.component.groups } get orientation() { return this.component.orientation } set orientation(e) { this.component.updateOptions({ orientation: e }) } constructor(e) { this.component = e } focus() { this.component.focus() } layout(e, i, n = !1) { this.component.layout(e, i, n) } addPanel(e) { return this.component.addPanel(e) } removePanel(e, i) { this.component.removePanel(e, i) } movePanel(e, i) { this.component.movePanel(e, i) } getPanel(e) { return this.component.getPanel(e) } fromJSON(e) { return this.component.fromJSON(e) } toJSON() { return this.component.toJSON() } clear() { this.component.clear() } } class Tn { get id() { return this.component.id } get width() { return this.component.width } get height() { return this.component.height } get minimumHeight() { return this.component.minimumHeight } get maximumHeight() { return this.component.maximumHeight } get minimumWidth() { return this.component.minimumWidth } get maximumWidth() { return this.component.maximumWidth } get size() { return this.component.size } get totalPanels() { return this.component.totalPanels } get onDidActiveGroupChange() { return this.component.onDidActiveGroupChange } get onDidAddGroup() { return this.component.onDidAddGroup } get onDidRemoveGroup() { return this.component.onDidRemoveGroup } get onDidActivePanelChange() { return this.component.onDidActivePanelChange } get onDidAddPanel() { return this.component.onDidAddPanel } get onDidRemovePanel() { return this.component.onDidRemovePanel } get onDidLayoutFromJSON() { return this.component.onDidLayoutFromJSON } get onDidLayoutChange() { return this.component.onDidLayoutChange } get onDidDrop() { return this.component.onDidDrop } get onWillDrop() { return this.component.onWillDrop } get onWillShowOverlay() { return this.component.onWillShowOverlay } get onWillDragGroup() { return this.component.onWillDragGroup } get onWillDragPanel() { return this.component.onWillDragPanel } get panels() { return this.component.panels } get groups() { return this.component.groups } get activePanel() { return this.component.activePanel } get activeGroup() { return this.component.activeGroup } constructor(e) { this.component = e } focus() { this.component.focus() } getPanel(e) { return this.component.getGroupPanel(e) } layout(e, i, n = !1) { this.component.layout(e, i, n) } addPanel(e) { return this.component.addPanel(e) } removePanel(e) { this.component.removePanel(e) } addGroup(e) { return this.component.addGroup(e) } closeAllGroups() { return this.component.closeAllGroups() } removeGroup(e) { this.component.removeGroup(e) } getGroup(e) { return this.component.getPanel(e) } addFloatingGroup(e, i) { return this.component.addFloatingGroup(e, i) } fromJSON(e) { this.component.fromJSON(e) } toJSON() { return this.component.toJSON() } clear() { this.component.clear() } moveToNext(e) { this.component.moveToNext(e) } moveToPrevious(e) { this.component.moveToPrevious(e) } maximizeGroup(e) { this.component.maximizeGroup(e.group) } hasMaximizedGroup() { return this.component.hasMaximizedGroup() } exitMaximizedGroup() { this.component.exitMaximizedGroup() } get onDidMaximizedGroupChange() { return this.component.onDidMaximizedGroupChange } addPopoutGroup(e, i) { return this.component.addPopoutGroup(e, i) } } class Nh extends V { constructor(e, i) { super(), this.element = e, this.callbacks = i, this.target = null, this.registerListeners() } onDragEnter(e) { this.target = e.target, this.callbacks.onDragEnter(e) } onDragOver(e) { e.preventDefault(), this.callbacks.onDragOver && this.callbacks.onDragOver(e) } onDragLeave(e) { this.target === e.target && (this.target = null, this.callbacks.onDragLeave(e)) } onDragEnd(e) { this.target = null, this.callbacks.onDragEnd(e) } onDrop(e) { this.callbacks.onDrop(e) } registerListeners() { this.addDisposables($(this.element, "dragenter", e => { this.onDragEnter(e) }, !0)), this.addDisposables($(this.element, "dragover", e => { this.onDragOver(e) }, !0)), this.addDisposables($(this.element, "dragleave", e => { this.onDragLeave(e) })), this.addDisposables($(this.element, "dragend", e => { this.onDragEnd(e) })), this.addDisposables($(this.element, "drop", e => { this.onDrop(e) })) } } class Af extends Ol { get nativeEvent() { return this.options.nativeEvent } get position() { return this.options.position } constructor(e) { super(), this.options = e } } function qa(t) { switch (t) { case "above": return "top"; case "below": return "bottom"; case "left": return "left"; case "right": return "right"; case "within": return "center"; default: throw new Error(`invalid direction '${t}'`) } } function If(t) { switch (t) { case "top": return "above"; case "bottom": return "below"; case "left": return "left"; case "right": return "right"; case "center": return "within"; default: throw new Error(`invalid position '${t}'`) } } const Nf = { value: 20, type: "percentage" }, Of = { value: 50, type: "percentage" }, Lf = 100, Rf = 100; class Ct extends V { get state() { return this._state } constructor(e, i) { super(), this.element = e, this.options = i, this._onDrop = new _, this.onDrop = this._onDrop.event, this._onWillShowOverlay = new _, this.onWillShowOverlay = this._onWillShowOverlay.event, this._acceptedTargetZonesSet = new Set(this.options.acceptedTargetZones), this.dnd = new Nh(this.element, { onDragEnter: () => { }, onDragOver: n => { if (this._acceptedTargetZonesSet.size === 0) { this.removeDropTarget(); return } const r = this.element.clientWidth, o = this.element.clientHeight; if (r === 0 || o === 0) return; const s = n.currentTarget.getBoundingClientRect(), l = n.clientX - s.left, a = n.clientY - s.top, u = this.calculateQuadrant(this._acceptedTargetZonesSet, l, a, r, o); if (this.isAlreadyUsed(n) || u === null) { this.removeDropTarget(); return } const m = new Af({ nativeEvent: n, position: u }); if (this._onWillShowOverlay.fire(m), m.defaultPrevented) { this.removeDropTarget(); return } if (typeof this.options.canDisplayOverlay == "boolean") { if (!this.options.canDisplayOverlay) { this.removeDropTarget(); return } } else if (!this.options.canDisplayOverlay(n, u)) { this.removeDropTarget(); return } this.markAsUsed(n), this.targetElement || (this.targetElement = document.createElement("div"), this.targetElement.className = "drop-target-dropzone", this.overlayElement = document.createElement("div"), this.overlayElement.className = "drop-target-selection", this._state = "center", this.targetElement.appendChild(this.overlayElement), this.element.classList.add("drop-target"), this.element.append(this.targetElement)), this.toggleClasses(u, r, o), this._state = u }, onDragLeave: () => { this.removeDropTarget() }, onDragEnd: () => { this.removeDropTarget() }, onDrop: n => { n.preventDefault(); const r = this._state; this.removeDropTarget(), r && (n.stopPropagation(), this._onDrop.fire({ position: r, nativeEvent: n })) } }), this.addDisposables(this._onDrop, this._onWillShowOverlay, this.dnd) } setTargetZones(e) { this._acceptedTargetZonesSet = new Set(e) } setOverlayModel(e) { this.options.overlayModel = e } dispose() { this.removeDropTarget(), super.dispose() } markAsUsed(e) { e[Ct.USED_EVENT_ID] = !0 } isAlreadyUsed(e) { const i = e[Ct.USED_EVENT_ID]; return typeof i == "boolean" && i } toggleClasses(e, i, n) { var r, o; if (!this.overlayElement) return; const s = i < Lf, l = n < Rf, a = e === "left", u = e === "right", m = e === "top", d = e === "bottom", c = !s && u, v = !s && a, g = !l && m, w = !l && d; let C = 1; const p = (o = (r = this.options.overlayModel) === null || r === void 0 ? void 0 : r.size) !== null && o !== void 0 ? o : Of; p.type === "percentage" ? C = ne(p.value, 0, 100) / 100 : ((c || v) && (C = ne(0, p.value, i) / i), (g || w) && (C = ne(0, p.value, n) / n)); const h = { top: "0px", left: "0px", width: "100%", height: "100%" }; c ? (h.left = `${100 * (1 - C)}%`, h.width = `${100 * C}%`) : v ? h.width = `${100 * C}%` : g ? h.height = `${100 * C}%` : w && (h.top = `${100 * (1 - C)}%`, h.height = `${100 * C}%`), this.overlayElement.style.top = h.top, this.overlayElement.style.left = h.left, this.overlayElement.style.width = h.width, this.overlayElement.style.height = h.height, G(this.overlayElement, "dv-drop-target-small-vertical", l), G(this.overlayElement, "dv-drop-target-small-horizontal", s), G(this.overlayElement, "dv-drop-target-left", a), G(this.overlayElement, "dv-drop-target-right", u), G(this.overlayElement, "dv-drop-target-top", m), G(this.overlayElement, "dv-drop-target-bottom", d), G(this.overlayElement, "dv-drop-target-center", e === "center") } calculateQuadrant(e, i, n, r, o) { var s, l; const a = (l = (s = this.options.overlayModel) === null || s === void 0 ? void 0 : s.activationSize) !== null && l !== void 0 ? l : Nf; return a.type === "percentage" ? Tf(e, i, n, r, o, a.value) : Gf(e, i, n, r, o, a.value) } removeDropTarget() { this.targetElement && (this._state = void 0, this.element.removeChild(this.targetElement), this.targetElement = void 0, this.overlayElement = void 0, this.element.classList.remove("drop-target")) } } Ct.USED_EVENT_ID = "__dockview_droptarget_event_is_used__"; function Tf(t, e, i, n, r, o) { const s = 100 * e / n, l = 100 * i / r; return t.has("left") && s < o ? "left" : t.has("right") && s > 100 - o ? "right" : t.has("top") && l < o ? "top" : t.has("bottom") && l > 100 - o ? "bottom" : t.has("center") ? "center" : null } function Gf(t, e, i, n, r, o) { return t.has("left") && e < o ? "left" : t.has("right") && e > n - o ? "right" : t.has("top") && i < o ? "top" : t.has("bottom") && i > r - o ? "bottom" : t.has("center") ? "center" : null } class Vf extends V { get element() { return this._element } constructor(e, i) { super(), this.accessor = e, this.group = i, this.disposable = new Qe, this._onDidFocus = new _, this.onDidFocus = this._onDidFocus.event, this._onDidBlur = new _, this.onDidBlur = this._onDidBlur.event, this._element = document.createElement("div"), this._element.className = "content-container", this._element.tabIndex = -1, this.addDisposables(this._onDidFocus, this._onDidBlur), this.dropTarget = new Ct(this.element, { acceptedTargetZones: ["top", "bottom", "left", "right", "center"], canDisplayOverlay: (n, r) => { if (this.group.locked === "no-drop-target" || this.group.locked && r === "center") return !1; const o = Fe(); return !o && n.shiftKey && this.group.location.type !== "floating" ? !1 : o && o.viewId === this.accessor.id ? o.groupId === this.group.id && (r === "center" || o.panelId === null) ? !1 : !(this.group.panels.length === 1 && o.groupId === this.group.id) : this.group.canDisplayOverlay(n, r, "content") } }), this.addDisposables(this.dropTarget) } show() { this.element.style.display = "" } hide() { this.element.style.display = "none" } renderPanel(e, i = { asActive: !0 }) { const n = i.asActive || this.panel && this.group.isPanelActive(this.panel); this.panel && this.panel.view.content.element.parentElement === this._element && this._element.removeChild(this.panel.view.content.element), this.panel = e; let r; switch (e.api.renderer) { case "onlyWhenVisibile": this.group.renderContainer.detatch(e), this.panel && n && this._element.appendChild(this.panel.view.content.element), r = this._element; break; case "always": e.view.content.element.parentElement === this._element && this._element.removeChild(e.view.content.element), r = this.group.renderContainer.attach({ panel: e, referenceContainer: this }); break }if (n) { const o = e.view.content.onDidFocus, s = e.view.content.onDidBlur, l = xh(r), a = new V; a.addDisposables(l, l.onDidFocus(() => this._onDidFocus.fire()), l.onDidBlur(() => this._onDidBlur.fire())), o && a.addDisposables(o(() => this._onDidFocus.fire())), s && a.addDisposables(s(() => this._onDidBlur.fire())), this.disposable.value = a } } openPanel(e) { this.panel !== e && this.renderPanel(e) } layout(e, i) { } closePanel() { var e; this.panel && this.panel.api.renderer === "onlyWhenVisibile" && ((e = this.panel.view.content.element.parentElement) === null || e === void 0 || e.removeChild(this.panel.view.content.element)), this.panel = void 0 } dispose() { this.disposable.dispose(), super.dispose() } } class Rl extends V { constructor(e) { super(), this.el = e, this.dataDisposable = new Qe, this.pointerEventsDisposable = new Qe, this._onDragStart = new _, this.onDragStart = this._onDragStart.event, this.addDisposables(this._onDragStart, this.dataDisposable, this.pointerEventsDisposable), this.configure() } isCancelled(e) { return !1 } configure() { this.addDisposables(this._onDragStart, $(this.el, "dragstart", e => { if (e.defaultPrevented || this.isCancelled(e)) { e.preventDefault(); return } const i = [...Ot("iframe"), ...Ot("webview")]; this.pointerEventsDisposable.value = { dispose: () => { for (const n of i) n.style.pointerEvents = "auto" } }; for (const n of i) n.style.pointerEvents = "none"; this.el.classList.add("dv-dragged"), setTimeout(() => this.el.classList.remove("dv-dragged"), 0), this.dataDisposable.value = this.getData(e), this._onDragStart.fire(e), e.dataTransfer && (e.dataTransfer.effectAllowed = "move", e.dataTransfer.items.length > 0 || e.dataTransfer.setData("text/plain", "__dockview_internal_drag_event__")) }), $(this.el, "dragend", () => { this.pointerEventsDisposable.dispose(), this.dataDisposable.dispose() })) } } class Mf extends Rl { constructor(e, i, n, r) { super(e), this.accessor = i, this.group = n, this.panel = r, this.panelTransfer = ut.getInstance() } getData(e) { return this.panelTransfer.setData([new Ft(this.accessor.id, this.group.id, this.panel.id)], Ft.prototype), { dispose: () => { this.panelTransfer.clearData(Ft.prototype) } } } } class bf extends V { get element() { return this._element } constructor(e, i, n) { super(), this.panel = e, this.accessor = i, this.group = n, this.content = void 0, this._onChanged = new _, this.onChanged = this._onChanged.event, this._onDropped = new _, this.onDrop = this._onDropped.event, this._onDragStart = new _, this.onDragStart = this._onDragStart.event, this._element = document.createElement("div"), this._element.className = "tab", this._element.tabIndex = 0, this._element.draggable = !0, G(this.element, "inactive-tab", !0); const r = new Mf(this._element, this.accessor, this.group, this.panel); this.dropTarget = new Ct(this._element, { acceptedTargetZones: ["center"], canDisplayOverlay: (o, s) => { if (this.group.locked) return !1; const l = Fe(); return l && this.accessor.id === l.viewId ? l.panelId === null && l.groupId === this.group.id ? !1 : this.panel.id !== l.panelId : this.group.model.canDisplayOverlay(o, s, "tab") } }), this.onWillShowOverlay = this.dropTarget.onWillShowOverlay, this.addDisposables(this._onChanged, this._onDropped, this._onDragStart, r.onDragStart(o => { this._onDragStart.fire(o) }), r, $(this._element, "mousedown", o => { o.defaultPrevented || this._onChanged.fire(o) }), this.dropTarget.onDrop(o => { this._onDropped.fire(o) }), this.dropTarget) } setActive(e) { G(this.element, "active-tab", e), G(this.element, "inactive-tab", !e) } setContent(e) { this.content && this._element.removeChild(this.content.element), this.content = e, this._element.appendChild(this.content.element) } dispose() { super.dispose() } } function Wf(t, e) { ho(e, "dv-dragged"), document.body.appendChild(e), t.setDragImage(e, 0, 0), setTimeout(() => { Ln(e, "dv-dragged"), e.remove() }, 0) } class Hf extends Rl { constructor(e, i, n) { super(e), this.accessor = i, this.group = n, this.panelTransfer = ut.getInstance(), this.addDisposables($(e, "mousedown", r => { r.shiftKey && wf(r) }, !0)) } isCancelled(e) { return this.group.api.location.type === "floating" && !e.shiftKey } getData(e) { const i = e.dataTransfer; this.panelTransfer.setData([new Ft(this.accessor.id, this.group.id, null)], Ft.prototype); const n = window.getComputedStyle(this.el), r = n.getPropertyValue("--dv-activegroup-visiblepanel-tab-background-color"), o = n.getPropertyValue("--dv-activegroup-visiblepanel-tab-color"); if (i) { const s = document.createElement("div"); s.style.backgroundColor = r, s.style.color = o, s.style.padding = "2px 8px", s.style.height = "24px", s.style.fontSize = "11px", s.style.lineHeight = "20px", s.style.borderRadius = "12px", s.style.position = "absolute", s.textContent = `Multiple Panels (${this.group.size})`, Wf(i, s) } return { dispose: () => { this.panelTransfer.clearData(Ft.prototype) } } } } class Ff extends V { get element() { return this._element } constructor(e, i) { super(), this.accessor = e, this.group = i, this._onDrop = new _, this.onDrop = this._onDrop.event, this._onDragStart = new _, this.onDragStart = this._onDragStart.event, this._element = document.createElement("div"), this._element.className = "void-container", this._element.tabIndex = 0, this._element.draggable = !0, this.addDisposables(this._onDrop, this._onDragStart, $(this._element, "click", () => { this.accessor.doSetGroupActive(this.group) })); const n = new Hf(this._element, e, i); this.dropTraget = new Ct(this._element, { acceptedTargetZones: ["center"], canDisplayOverlay: (r, o) => { var s; const l = Fe(); return l && this.accessor.id === l.viewId ? l.panelId === null && l.groupId === this.group.id ? !1 : ((s = Df(this.group.panels)) === null || s === void 0 ? void 0 : s.id) !== l.panelId : i.model.canDisplayOverlay(r, o, "header_space") } }), this.onWillShowOverlay = this.dropTraget.onWillShowOverlay, this.addDisposables(n, n.onDragStart(r => { this._onDragStart.fire(r) }), this.dropTraget.onDrop(r => { this._onDrop.fire(r) }), this.dropTraget) } } class Bf extends V { get panels() { return this.tabs.map(e => e.value.panel.id) } get size() { return this.tabs.length } get hidden() { return this._hidden } set hidden(e) { this._hidden = e, this.element.style.display = e ? "none" : "" } show() { this.hidden || (this.element.style.display = "") } hide() { this._element.style.display = "none" } setRightActionsElement(e) { this.rightActions !== e && (this.rightActions && (this.rightActions.remove(), this.rightActions = void 0), e && (this.rightActionsContainer.appendChild(e), this.rightActions = e)) } setLeftActionsElement(e) { this.leftActions !== e && (this.leftActions && (this.leftActions.remove(), this.leftActions = void 0), e && (this.leftActionsContainer.appendChild(e), this.leftActions = e)) } setPrefixActionsElement(e) { this.preActions !== e && (this.preActions && (this.preActions.remove(), this.preActions = void 0), e && (this.preActionsContainer.appendChild(e), this.preActions = e)) } get element() { return this._element } isActive(e) { return this.selectedIndex > -1 && this.tabs[this.selectedIndex].value === e } indexOf(e) { return this.tabs.findIndex(i => i.value.panel.id === e) } constructor(e, i) { super(), this.accessor = e, this.group = i, this.tabs = [], this.selectedIndex = -1, this._hidden = !1, this._onDrop = new _, this.onDrop = this._onDrop.event, this._onTabDragStart = new _, this.onTabDragStart = this._onTabDragStart.event, this._onGroupDragStart = new _, this.onGroupDragStart = this._onGroupDragStart.event, this._onWillShowOverlay = new _, this.onWillShowOverlay = this._onWillShowOverlay.event, this._element = document.createElement("div"), this._element.className = "tabs-and-actions-container", G(this._element, "dv-full-width-single-tab", this.accessor.options.singleTabMode === "fullwidth"), this.rightActionsContainer = document.createElement("div"), this.rightActionsContainer.className = "right-actions-container", this.leftActionsContainer = document.createElement("div"), this.leftActionsContainer.className = "left-actions-container", this.preActionsContainer = document.createElement("div"), this.preActionsContainer.className = "pre-actions-container", this.tabContainer = document.createElement("div"), this.tabContainer.className = "tabs-container", this.voidContainer = new Ff(this.accessor, this.group), this._element.appendChild(this.preActionsContainer), this._element.appendChild(this.tabContainer), this._element.appendChild(this.leftActionsContainer), this._element.appendChild(this.voidContainer.element), this._element.appendChild(this.rightActionsContainer), this.addDisposables(this.accessor.onDidAddPanel(n => { n.api.group === this.group && G(this._element, "dv-single-tab", this.size === 1) }), this.accessor.onDidRemovePanel(n => { n.api.group === this.group && G(this._element, "dv-single-tab", this.size === 1) }), this._onWillShowOverlay, this._onDrop, this._onTabDragStart, this._onGroupDragStart, this.voidContainer, this.voidContainer.onDragStart(n => { this._onGroupDragStart.fire({ nativeEvent: n, group: this.group }) }), this.voidContainer.onDrop(n => { this._onDrop.fire({ event: n.nativeEvent, index: this.tabs.length }) }), this.voidContainer.onWillShowOverlay(n => { this._onWillShowOverlay.fire(new $r(n, { kind: "header_space" })) }), $(this.voidContainer.element, "mousedown", n => { if (!this.accessor.options.disableFloatingGroups && n.shiftKey && this.group.api.location.type !== "floating") { n.preventDefault(); const { top: o, left: s } = this.element.getBoundingClientRect(), { top: l, left: a } = this.accessor.element.getBoundingClientRect(); this.accessor.addFloatingGroup(this.group, { x: s - a + 20, y: o - l + 20 }, { inDragMode: !0 }) } }), $(this.tabContainer, "mousedown", n => { if (n.defaultPrevented) return; n.button === 0 && this.accessor.doSetGroupActive(this.group) })) } setActive(e) { } addTab(e, i = this.tabs.length) { if (i < 0 || i > this.tabs.length) throw new Error("invalid location"); this.tabContainer.insertBefore(e.value.element, this.tabContainer.children[i]), this.tabs = [...this.tabs.slice(0, i), e, ...this.tabs.slice(i)], this.selectedIndex < 0 && (this.selectedIndex = i) } delete(e) { const i = this.tabs.findIndex(s => s.value.panel.id === e), n = this.tabs.splice(i, 1)[0], { value: r, disposable: o } = n; o.dispose(), r.dispose(), r.element.remove() } setActivePanel(e) { this.tabs.forEach(i => { const n = e.id === i.value.panel.id; i.value.setActive(n) }) } openPanel(e, i = this.tabs.length) { var n; if (this.tabs.find(l => l.value.panel.id === e.id)) return; const r = new bf(e, this.accessor, this.group); if (!(!((n = e.view) === null || n === void 0) && n.tab)) throw new Error("invalid header component"); r.setContent(e.view.tab); const o = new V(r.onDragStart(l => { this._onTabDragStart.fire({ nativeEvent: l, panel: e }) }), r.onChanged(l => { const a = !this.accessor.options.disableFloatingGroups, u = this.group.api.location.type === "floating" && this.size === 1; if (a && !u && l.shiftKey) { l.preventDefault(); const d = this.accessor.getGroupPanel(r.panel.id), { top: c, left: v } = r.element.getBoundingClientRect(), { top: g, left: w } = this.accessor.element.getBoundingClientRect(); this.accessor.addFloatingGroup(d, { x: v - w, y: c - g }, { inDragMode: !0 }); return } !(l.button === 0) || l.defaultPrevented || this.group.activePanel !== e && this.group.model.openPanel(e) }), r.onDrop(l => { this._onDrop.fire({ event: l.nativeEvent, index: this.tabs.findIndex(a => a.value === r) }) }), r.onWillShowOverlay(l => { this._onWillShowOverlay.fire(new $r(l, { kind: "tab" })) })), s = { value: r, disposable: o }; this.addTab(s, i) } closePanel(e) { this.delete(e.id) } dispose() { super.dispose(); for (const { value: e, disposable: i } of this.tabs) i.dispose(), e.dispose(); this.tabs = [] } } class Tl extends Ol { get nativeEvent() { return this.options.nativeEvent } get position() { return this.options.position } get panel() { return this.options.panel } get group() { return this.options.group } get api() { return this.options.api } constructor(e) { super(), this.options = e } getData() { return this.options.getData() } } class Oh extends Tl { get kind() { return this._kind } constructor(e) { super(e), this._kind = e.kind } } class $r { get kind() { return this._kind } get nativeEvent() { return this.event.nativeEvent } get position() { return this.event.position } get defaultPrevented() { return this.event.defaultPrevented } preventDefault() { this.event.preventDefault() } constructor(e, i) { this.event = e, this._kind = i.kind } } class jf extends V { get element() { throw new Error("not supported") } get activePanel() { return this._activePanel } get locked() { return this._locked } set locked(e) { this._locked = e, G(this.container, "locked-groupview", e === "no-drop-target" || e) } get isActive() { return this._isGroupActive } get panels() { return this._panels } get size() { return this._panels.length } get isEmpty() { return this._panels.length === 0 } get hasWatermark() { return !!(this.watermark && this.container.contains(this.watermark.element)) } get header() { return this.tabsContainer } get isContentFocused() { return document.activeElement ? Ts(document.activeElement, this.contentContainer.element) : !1 } get location() { return this._location } set location(e) { switch (this._location = e, G(this.container, "dv-groupview-floating", !1), G(this.container, "dv-groupview-popout", !1), e.type) { case "grid": this.contentContainer.dropTarget.setTargetZones(["top", "bottom", "left", "right", "center"]); break; case "floating": this.contentContainer.dropTarget.setTargetZones(["center"]), this.contentContainer.dropTarget.setTargetZones(e ? ["center"] : ["top", "bottom", "left", "right", "center"]), G(this.container, "dv-groupview-floating", !0); break; case "popout": this.contentContainer.dropTarget.setTargetZones(["center"]), G(this.container, "dv-groupview-popout", !0); break }this.groupPanel.api._onDidLocationChange.fire({ location: this.location }) } constructor(e, i, n, r, o) { var s; super(), this.container = e, this.accessor = i, this.id = n, this.options = r, this.groupPanel = o, this._isGroupActive = !1, this._locked = !1, this._location = { type: "grid" }, this.mostRecentlyUsed = [], this._onDidChange = new _, this.onDidChange = this._onDidChange.event, this._width = 0, this._height = 0, this._panels = [], this._panelDisposables = new Map, this._onMove = new _, this.onMove = this._onMove.event, this._onDidDrop = new _, this.onDidDrop = this._onDidDrop.event, this._onWillDrop = new _, this.onWillDrop = this._onWillDrop.event, this._onWillShowOverlay = new _, this.onWillShowOverlay = this._onWillShowOverlay.event, this._onTabDragStart = new _, this.onTabDragStart = this._onTabDragStart.event, this._onGroupDragStart = new _, this.onGroupDragStart = this._onGroupDragStart.event, this._onDidAddPanel = new _, this.onDidAddPanel = this._onDidAddPanel.event, this._onDidPanelTitleChange = new _, this.onDidPanelTitleChange = this._onDidPanelTitleChange.event, this._onDidPanelParametersChange = new _, this.onDidPanelParametersChange = this._onDidPanelParametersChange.event, this._onDidRemovePanel = new _, this.onDidRemovePanel = this._onDidRemovePanel.event, this._onDidActivePanelChange = new _, this.onDidActivePanelChange = this._onDidActivePanelChange.event, this._overwriteRenderContainer = null, G(this.container, "groupview", !0), this._api = new Tn(this.accessor), this.tabsContainer = new Bf(this.accessor, this.groupPanel), this.contentContainer = new Vf(this.accessor, this), e.append(this.tabsContainer.element, this.contentContainer.element), this.header.hidden = !!r.hideHeader, this.locked = (s = r.locked) !== null && s !== void 0 ? s : !1, this.addDisposables(this._onTabDragStart, this._onGroupDragStart, this._onWillShowOverlay, this.tabsContainer.onTabDragStart(l => { this._onTabDragStart.fire(l) }), this.tabsContainer.onGroupDragStart(l => { this._onGroupDragStart.fire(l) }), this.tabsContainer.onDrop(l => { this.handleDropEvent("header", l.event, "center", l.index) }), this.contentContainer.onDidFocus(() => { this.accessor.doSetGroupActive(this.groupPanel) }), this.contentContainer.onDidBlur(() => { }), this.contentContainer.dropTarget.onDrop(l => { this.handleDropEvent("content", l.nativeEvent, l.position) }), this.tabsContainer.onWillShowOverlay(l => { this._onWillShowOverlay.fire(l) }), this.contentContainer.dropTarget.onWillShowOverlay(l => { this._onWillShowOverlay.fire(new $r(l, { kind: "content" })) }), this._onMove, this._onDidChange, this._onDidDrop, this._onWillDrop, this._onDidAddPanel, this._onDidRemovePanel, this._onDidActivePanelChange) } focusContent() { this.contentContainer.element.focus() } set renderContainer(e) { this.panels.forEach(i => { this.renderContainer.detatch(i) }), this._overwriteRenderContainer = e, this.panels.forEach(i => { this.rerender(i) }) } get renderContainer() { var e; return (e = this._overwriteRenderContainer) !== null && e !== void 0 ? e : this.accessor.overlayRenderContainer } initialize() { this.options.panels && this.options.panels.forEach(e => { this.doAddPanel(e) }), this.options.activePanel && this.openPanel(this.options.activePanel), this.setActive(this.isActive, !0), this.updateContainer(), this.accessor.options.createRightHeaderActionsElement && (this._rightHeaderActions = this.accessor.options.createRightHeaderActionsElement(this.groupPanel), this.addDisposables(this._rightHeaderActions), this._rightHeaderActions.init({ containerApi: this._api, api: this.groupPanel.api }), this.tabsContainer.setRightActionsElement(this._rightHeaderActions.element)), this.accessor.options.createLeftHeaderActionsElement && (this._leftHeaderActions = this.accessor.options.createLeftHeaderActionsElement(this.groupPanel), this.addDisposables(this._leftHeaderActions), this._leftHeaderActions.init({ containerApi: this._api, api: this.groupPanel.api }), this.tabsContainer.setLeftActionsElement(this._leftHeaderActions.element)), this.accessor.options.createPrefixHeaderActionsElement && (this._prefixHeaderActions = this.accessor.options.createPrefixHeaderActionsElement(this.groupPanel), this.addDisposables(this._prefixHeaderActions), this._prefixHeaderActions.init({ containerApi: this._api, api: this.groupPanel.api }), this.tabsContainer.setPrefixActionsElement(this._prefixHeaderActions.element)) } rerender(e) { this.contentContainer.renderPanel(e, { asActive: !1 }) } indexOf(e) { return this.tabsContainer.indexOf(e.id) } toJSON() { var e; const i = { views: this.tabsContainer.panels, activeView: (e = this._activePanel) === null || e === void 0 ? void 0 : e.id, id: this.id }; return this.locked !== !1 && (i.locked = this.locked), this.header.hidden && (i.hideHeader = !0), i } moveToNext(e) { e || (e = {}), e.panel || (e.panel = this.activePanel); const i = e.panel ? this.panels.indexOf(e.panel) : -1; let n; if (i < this.panels.length - 1) n = i + 1; else if (!e.suppressRoll) n = 0; else return; this.openPanel(this.panels[n]) } moveToPrevious(e) { if (e || (e = {}), e.panel || (e.panel = this.activePanel), !e.panel) return; const i = this.panels.indexOf(e.panel); let n; if (i > 0) n = i - 1; else if (!e.suppressRoll) n = this.panels.length - 1; else return; this.openPanel(this.panels[n]) } containsPanel(e) { return this.panels.includes(e) } init(e) { } update(e) { } focus() { var e; (e = this._activePanel) === null || e === void 0 || e.focus() } openPanel(e, i = {}) { (typeof i.index != "number" || i.index > this.panels.length) && (i.index = this.panels.length); const n = !!i.skipSetActive; if (e.updateParentGroup(this.groupPanel, { skipSetActive: i.skipSetActive }), this.doAddPanel(e, i.index, { skipSetActive: n }), this._activePanel === e) { this.contentContainer.renderPanel(e, { asActive: !0 }); return } n || this.doSetActivePanel(e), i.skipSetGroupActive || this.accessor.doSetGroupActive(this.groupPanel), i.skipSetActive || this.updateContainer() } removePanel(e, i = { skipSetActive: !1 }) { const n = typeof e == "string" ? e : e.id, r = this._panels.find(o => o.id === n); if (!r) throw new Error("invalid operation"); return this._removePanel(r, i) } closeAllPanels() { if (this.panels.length > 0) { const e = [...this.panels]; for (const i of e) this.doClose(i) } else this.accessor.removeGroup(this.groupPanel) } closePanel(e) { this.doClose(e) } doClose(e) { this.accessor.removePanel(e) } isPanelActive(e) { return this._activePanel === e } updateActions(e) { this.tabsContainer.setRightActionsElement(e) } setActive(e, i = !1) { !i && this.isActive === e || (this._isGroupActive = e, G(this.container, "active-group", e), G(this.container, "inactive-group", !e), this.tabsContainer.setActive(this.isActive), !this._activePanel && this.panels.length > 0 && this.doSetActivePanel(this.panels[0]), this.updateContainer()) } layout(e, i) { var n; this._width = e, this._height = i, this.contentContainer.layout(this._width, this._height), !((n = this._activePanel) === null || n === void 0) && n.layout && this._activePanel.layout(this._width, this._height) } _removePanel(e, i) { const n = this._activePanel === e; if (this.doRemovePanel(e), n && this.panels.length > 0) { const r = this.mostRecentlyUsed[0]; this.openPanel(r, { skipSetActive: i.skipSetActive, skipSetGroupActive: i.skipSetActiveGroup }) } return this._activePanel && this.panels.length === 0 && this.doSetActivePanel(void 0), i.skipSetActive || this.updateContainer(), e } doRemovePanel(e) { const i = this.panels.indexOf(e); this._activePanel === e && this.contentContainer.closePanel(), this.tabsContainer.delete(e.id), this._panels.splice(i, 1), this.mostRecentlyUsed.includes(e) && this.mostRecentlyUsed.splice(this.mostRecentlyUsed.indexOf(e), 1); const n = this._panelDisposables.get(e.id); n && (n.dispose(), this._panelDisposables.delete(e.id)), this._onDidRemovePanel.fire({ panel: e }) } doAddPanel(e, i = this.panels.length, n = { skipSetActive: !1 }) { const o = this._panels.indexOf(e) > -1; this.tabsContainer.show(), this.contentContainer.show(), this.tabsContainer.openPanel(e, i), n.skipSetActive || this.contentContainer.openPanel(e), !o && (this.updateMru(e), this.panels.splice(i, 0, e), this._panelDisposables.set(e.id, new V(e.api.onDidTitleChange(s => this._onDidPanelTitleChange.fire(s)), e.api.onDidParametersChange(s => this._onDidPanelParametersChange.fire(s)))), this._onDidAddPanel.fire({ panel: e })) } doSetActivePanel(e) { this._activePanel !== e && (this._activePanel = e, e && (this.tabsContainer.setActivePanel(e), e.layout(this._width, this._height), this.updateMru(e), this._onDidActivePanelChange.fire({ panel: e }))) } updateMru(e) { this.mostRecentlyUsed.includes(e) && this.mostRecentlyUsed.splice(this.mostRecentlyUsed.indexOf(e), 1), this.mostRecentlyUsed = [e, ...this.mostRecentlyUsed] } updateContainer() { var e, i; if (G(this.container, "empty", this.isEmpty), this.panels.forEach(n => n.runEvents()), this.isEmpty && !this.watermark) { const n = this.accessor.createWatermarkComponent(); n.init({ containerApi: this._api, group: this.groupPanel }), this.watermark = n, $(this.watermark.element, "click", () => { this.isActive || this.accessor.doSetGroupActive(this.groupPanel) }), this.tabsContainer.hide(), this.contentContainer.element.appendChild(this.watermark.element), this.watermark.updateParentGroup(this.groupPanel, !0) } !this.isEmpty && this.watermark && (this.watermark.element.remove(), (i = (e = this.watermark).dispose) === null || i === void 0 || i.call(e), this.watermark = void 0, this.tabsContainer.show()) } canDisplayOverlay(e, i, n) { return this.accessor.options.showDndOverlay ? this.accessor.options.showDndOverlay({ nativeEvent: e, target: n, group: this.accessor.getPanel(this.id), position: i, getData: Fe }) : !1 } handleDropEvent(e, i, n, r) { if (this.locked === "no-drop-target") return; function o() { switch (e) { case "header": return typeof r == "number" ? "tab" : "header_space"; case "content": return "content" } } const s = typeof r == "number" ? this.panels[r] : void 0, l = new Oh({ nativeEvent: i, position: n, panel: s, getData: () => Fe(), kind: o(), group: this.groupPanel, api: this._api }); if (this._onWillDrop.fire(l), l.defaultPrevented) return; const a = Fe(); if (a && a.viewId === this.accessor.id) { if (a.panelId === null) { const { groupId: v } = a; this._onMove.fire({ target: n, groupId: v, index: r }); return } if (this.tabsContainer.indexOf(a.panelId) !== -1 && this.tabsContainer.size === 1) return; const { groupId: m, panelId: d } = a; if (this.id === m && !n && this.tabsContainer.indexOf(d) === r) return; this._onMove.fire({ target: n, groupId: a.groupId, itemId: a.panelId, index: r }) } else this._onDidDrop.fire(new Tl({ nativeEvent: i, position: n, panel: s, getData: () => Fe(), group: this.groupPanel, api: this._api })) } dispose() { var e, i, n; super.dispose(), (e = this.watermark) === null || e === void 0 || e.element.remove(), (n = (i = this.watermark) === null || i === void 0 ? void 0 : i.dispose) === null || n === void 0 || n.call(i), this.watermark = void 0; for (const r of this.panels) r.dispose(); this.tabsContainer.dispose(), this.contentContainer.dispose() } } class Gl extends V { get element() { return this._element } get disableResizing() { return this._disableResizing } set disableResizing(e) { this._disableResizing = e } constructor(e, i = !1) { super(), this._disableResizing = i, this._element = e, this.addDisposables(Eh(this._element, n => { if (this.isDisposed || this.disableResizing || !this._element.offsetParent || !yf(this._element)) return; const { width: r, height: o } = n.contentRect; this.layout(r, o) })) } } const Uf = Ll(); function Jr(t) { switch (t) { case "left": return "left"; case "right": return "right"; case "above": return "top"; case "below": return "bottom"; case "within": default: return "center" } } class Lh extends Gl { get id() { return this._id } get size() { return this._groups.size } get groups() { return Array.from(this._groups.values()).map(e => e.value) } get width() { return this.gridview.width } get height() { return this.gridview.height } get minimumHeight() { return this.gridview.minimumHeight } get maximumHeight() { return this.gridview.maximumHeight } get minimumWidth() { return this.gridview.minimumWidth } get maximumWidth() { return this.gridview.maximumWidth } get activeGroup() { return this._activeGroup } get locked() { return this.gridview.locked } set locked(e) { this.gridview.locked = e } constructor(e) { super(document.createElement("div"), e.disableAutoResizing), this._id = Uf.next(), this._groups = new Map, this._onDidLayoutChange = new _, this.onDidLayoutChange = this._onDidLayoutChange.event, this._onDidRemove = new _, this.onDidRemove = this._onDidRemove.event, this._onDidAdd = new _, this.onDidAdd = this._onDidAdd.event, this._onDidActiveChange = new _, this.onDidActiveChange = this._onDidActiveChange.event, this._bufferOnDidLayoutChange = new vf, this.element.style.height = "100%", this.element.style.width = "100%", e.parentElement.appendChild(this.element), this.gridview = new zf(!!e.proportionalLayout, e.styles, e.orientation), this.gridview.locked = !!e.locked, this.element.appendChild(this.gridview.element), this.layout(0, 0, !0), this.addDisposables(Oe.from(() => { var i; (i = this.element.parentElement) === null || i === void 0 || i.removeChild(this.element) }), this.gridview.onDidChange(() => { this._bufferOnDidLayoutChange.fire() }), ni.any(this.onDidAdd, this.onDidRemove, this.onDidActiveChange)(() => { this._bufferOnDidLayoutChange.fire() }), this._bufferOnDidLayoutChange.onEvent(() => { this._onDidLayoutChange.fire() }), this._bufferOnDidLayoutChange) } setVisible(e, i) { this.gridview.setViewVisible(q(e.element), i), this._onDidLayoutChange.fire() } isVisible(e) { return this.gridview.isViewVisible(q(e.element)) } maximizeGroup(e) { this.gridview.maximizeView(e), this.doSetGroupActive(e) } isMaximizedGroup(e) { return this.gridview.maximizedView() === e } exitMaximizedGroup() { this.gridview.exitMaximizedView() } hasMaximizedGroup() { return this.gridview.hasMaximizedView() } get onDidMaximizedGroupChange() { return this.gridview.onDidMaximizedNodeChange } doAddGroup(e, i = [0], n) { this.gridview.addView(e, n ?? Le.Distribute, i), this._onDidAdd.fire(e) } doRemoveGroup(e, i) { if (!this._groups.has(e.id)) throw new Error("invalid operation"); const n = this._groups.get(e.id), r = this.gridview.remove(e, Le.Distribute); if (n && !(i != null && i.skipDispose) && (n.disposable.dispose(), n.value.dispose(), this._groups.delete(e.id), this._onDidRemove.fire(e)), !(i != null && i.skipActive) && this._activeGroup === e) { const o = Array.from(this._groups.values()); this.doSetGroupActive(o.length > 0 ? o[0].value : void 0) } return r } getPanel(e) { var i; return (i = this._groups.get(e)) === null || i === void 0 ? void 0 : i.value } doSetGroupActive(e) { this._activeGroup !== e && (this._activeGroup && this._activeGroup.setActive(!1), e && e.setActive(!0), this._activeGroup = e, this._onDidActiveChange.fire(e)) } removeGroup(e) { this.doRemoveGroup(e) } moveToNext(e) { var i; if (e || (e = {}), !e.group) { if (!this.activeGroup) return; e.group = this.activeGroup } const n = q(e.group.element), r = (i = this.gridview.next(n)) === null || i === void 0 ? void 0 : i.view; this.doSetGroupActive(r) } moveToPrevious(e) { var i; if (e || (e = {}), !e.group) { if (!this.activeGroup) return; e.group = this.activeGroup } const n = q(e.group.element), r = (i = this.gridview.previous(n)) === null || i === void 0 ? void 0 : i.view; this.doSetGroupActive(r) } layout(e, i, n) { (n ?? (e !== this.width || i !== this.height)) && (this.gridview.element.style.height = `${i}px`, this.gridview.element.style.width = `${e}px`, this.gridview.layout(e, i)) } dispose() { this._onDidActiveChange.dispose(), this._onDidAdd.dispose(), this._onDidRemove.dispose(), this._onDidLayoutChange.dispose(); for (const e of this.groups) e.dispose(); this.gridview.dispose(), super.dispose() } } class Rh extends Ol { constructor() { super() } } class Th extends V { get isFocused() { return this._isFocused } get isActive() { return this._isActive } get isVisible() { return this._isVisible } get width() { return this._width } get height() { return this._height } constructor(e, i) { super(), this.id = e, this.component = i, this._isFocused = !1, this._isActive = !1, this._isVisible = !0, this._width = 0, this._height = 0, this._parameters = {}, this.panelUpdatesDisposable = new Qe, this._onDidDimensionChange = new _, this.onDidDimensionsChange = this._onDidDimensionChange.event, this._onDidChangeFocus = new _, this.onDidFocusChange = this._onDidChangeFocus.event, this._onWillFocus = new _, this.onWillFocus = this._onWillFocus.event, this._onDidVisibilityChange = new _, this.onDidVisibilityChange = this._onDidVisibilityChange.event, this._onWillVisibilityChange = new _, this.onWillVisibilityChange = this._onWillVisibilityChange.event, this._onDidActiveChange = new _, this.onDidActiveChange = this._onDidActiveChange.event, this._onActiveChange = new _, this.onActiveChange = this._onActiveChange.event, this._onDidParametersChange = new _, this.onDidParametersChange = this._onDidParametersChange.event, this.addDisposables(this.onDidFocusChange(n => { this._isFocused = n.isFocused }), this.onDidActiveChange(n => { this._isActive = n.isActive }), this.onDidVisibilityChange(n => { this._isVisible = n.isVisible }), this.onDidDimensionsChange(n => { this._width = n.width, this._height = n.height }), this.panelUpdatesDisposable, this._onDidDimensionChange, this._onDidChangeFocus, this._onDidVisibilityChange, this._onDidActiveChange, this._onWillFocus, this._onActiveChange, this._onWillFocus, this._onWillVisibilityChange, this._onDidParametersChange) } getParameters() { return this._parameters } initialize(e) { this.panelUpdatesDisposable.value = this._onDidParametersChange.event(i => { this._parameters = i, e.update({ params: i }) }) } setVisible(e) { this._onWillVisibilityChange.fire({ isVisible: e }) } setActive() { this._onActiveChange.fire() } updateParameters(e) { this._onDidParametersChange.fire(e) } } class Gh extends Th { constructor(e, i) { super(e, i), this._onDidConstraintsChangeInternal = new _, this.onDidConstraintsChangeInternal = this._onDidConstraintsChangeInternal.event, this._onDidConstraintsChange = new _({ replay: !0 }), this.onDidConstraintsChange = this._onDidConstraintsChange.event, this._onDidSizeChange = new _, this.onDidSizeChange = this._onDidSizeChange.event, this.addDisposables(this._onDidConstraintsChangeInternal, this._onDidConstraintsChange, this._onDidSizeChange) } setConstraints(e) { this._onDidConstraintsChangeInternal.fire(e) } setSize(e) { this._onDidSizeChange.fire(e) } } class $f extends Gh { set pane(e) { this._pane = e } constructor(e, i) { super(e, i), this._onDidExpansionChange = new _({ replay: !0 }), this.onDidExpansionChange = this._onDidExpansionChange.event, this._onMouseEnter = new _({}), this.onMouseEnter = this._onMouseEnter.event, this._onMouseLeave = new _({}), this.onMouseLeave = this._onMouseLeave.event, this.addDisposables(this._onDidExpansionChange, this._onMouseEnter, this._onMouseLeave) } setExpanded(e) { var i; (i = this._pane) === null || i === void 0 || i.setExpanded(e) } get isExpanded() { var e; return !!(!((e = this._pane) === null || e === void 0) && e.isExpanded()) } } class Vl extends V { get element() { return this._element } get width() { return this._width } get height() { return this._height } get params() { var e; return (e = this._params) === null || e === void 0 ? void 0 : e.params } constructor(e, i, n) { super(), this.id = e, this.component = i, this.api = n, this._height = 0, this._width = 0, this._element = document.createElement("div"), this._element.tabIndex = -1, this._element.style.outline = "none", this._element.style.height = "100%", this._element.style.width = "100%", this._element.style.overflow = "hidden"; const r = xh(this._element); this.addDisposables(this.api, r.onDidFocus(() => { this.api._onDidChangeFocus.fire({ isFocused: !0 }) }), r.onDidBlur(() => { this.api._onDidChangeFocus.fire({ isFocused: !1 }) }), r) } focus() { const e = new Rh; this.api._onWillFocus.fire(e), !e.defaultPrevented && this._element.focus() } layout(e, i) { this._width = e, this._height = i, this.api._onDidDimensionChange.fire({ width: e, height: i }), this.part && this._params && this.part.update(this._params.params) } init(e) { this._params = e, this.part = this.getComponent() } update(e) { var i, n; this._params = Object.assign(Object.assign({}, this._params), { params: Object.assign(Object.assign({}, (i = this._params) === null || i === void 0 ? void 0 : i.params), e.params) }); for (const r of Object.keys(e.params)) e.params[r] === void 0 && delete this._params.params[r]; (n = this.part) === null || n === void 0 || n.update({ params: this._params.params }) } toJSON() { var e, i; const n = (i = (e = this._params) === null || e === void 0 ? void 0 : e.params) !== null && i !== void 0 ? i : {}; return { id: this.id, component: this.component, params: Object.keys(n).length > 0 ? n : void 0 } } dispose() { var e; this.api.dispose(), (e = this.part) === null || e === void 0 || e.dispose(), super.dispose() } } class Jf extends Vl { set orientation(e) { this._orientation = e } get orientation() { return this._orientation } get minimumSize() { const e = this.headerSize, n = this.isExpanded() ? this._minimumBodySize : 0; return e + n } get maximumSize() { const e = this.headerSize, n = this.isExpanded() ? this._maximumBodySize : 0; return e + n } get size() { return this._size } get orthogonalSize() { return this._orthogonalSize } set orthogonalSize(e) { this._orthogonalSize = e } get minimumBodySize() { return this._minimumBodySize } set minimumBodySize(e) { this._minimumBodySize = typeof e == "number" ? e : 0 } get maximumBodySize() { return this._maximumBodySize } set maximumBodySize(e) { this._maximumBodySize = typeof e == "number" ? e : Number.POSITIVE_INFINITY } get headerVisible() { return this._headerVisible } set headerVisible(e) { this._headerVisible = e, this.header.style.display = e ? "" : "none" } constructor(e, i, n, r, o, s) { super(e, i, new $f(e, i)), this.headerComponent = n, this._onDidChangeExpansionState = new _({ replay: !0 }), this.onDidChangeExpansionState = this._onDidChangeExpansionState.event, this._onDidChange = new _, this.onDidChange = this._onDidChange.event, this.headerSize = 22, this._orthogonalSize = 0, this._size = 0, this._minimumBodySize = 100, this._maximumBodySize = Number.POSITIVE_INFINITY, this._isExpanded = !1, this.expandedSize = 0, this.api.pane = this, this.api.initialize(this), this._isExpanded = o, this._headerVisible = s, this._onDidChangeExpansionState.fire(this.isExpanded()), this._orientation = r, this.element.classList.add("pane"), this.addDisposables(this.api.onWillVisibilityChange(l => { const { isVisible: a } = l, { accessor: u } = this._params; u.setVisible(this, a) }), this.api.onDidSizeChange(l => { this._onDidChange.fire({ size: l.size }) }), $(this.element, "mouseenter", l => { this.api._onMouseEnter.fire(l) }), $(this.element, "mouseleave", l => { this.api._onMouseLeave.fire(l) })), this.addDisposables(this._onDidChangeExpansionState, this.onDidChangeExpansionState(l => { this.api._onDidExpansionChange.fire({ isExpanded: l }) }), this.api.onDidFocusChange(l => { this.header && (l.isFocused ? ho(this.header, "focused") : Ln(this.header, "focused")) })), this.renderOnce() } setVisible(e) { this.api._onDidVisibilityChange.fire({ isVisible: e }) } setActive(e) { this.api._onDidActiveChange.fire({ isActive: e }) } isExpanded() { return this._isExpanded } setExpanded(e) { this._isExpanded !== e && (this._isExpanded = e, e ? (this.animationTimer && clearTimeout(this.animationTimer), this.body && this.element.appendChild(this.body)) : this.animationTimer = setTimeout(() => { var i; (i = this.body) === null || i === void 0 || i.remove() }, 200), this._onDidChange.fire(e ? { size: this.width } : {}), this._onDidChangeExpansionState.fire(e)) } layout(e, i) { this._size = e, this._orthogonalSize = i; const [n, r] = this.orientation === I.HORIZONTAL ? [e, i] : [i, e]; this.isExpanded() && (this.expandedSize = n), super.layout(n, r) } init(e) { var i, n; super.init(e), typeof e.minimumBodySize == "number" && (this.minimumBodySize = e.minimumBodySize), typeof e.maximumBodySize == "number" && (this.maximumBodySize = e.maximumBodySize), this.bodyPart = this.getBodyComponent(), this.headerPart = this.getHeaderComponent(), this.bodyPart.init(Object.assign(Object.assign({}, e), { api: this.api })), this.headerPart.init(Object.assign(Object.assign({}, e), { api: this.api })), (i = this.body) === null || i === void 0 || i.append(this.bodyPart.element), (n = this.header) === null || n === void 0 || n.append(this.headerPart.element), typeof e.isExpanded == "boolean" && this.setExpanded(e.isExpanded) } toJSON() { const e = this._params; return Object.assign(Object.assign({}, super.toJSON()), { headerComponent: this.headerComponent, title: e.title }) } renderOnce() { this.header = document.createElement("div"), this.header.tabIndex = 0, this.header.className = "pane-header", this.header.style.height = `${this.headerSize}px`, this.header.style.lineHeight = `${this.headerSize}px`, this.header.style.minHeight = `${this.headerSize}px`, this.header.style.maxHeight = `${this.headerSize}px`, this.element.appendChild(this.header), this.body = document.createElement("div"), this.body.className = "pane-body", this.element.appendChild(this.body) } getComponent() { return { update: e => { var i, n; (i = this.bodyPart) === null || i === void 0 || i.update({ params: e }), (n = this.headerPart) === null || n === void 0 || n.update({ params: e }) }, dispose: () => { var e, i; (e = this.bodyPart) === null || e === void 0 || e.dispose(), (i = this.headerPart) === null || i === void 0 || i.dispose() } } } } class Qf extends Jf { constructor(e, i, n, r, o, s, l) { super(i, n, r, o, s, !0), this.accessor = e, this._onDidDrop = new _, this.onDidDrop = this._onDidDrop.event, l || this.initDragFeatures() } initDragFeatures() { if (!this.header) return; const e = this.id, i = this.accessor.id; this.header.draggable = !0, this.handler = new class extends Rl { getData() { return ut.getInstance().setData([new mn(i, e)], mn.prototype), { dispose: () => { ut.getInstance().clearData(mn.prototype) } } } }(this.header), this.target = new Ct(this.element, { acceptedTargetZones: ["top", "bottom"], overlayModel: { activationSize: { type: "percentage", value: 50 } }, canDisplayOverlay: n => { const r = qi(); return r && r.paneId !== this.id && r.viewId === this.accessor.id ? !0 : this.accessor.options.showDndOverlay ? this.accessor.options.showDndOverlay({ nativeEvent: n, getData: qi, panel: this }) : !1 } }), this.addDisposables(this._onDidDrop, this.handler, this.target, this.target.onDrop(n => { this.onDrop(n) })) } onDrop(e) { const i = qi(); if (!i || i.viewId !== this.accessor.id) { this._onDidDrop.fire(Object.assign(Object.assign({}, e), { panel: this, api: new Wi(this.accessor), getData: qi })); return } const n = this._params.containerApi, r = i.paneId, o = n.getPanel(r); if (!o) { this._onDidDrop.fire(Object.assign(Object.assign({}, e), { panel: this, getData: qi, api: new Wi(this.accessor) })); return } const s = n.panels, l = s.indexOf(o); let a = n.panels.indexOf(this); (e.position === "left" || e.position === "top") && (a = Math.max(0, a - 1)), (e.position === "right" || e.position === "bottom") && (l > a && a++, a = Math.min(s.length - 1, a)), n.movePanel(l, a) } } class Ml extends Th { constructor(e, i, n) { super(e, i), this._onDidConstraintsChangeInternal = new _, this.onDidConstraintsChangeInternal = this._onDidConstraintsChangeInternal.event, this._onDidConstraintsChange = new _, this.onDidConstraintsChange = this._onDidConstraintsChange.event, this._onDidSizeChange = new _, this.onDidSizeChange = this._onDidSizeChange.event, this.addDisposables(this._onDidConstraintsChangeInternal, this._onDidConstraintsChange, this._onDidSizeChange), n && this.initialize(n) } setConstraints(e) { this._onDidConstraintsChangeInternal.fire(e) } setSize(e) { this._onDidSizeChange.fire(e) } } class Vh extends Vl { get priority() { return this._priority } get snap() { return this._snap } get minimumWidth() { const e = typeof this._minimumWidth == "function" ? this._minimumWidth() : this._minimumWidth; return e !== this._evaluatedMinimumWidth && (this._evaluatedMinimumWidth = e, this.updateConstraints()), e } get minimumHeight() { const e = typeof this._minimumHeight == "function" ? this._minimumHeight() : this._minimumHeight; return e !== this._evaluatedMinimumHeight && (this._evaluatedMinimumHeight = e, this.updateConstraints()), e } get maximumHeight() { const e = typeof this._maximumHeight == "function" ? this._maximumHeight() : this._maximumHeight; return e !== this._evaluatedMaximumHeight && (this._evaluatedMaximumHeight = e, this.updateConstraints()), e } get maximumWidth() { const e = typeof this._maximumWidth == "function" ? this._maximumWidth() : this._maximumWidth; return e !== this._evaluatedMaximumWidth && (this._evaluatedMaximumWidth = e, this.updateConstraints()), e } get isActive() { return this.api.isActive } constructor(e, i, n, r) { super(e, i, r ?? new Ml(e, i)), this._evaluatedMinimumWidth = 0, this._evaluatedMaximumWidth = Number.MAX_SAFE_INTEGER, this._evaluatedMinimumHeight = 0, this._evaluatedMaximumHeight = Number.MAX_SAFE_INTEGER, this._minimumWidth = 0, this._minimumHeight = 0, this._maximumWidth = Number.MAX_SAFE_INTEGER, this._maximumHeight = Number.MAX_SAFE_INTEGER, this._snap = !1, this._onDidChange = new _, this.onDidChange = this._onDidChange.event, typeof (n == null ? void 0 : n.minimumWidth) == "number" && (this._minimumWidth = n.minimumWidth), typeof (n == null ? void 0 : n.maximumWidth) == "number" && (this._maximumWidth = n.maximumWidth), typeof (n == null ? void 0 : n.minimumHeight) == "number" && (this._minimumHeight = n.minimumHeight), typeof (n == null ? void 0 : n.maximumHeight) == "number" && (this._maximumHeight = n.maximumHeight), this.api.initialize(this), this.addDisposables(this.api.onWillVisibilityChange(o => { const { isVisible: s } = o, { accessor: l } = this._params; l.setVisible(this, s) }), this.api.onActiveChange(() => { const { accessor: o } = this._params; o.doSetGroupActive(this) }), this.api.onDidConstraintsChangeInternal(o => { (typeof o.minimumWidth == "number" || typeof o.minimumWidth == "function") && (this._minimumWidth = o.minimumWidth), (typeof o.minimumHeight == "number" || typeof o.minimumHeight == "function") && (this._minimumHeight = o.minimumHeight), (typeof o.maximumWidth == "number" || typeof o.maximumWidth == "function") && (this._maximumWidth = o.maximumWidth), (typeof o.maximumHeight == "number" || typeof o.maximumHeight == "function") && (this._maximumHeight = o.maximumHeight) }), this.api.onDidSizeChange(o => { this._onDidChange.fire({ height: o.height, width: o.width }) }), this._onDidChange) } setVisible(e) { this.api._onDidVisibilityChange.fire({ isVisible: e }) } setActive(e) { this.api._onDidActiveChange.fire({ isActive: e }) } init(e) { e.maximumHeight && (this._maximumHeight = e.maximumHeight), e.minimumHeight && (this._minimumHeight = e.minimumHeight), e.maximumWidth && (this._maximumWidth = e.maximumWidth), e.minimumWidth && (this._minimumWidth = e.minimumWidth), this._priority = e.priority, this._snap = !!e.snap, super.init(e), typeof e.isVisible == "boolean" && this.setVisible(e.isVisible) } updateConstraints() { this.api._onDidConstraintsChange.fire({ minimumWidth: this._evaluatedMinimumWidth, maximumWidth: this._evaluatedMaximumWidth, minimumHeight: this._evaluatedMinimumHeight, maximumHeight: this._evaluatedMaximumHeight }) } toJSON() { const e = super.toJSON(), i = r => r === Number.MAX_SAFE_INTEGER ? void 0 : r, n = r => r <= 0 ? void 0 : r; return Object.assign(Object.assign({}, e), { minimumHeight: n(this.minimumHeight), maximumHeight: i(this.maximumHeight), minimumWidth: n(this.minimumWidth), maximumWidth: i(this.maximumWidth), snap: this.snap, priority: this.priority }) } } const en = "DockviewGroupPanelApiImpl not initialized"; class Zf extends Ml { get location() { if (!this._group) throw new Error(en); return this._group.model.location } constructor(e, i) { super(e, "__dockviewgroup__"), this.accessor = i, this._onDidLocationChange = new _, this.onDidLocationChange = this._onDidLocationChange.event, this.addDisposables(this._onDidLocationChange) } close() { if (this._group) return this.accessor.removeGroup(this._group) } getWindow() { return this.location.type === "popout" ? this.location.getWindow() : window } moveTo(e) { var i, n, r; if (!this._group) throw new Error(en); const o = (i = e.group) !== null && i !== void 0 ? i : this.accessor.addGroup({ direction: If((n = e.position) !== null && n !== void 0 ? n : "right"), skipSetActive: !0 }); this.accessor.moveGroupOrPanel({ from: { groupId: this._group.id }, to: { group: o, position: e.group && (r = e.position) !== null && r !== void 0 ? r : "center" } }) } maximize() { if (!this._group) throw new Error(en); this.location.type === "grid" && this.accessor.maximizeGroup(this._group) } isMaximized() { if (!this._group) throw new Error(en); return this.accessor.isMaximizedGroup(this._group) } exitMaximized() { if (!this._group) throw new Error(en); this.isMaximized() && this.accessor.exitMaximizedGroup() } initialize(e) { this._group = e } } const Yf = 100, Kf = 100; class eu extends Vh { get panels() { return this._model.panels } get activePanel() { return this._model.activePanel } get size() { return this._model.size } get model() { return this._model } get locked() { return this._model.locked } set locked(e) { this._model.locked = e } get header() { return this._model.header } constructor(e, i, n) { super(i, "groupview_default", { minimumHeight: Kf, minimumWidth: Yf }, new Zf(i, e)), this.api.initialize(this), this._model = new jf(this.element, e, i, n, this) } focus() { this.api.isActive || this.api.setActive(), super.focus() } initialize() { this._model.initialize() } setActive(e) { super.setActive(e), this.model.setActive(e) } layout(e, i) { super.layout(e, i), this.model.layout(e, i) } getComponent() { return this._model } toJSON() { return this.model.toJSON() } } function Xf(t) { return !!t.referencePanel } function qf(t) { return !!t.referenceGroup } function em(t) { return !!t.referencePanel } function tm(t) { return !!t.referenceGroup } class im extends Ml { get location() { return this.group.api.location } get title() { return this.panel.title } get isGroupActive() { return this.group.isActive } get renderer() { return this.panel.renderer } set group(e) { const i = this._group; this._group !== e && (this._group = e, this._onDidGroupChange.fire({}), this.setupGroupEventListeners(i), this._onDidLocationChange.fire({ location: this.group.api.location })) } get group() { return this._group } get tabComponent() { return this._tabComponent } constructor(e, i, n, r, o) { super(e.id, r), this.panel = e, this.accessor = n, this._onDidTitleChange = new _, this.onDidTitleChange = this._onDidTitleChange.event, this._onDidActiveGroupChange = new _, this.onDidActiveGroupChange = this._onDidActiveGroupChange.event, this._onDidGroupChange = new _, this.onDidGroupChange = this._onDidGroupChange.event, this._onDidRendererChange = new _, this.onDidRendererChange = this._onDidRendererChange.event, this._onDidLocationChange = new _, this.onDidLocationChange = this._onDidLocationChange.event, this.groupEventsDisposable = new Qe, this._tabComponent = o, this.initialize(e), this._group = i, this.setupGroupEventListeners(), this.addDisposables(this.groupEventsDisposable, this._onDidRendererChange, this._onDidTitleChange, this._onDidGroupChange, this._onDidActiveGroupChange, this._onDidLocationChange) } getWindow() { return this.group.api.getWindow() } moveTo(e) { var i; this.accessor.moveGroupOrPanel({ from: { groupId: this._group.id, panelId: this.panel.id }, to: { group: e.group, position: (i = e.position) !== null && i !== void 0 ? i : "center", index: e.index } }) } setTitle(e) { this.panel.setTitle(e) } setRenderer(e) { this.panel.setRenderer(e) } close() { this.group.model.closePanel(this.panel) } maximize() { this.group.api.maximize() } isMaximized() { return this.group.api.isMaximized() } exitMaximized() { this.group.api.exitMaximized() } setupGroupEventListeners(e) { var i; let n = (i = e == null ? void 0 : e.isActive) !== null && i !== void 0 ? i : !1; this.groupEventsDisposable.value = new V(this.group.api.onDidVisibilityChange(r => { !r.isVisible && this.isVisible ? this._onDidVisibilityChange.fire(r) : r.isVisible && !this.isVisible && this.group.model.isPanelActive(this.panel) && this._onDidVisibilityChange.fire(r) }), this.group.api.onDidLocationChange(r => { this.group === this.panel.group && this._onDidLocationChange.fire(r) }), this.group.api.onDidActiveChange(() => { this.group === this.panel.group && n !== this.isGroupActive && (n = this.isGroupActive, this._onDidActiveGroupChange.fire({ isActive: this.isGroupActive })) })) } } class fi extends V { get params() { return this._params } get title() { return this._title } get group() { return this._group } get renderer() { var e; return (e = this._renderer) !== null && e !== void 0 ? e : this.accessor.renderer } constructor(e, i, n, r, o, s, l, a) { super(), this.id = e, this.accessor = r, this.containerApi = o, this.view = l, this._renderer = a.renderer, this._group = s, this.api = new im(this, this._group, r, i, n), this.addDisposables(this.api.onActiveChange(() => { r.setActivePanel(this) }), this.api.onDidSizeChange(u => { this.group.api.setSize(u) }), this.api.onDidRendererChange(u => { this.group.model.rerender(this) })) } init(e) { this._params = e.params, this.view.init(Object.assign(Object.assign({}, e), { api: this.api, containerApi: this.containerApi })), this.setTitle(e.title) } focus() { const e = new Rh; this.api._onWillFocus.fire(e), !e.defaultPrevented && (this.api.isActive || this.api.setActive()) } toJSON() { return { id: this.id, contentComponent: this.view.contentComponent, tabComponent: this.view.tabComponent, params: Object.keys(this._params || {}).length > 0 ? this._params : void 0, title: this.title, renderer: this._renderer } } setTitle(e) { e !== this.title && (this._title = e, this.view.update({ params: { params: this._params, title: this.title } }), this.api._onDidTitleChange.fire({ title: e })) } setRenderer(e) { e !== this.renderer && (this._renderer = e, this.api._onDidRendererChange.fire({ renderer: e })) } update(e) { var i; this._params = Object.assign(Object.assign({}, (i = this._params) !== null && i !== void 0 ? i : {}), e.params); for (const n of Object.keys(e.params)) e.params[n] === void 0 && delete this._params[n]; this.view.update({ params: { params: this._params, title: this.title } }) } updateParentGroup(e, i) { this._group = e, this.api.group = this._group; const n = this._group.model.isPanelActive(this), r = this.group.api.isActive && n; i != null && i.skipSetActive || this.api.isActive !== r && this.api._onDidActiveChange.fire({ isActive: this.group.api.isActive && n }), this.api.isVisible !== n && this.api._onDidVisibilityChange.fire({ isVisible: n }) } runEvents() { const e = this._group.model.isPanelActive(this), i = this.group.api.isActive && e; this.api.isActive !== i && this.api._onDidActiveChange.fire({ isActive: this.group.api.isActive && e }), this.api.isVisible !== e && this.api._onDidVisibilityChange.fire({ isVisible: e }) } layout(e, i) { this.api._onDidDimensionChange.fire({ width: e, height: i }), this.view.layout(e, i) } dispose() { this.api.dispose(), this.view.dispose() } } const bl = t => { const e = document.createElementNS("http://www.w3.org/2000/svg", "svg"); e.setAttributeNS(null, "height", t.height), e.setAttributeNS(null, "width", t.width), e.setAttributeNS(null, "viewBox", t.viewbox), e.setAttributeNS(null, "aria-hidden", "false"), e.setAttributeNS(null, "focusable", "false"), e.classList.add("dockview-svg"); const i = document.createElementNS("http://www.w3.org/2000/svg", "path"); return i.setAttributeNS(null, "d", t.path), e.appendChild(i), e }, Mh = () => bl({ width: "11", height: "11", viewbox: "0 0 28 28", path: "M2.1 27.3L0 25.2L11.55 13.65L0 2.1L2.1 0L13.65 11.55L25.2 0L27.3 2.1L15.75 13.65L27.3 25.2L25.2 27.3L13.65 15.75L2.1 27.3Z" }), nm = () => bl({ width: "11", height: "11", viewbox: "0 0 24 15", path: "M12 14.15L0 2.15L2.15 0L12 9.9L21.85 0.0499992L24 2.2L12 14.15Z" }), rm = () => bl({ width: "11", height: "11", viewbox: "0 0 15 25", path: "M2.15 24.1L0 21.95L9.9 12.05L0 2.15L2.15 0L14.2 12.05L2.15 24.1Z" }); class Ho extends V { get element() { return this._element } constructor() { super(), this.params = {}, this._element = document.createElement("div"), this._element.className = "dv-default-tab", this._content = document.createElement("div"), this._content.className = "dv-default-tab-content", this.action = document.createElement("div"), this.action.className = "dv-default-tab-action", this.action.appendChild(Mh()), this._element.appendChild(this._content), this._element.appendChild(this.action), this.addDisposables($(this.action, "mousedown", e => { e.preventDefault() })), this.render() } update(e) { this.params = Object.assign(Object.assign({}, this.params), e.params), this.render() } focus() { } init(e) { this.params = e, this._content.textContent = e.title, $(this.action, "click", i => { i.preventDefault(), this.params.api.close() }) } onGroupChange(e) { this.render() } onPanelVisibleChange(e) { this.render() } layout(e, i) { } render() { this._content.textContent !== this.params.title && (this._content.textContent = this.params.title) } } class bh { get content() { return this._content } get tab() { return this._tab } constructor(e, i, n, r) { this.accessor = e, this.id = i, this.contentComponent = n, this.tabComponent = r, this._content = this.createContentComponent(this.id, n), this._tab = this.createTabComponent(this.id, r) } init(e) { this.content.init(Object.assign(Object.assign({}, e), { tab: this.tab })), this.tab.init(e) } updateParentGroup(e, i) { } layout(e, i) { var n, r; (r = (n = this.content).layout) === null || r === void 0 || r.call(n, e, i) } update(e) { var i, n, r, o; (n = (i = this.content).update) === null || n === void 0 || n.call(i, e), (o = (r = this.tab).update) === null || o === void 0 || o.call(r, e) } dispose() { var e, i, n, r; (i = (e = this.content).dispose) === null || i === void 0 || i.call(e), (r = (n = this.tab).dispose) === null || r === void 0 || r.call(n) } createContentComponent(e, i) { var n, r; return je(e, i, (n = this.accessor.options.components) !== null && n !== void 0 ? n : {}, this.accessor.options.frameworkComponents, (r = this.accessor.options.frameworkComponentFactory) === null || r === void 0 ? void 0 : r.content) } createTabComponent(e, i) { var n, r; return i ? je(e, i, this.accessor.options.tabComponents, this.accessor.options.frameworkTabComponents, (n = this.accessor.options.frameworkComponentFactory) === null || n === void 0 ? void 0 : n.tab, () => new Ho) : this.accessor.options.defaultTabComponent ? je(e, this.accessor.options.defaultTabComponent, this.accessor.options.tabComponents, this.accessor.options.frameworkTabComponents, (r = this.accessor.options.frameworkComponentFactory) === null || r === void 0 ? void 0 : r.tab, () => new Ho) : new Ho } } class om { constructor(e) { this.accessor = e } fromJSON(e, i) { var n, r; const o = e.id, s = e.params, l = e.title, a = e.view, u = a ? a.content.id : (n = e.contentComponent) !== null && n !== void 0 ? n : "unknown", m = a ? (r = a.tab) === null || r === void 0 ? void 0 : r.id : e.tabComponent, d = new bh(this.accessor, o, u, m), c = new fi(o, u, m, this.accessor, new Tn(this.accessor), i, d, { renderer: e.renderer }); return c.init({ title: l ?? o, params: s ?? {} }), c } } class sm extends V { get element() { return this._element } constructor() { super(), this._element = document.createElement("div"), this._element.className = "watermark"; const e = document.createElement("div"); e.className = "watermark-title"; const i = document.createElement("span"); i.style.flexGrow = "1"; const n = document.createElement("div"); n.className = "watermark-content", this._element.appendChild(e), this._element.appendChild(n); const r = document.createElement("div"); r.className = "actions-container"; const o = document.createElement("div"); o.className = "close-action", o.appendChild(Mh()), r.appendChild(o), e.appendChild(i), e.appendChild(r), this.addDisposables($(o, "click", s => { var l; s.preventDefault(), this._group && ((l = this._api) === null || l === void 0 || l.removeGroup(this._group)) })) } update(e) { } focus() { } layout(e, i) { } init(e) { this._api = e.containerApi, this.render() } updateParentGroup(e, i) { this._group = e, this.render() } dispose() { super.dispose() } render() { const e = !!(this._api && this._api.size <= 1); G(this.element, "has-actions", e) } } const tu = (() => { let t = null; function e(i) { t !== i && t !== null && G(t, "dv-bring-to-front", !1), G(i, "dv-bring-to-front", !0), t = i } return e })(); class Lt extends V { set minimumInViewportWidth(e) { this.options.minimumInViewportWidth = e } set minimumInViewportHeight(e) { this.options.minimumInViewportHeight = e } constructor(e) { super(), this.options = e, this._element = document.createElement("div"), this._onDidChange = new _, this.onDidChange = this._onDidChange.event, this._onDidChangeEnd = new _, this.onDidChangeEnd = this._onDidChangeEnd.event, this.addDisposables(this._onDidChange, this._onDidChangeEnd), this._element.className = "dv-resize-container", this.setupResize("top"), this.setupResize("bottom"), this.setupResize("left"), this.setupResize("right"), this.setupResize("topleft"), this.setupResize("topright"), this.setupResize("bottomleft"), this.setupResize("bottomright"), this._element.appendChild(this.options.content), this.options.container.appendChild(this._element), this.setBounds({ height: this.options.height, width: this.options.width, top: this.options.top, left: this.options.left }) } setBounds(e = {}) { typeof e.height == "number" && (this._element.style.height = `${e.height}px`), typeof e.width == "number" && (this._element.style.width = `${e.width}px`), typeof e.top == "number" && (this._element.style.top = `${e.top}px`), typeof e.left == "number" && (this._element.style.left = `${e.left}px`); const i = this.options.container.getBoundingClientRect(), n = this._element.getBoundingClientRect(), r = Math.max(0, this.getMinimumWidth(n.width)), o = typeof this.options.minimumInViewportHeight == "number" ? Math.max(0, this.getMinimumHeight(n.height)) : 0, s = ne(n.left - i.left, -r, Math.max(0, i.width - n.width + r)), l = ne(n.top - i.top, -o, Math.max(0, i.height - n.height + o)); this._element.style.left = `${s}px`, this._element.style.top = `${l}px`, this._onDidChange.fire() } toJSON() { const e = this.options.container.getBoundingClientRect(), i = this._element.getBoundingClientRect(); return { top: i.top - e.top, left: i.left - e.left, width: i.width, height: i.height } } setupDrag(e, i = { inDragMode: !1 }) { const n = new Qe, r = () => { let o = null; const s = [...Ot("iframe"), ...Ot("webview")]; for (const l of s) l.style.pointerEvents = "none"; n.value = new V({ dispose: () => { for (const l of s) l.style.pointerEvents = "auto" } }, mt(window, "mousemove", l => { const a = this.options.container.getBoundingClientRect(), u = l.clientX - a.left, m = l.clientY - a.top; G(this._element, "dv-resize-container-dragging", !0); const d = this._element.getBoundingClientRect(); o === null && (o = { x: l.clientX - d.left, y: l.clientY - d.top }); const c = Math.max(0, this.getMinimumWidth(d.width)), v = Math.max(0, this.options.minimumInViewportHeight ? this.getMinimumHeight(d.height) : 0), g = ne(u - o.x, -c, Math.max(0, a.width - d.width + c)), w = ne(m - o.y, -v, Math.max(0, a.height - d.height + v)); this.setBounds({ top: w, left: g }) }), mt(window, "mouseup", () => { G(this._element, "dv-resize-container-dragging", !1), n.dispose(), this._onDidChangeEnd.fire() })) }; this.addDisposables(n, $(e, "mousedown", o => { if (o.defaultPrevented) { o.preventDefault(); return } Za(o) || r() }), $(this.options.content, "mousedown", o => { o.defaultPrevented || Za(o) || o.shiftKey && r() }), $(this.options.content, "mousedown", () => { tu(this._element) }, !0)), tu(this._element), i.inDragMode && r() } setupResize(e) { const i = document.createElement("div"); i.className = `dv-resize-handle-${e}`, this._element.appendChild(i); const n = new Qe; this.addDisposables(n, $(i, "mousedown", r => { r.preventDefault(); let o = null; const s = [...Ot("iframe"), ...Ot("webview")]; for (const l of s) l.style.pointerEvents = "none"; n.value = new V(mt(window, "mousemove", l => { const a = this.options.container.getBoundingClientRect(), u = this._element.getBoundingClientRect(), m = l.clientY - a.top, d = l.clientX - a.left; o === null && (o = { originalY: m, originalHeight: u.height, originalX: d, originalWidth: u.width }); let c, v, g, w; const C = () => { c = ne(m, -Number.MAX_VALUE, o.originalY + o.originalHeight > a.height ? this.getMinimumHeight(a.height) : Math.max(0, o.originalY + o.originalHeight - Lt.MINIMUM_HEIGHT)), v = o.originalY + o.originalHeight - c }, p = () => { c = o.originalY - o.originalHeight, v = ne(m - c, c < 0 && typeof this.options.minimumInViewportHeight == "number" ? -c + this.options.minimumInViewportHeight : Lt.MINIMUM_HEIGHT, Number.MAX_VALUE) }, h = () => { g = ne(d, -Number.MAX_VALUE, o.originalX + o.originalWidth > a.width ? this.getMinimumWidth(a.width) : Math.max(0, o.originalX + o.originalWidth - Lt.MINIMUM_WIDTH)), w = o.originalX + o.originalWidth - g }, f = () => { g = o.originalX - o.originalWidth, w = ne(d - g, g < 0 && typeof this.options.minimumInViewportWidth == "number" ? -g + this.options.minimumInViewportWidth : Lt.MINIMUM_WIDTH, Number.MAX_VALUE) }; switch (e) { case "top": C(); break; case "bottom": p(); break; case "left": h(); break; case "right": f(); break; case "topleft": C(), h(); break; case "topright": C(), f(); break; case "bottomleft": p(), h(); break; case "bottomright": p(), f(); break }this.setBounds({ height: v, width: w, top: c, left: g }) }), { dispose: () => { for (const l of s) l.style.pointerEvents = "auto" } }, mt(window, "mouseup", () => { n.dispose(), this._onDidChangeEnd.fire() })) })) } getMinimumWidth(e) { return typeof this.options.minimumInViewportWidth == "number" ? e - this.options.minimumInViewportWidth : 0 } getMinimumHeight(e) { return typeof this.options.minimumInViewportHeight == "number" ? e - this.options.minimumInViewportHeight : e } dispose() { this._element.remove(), super.dispose() } } Lt.MINIMUM_HEIGHT = 20; Lt.MINIMUM_WIDTH = 20; class lm extends V { constructor(e, i) { super(), this.group = e, this.overlay = i, this.addDisposables(i) } position(e) { this.overlay.setBounds(e) } } const lr = 100, iu = { left: 100, top: 100 }; function am() { const t = document.createElement("div"); return t.tabIndex = -1, t } class nu extends V { constructor(e) { super(), this.element = e, this.map = {}, this._disposed = !1, this.addDisposables(Oe.from(() => { for (const i of Object.values(this.map)) i.disposable.dispose(), i.destroy.dispose(); this._disposed = !0 })) } detatch(e) { if (this.map[e.api.id]) { const { disposable: i, destroy: n } = this.map[e.api.id]; return i.dispose(), n.dispose(), delete this.map[e.api.id], !0 } return !1 } attach(e) { const { panel: i, referenceContainer: n } = e; if (!this.map[i.api.id]) { const a = am(); a.className = "dv-render-overlay", this.map[i.api.id] = { panel: i, disposable: Oe.NONE, destroy: Oe.NONE, element: a } } const r = this.map[i.api.id].element; i.view.content.element.parentElement !== r && r.appendChild(i.view.content.element), r.parentElement !== this.element && this.element.appendChild(r); const o = () => { const a = Ya(n.element), u = Ya(this.element); r.style.left = `${a.left - u.left}px`, r.style.top = `${a.top - u.top}px`, r.style.width = `${a.width}px`, r.style.height = `${a.height}px`, G(r, "dv-render-overlay-float", i.group.api.location.type === "floating") }, s = () => { i.api.isVisible && o(), r.style.display = i.api.isVisible ? "" : "none" }, l = new V(new Nh(r, { onDragEnd: a => { n.dropTarget.dnd.onDragEnd(a) }, onDragEnter: a => { n.dropTarget.dnd.onDragEnter(a) }, onDragLeave: a => { n.dropTarget.dnd.onDragLeave(a) }, onDrop: a => { n.dropTarget.dnd.onDrop(a) }, onDragOver: a => { n.dropTarget.dnd.onDragOver(a) } }), i.api.onDidVisibilityChange(a => { s() }), i.api.onDidDimensionsChange(() => { i.api.isVisible && o() })); return this.map[i.api.id].destroy = Oe.from(() => { var a; i.view.content.element.parentElement === r && r.removeChild(i.view.content.element), (a = r.parentElement) === null || a === void 0 || a.removeChild(r) }), queueMicrotask(() => { this.isDisposed || s() }), this.map[i.api.id].disposable.dispose(), this.map[i.api.id].disposable = l, r } } var um = function (t, e, i, n) { function r(o) { return o instanceof i ? o : new i(function (s) { s(o) }) } return new (i || (i = Promise))(function (o, s) { function l(m) { try { u(n.next(m)) } catch (d) { s(d) } } function a(m) { try { u(n.throw(m)) } catch (d) { s(d) } } function u(m) { m.done ? o(m.value) : r(m.value).then(l, a) } u((n = n.apply(t, e || [])).next()) }) }; class dm extends V { get window() { var e, i; return (i = (e = this._window) === null || e === void 0 ? void 0 : e.value) !== null && i !== void 0 ? i : null } constructor(e, i, n) { super(), this.target = e, this.className = i, this.options = n, this._onWillClose = new _, this.onWillClose = this._onWillClose.event, this._onDidClose = new _, this.onDidClose = this._onDidClose.event, this._window = null, this.addDisposables(this._onWillClose, this._onDidClose, { dispose: () => { this.close() } }) } dimensions() { if (!this._window) return null; const e = this._window.value.screenX, i = this._window.value.screenY, n = this._window.value.innerWidth, r = this._window.value.innerHeight; return { top: i, left: e, width: n, height: r } } close() { var e, i; this._window && (this._onWillClose.fire(), (i = (e = this.options).onWillClose) === null || i === void 0 || i.call(e, { id: this.target, window: this._window.value }), this._window.disposable.dispose(), this._window.value.close(), this._window = null, this._onDidClose.fire()) } open() { var e, i; return um(this, void 0, void 0, function* () { if (this._window) throw new Error("instance of popout window is already open"); const n = `${this.options.url}`, r = Object.entries({ top: this.options.top, left: this.options.left, width: this.options.width, height: this.options.height }).map(([a, u]) => `${a}=${u}`).join(","), o = window.open(n, this.target, r); if (!o) return null; const s = new V; this._window = { value: o, disposable: s }, s.addDisposables(mt(window, "beforeunload", () => { this.close() })); const l = this.createPopoutWindowContainer(); return this.className && l.classList.add(this.className), (i = (e = this.options).onDidOpen) === null || i === void 0 || i.call(e, { id: this.target, window: o }), new Promise(a => { o.addEventListener("unload", u => { }), o.addEventListener("load", () => { const u = o.document; u.title = document.title, u.body.appendChild(l), _f(u, window.document.styleSheets), mt(o, "beforeunload", () => { this.close() }), a(l) }) }) }) } createPopoutWindowContainer() { const e = document.createElement("div"); return e.classList.add("dv-popout-window"), e.id = "dv-popout-window", e.style.position = "absolute", e.style.width = "100%", e.style.height = "100%", e.style.top = "0px", e.style.left = "0px", e } } const hm = { activationSize: { type: "pixels", value: 10 }, size: { type: "pixels", value: 20 } }; function Fo(t) { const e = t.from.activePanel;[...t.from.panels].map(n => { const r = t.from.model.removePanel(n); return t.from.model.renderContainer.detatch(n), r }).forEach(n => { t.to.model.openPanel(n, { skipSetActive: e !== n, skipSetGroupActive: !0 }) }) } function cm(t) { function e(r) { const o = []; for (let s = 0; s < r.classList.length; s++)o.push(r.classList.item(s)); return o } let i, n = t; for (; n !== null && (i = e(n).find(r => r.startsWith("dockview-theme-")), typeof i != "string");)n = n.parentElement; return i } class pm extends Lh { get orientation() { return this.gridview.orientation } get totalPanels() { return this.panels.length } get panels() { return this.groups.flatMap(e => e.panels) } get options() { return this._options } get activePanel() { const e = this.activeGroup; if (e) return e.activePanel } get renderer() { var e; return (e = this.options.defaultRenderer) !== null && e !== void 0 ? e : "onlyWhenVisibile" } constructor(e) { var i, n; super({ proportionalLayout: !0, orientation: (i = e.orientation) !== null && i !== void 0 ? i : I.HORIZONTAL, styles: e.styles, parentElement: e.parentElement, disableAutoResizing: e.disableAutoResizing, locked: e.locked }), this.nextGroupId = Ll(), this._deserializer = new om(this), this.watermark = null, this._onWillDragPanel = new _, this.onWillDragPanel = this._onWillDragPanel.event, this._onWillDragGroup = new _, this.onWillDragGroup = this._onWillDragGroup.event, this._onDidDrop = new _, this.onDidDrop = this._onDidDrop.event, this._onWillDrop = new _, this.onWillDrop = this._onWillDrop.event, this._onWillShowOverlay = new _, this.onWillShowOverlay = this._onWillShowOverlay.event, this._onDidRemovePanel = new _, this.onDidRemovePanel = this._onDidRemovePanel.event, this._onDidAddPanel = new _, this.onDidAddPanel = this._onDidAddPanel.event, this._onDidLayoutFromJSON = new _, this.onDidLayoutFromJSON = this._onDidLayoutFromJSON.event, this._onDidActivePanelChange = new _, this.onDidActivePanelChange = this._onDidActivePanelChange.event, this._onDidMovePanel = new _, this._floatingGroups = [], this._popoutGroups = [], this._ignoreEvents = 0, this._onDidRemoveGroup = new _, this.onDidRemoveGroup = this._onDidRemoveGroup.event, this._onDidAddGroup = new _, this.onDidAddGroup = this._onDidAddGroup.event, this._onDidActiveGroupChange = new _, this.onDidActiveGroupChange = this._onDidActiveGroupChange.event, this._moving = !1; const r = document.createElement("div"); r.className = "dv-overlay-render-container", this.gridview.element.appendChild(r), this.overlayRenderContainer = new nu(r), G(this.gridview.element, "dv-dockview", !0), G(this.element, "dv-debug", !!e.debug), this.addDisposables(this.overlayRenderContainer, this._onWillDragPanel, this._onWillDragGroup, this._onWillShowOverlay, this._onDidActivePanelChange, this._onDidAddPanel, this._onDidRemovePanel, this._onDidLayoutFromJSON, this._onDidDrop, this._onWillDrop, this._onDidMovePanel, this._onDidAddGroup, this._onDidRemoveGroup, this._onDidActiveGroupChange, this.onDidAdd(o => { this._moving || this._onDidAddGroup.fire(o) }), this.onDidRemove(o => { this._moving || this._onDidRemoveGroup.fire(o) }), this.onDidActiveChange(o => { this._moving || this._onDidActiveGroupChange.fire(o) }), ni.any(this.onDidAdd, this.onDidRemove)(() => { this.updateWatermark() }), ni.any(this.onDidAddPanel, this.onDidRemovePanel, this.onDidActivePanelChange)(() => { this._bufferOnDidLayoutChange.fire() }), Oe.from(() => { for (const o of [...this._floatingGroups]) o.dispose(); for (const o of [...this._popoutGroups]) o.disposable.dispose() })), this._options = e, this.options.components || (this.options.components = {}), this.options.frameworkComponents || (this.options.frameworkComponents = {}), this.options.frameworkTabComponents || (this.options.frameworkTabComponents = {}), this.options.tabComponents || (this.options.tabComponents = {}), !this.options.watermarkComponent && !this.options.watermarkFrameworkComponent && (this.options.watermarkComponent = sm), this._rootDropTarget = new Ct(this.element, { canDisplayOverlay: (o, s) => { const l = Fe(); return l ? l.viewId !== this.id ? !1 : s === "center" ? this.gridview.length === 0 : !0 : this.options.showDndOverlay ? s === "center" && this.gridview.length !== 0 ? !1 : this.options.showDndOverlay({ nativeEvent: o, position: s, target: "edge", getData: Fe }) : !1 }, acceptedTargetZones: ["top", "bottom", "left", "right", "center"], overlayModel: (n = this.options.rootOverlayModel) !== null && n !== void 0 ? n : hm }), this.addDisposables(this._rootDropTarget, this._rootDropTarget.onWillShowOverlay(o => { this.gridview.length > 0 && o.position === "center" || this._onWillShowOverlay.fire(new $r(o, { kind: "edge" })) }), this._rootDropTarget.onDrop(o => { var s; const l = new Oh({ nativeEvent: o.nativeEvent, position: o.position, panel: void 0, api: this._api, group: void 0, getData: Fe, kind: "edge" }); if (this._onWillDrop.fire(l), l.defaultPrevented) return; const a = Fe(); a ? this.moveGroupOrPanel({ from: { groupId: a.groupId, panelId: (s = a.panelId) !== null && s !== void 0 ? s : void 0 }, to: { group: this.orthogonalize(o.position), position: "center" } }) : this._onDidDrop.fire(new Tl({ nativeEvent: o.nativeEvent, position: o.position, panel: void 0, api: this._api, group: void 0, getData: Fe })) }), this._rootDropTarget), this._api = new Tn(this), this.updateWatermark() } addPopoutGroup(e, i) { var n, r, o; if (e instanceof fi && e.group.size === 1) return this.addPopoutGroup(e.group); const s = cm(this.gridview.element), l = this.element; function a() { return i != null && i.position ? i.position : e instanceof eu ? e.element.getBoundingClientRect() : e.group ? e.group.element.getBoundingClientRect() : l.getBoundingClientRect() } const u = a(), m = (r = (n = i == null ? void 0 : i.overridePopoutGroup) === null || n === void 0 ? void 0 : n.id) !== null && r !== void 0 ? r : this.getNextGroupId(); e.api.location.type === "grid" && e.api.setVisible(!1); const d = new dm(`${this.id}-${m}`, s ?? "", { url: (o = i == null ? void 0 : i.popoutUrl) !== null && o !== void 0 ? o : "/popout.html", left: window.screenX + u.left, top: window.screenY + u.top, width: u.width, height: u.height, onDidOpen: i == null ? void 0 : i.onDidOpen, onWillClose: i == null ? void 0 : i.onWillClose }), c = new V(d, d.onDidClose(() => { c.dispose() })); return d.open().then(v => { var g; if (d.isDisposed) return; if (v === null) { c.dispose(); return } const w = document.createElement("div"); w.className = "dv-overlay-render-container"; const C = new nu(w), p = e instanceof fi ? e.group : e, h = e.api.location.type, f = (g = i == null ? void 0 : i.overridePopoutGroup) !== null && g !== void 0 ? g : this.createGroup({ id: m }); if (f.model.renderContainer = C, i != null && i.overridePopoutGroup || this._onDidAddGroup.fire(f), e instanceof fi) this.movingLock(() => { const E = p.model.removePanel(e); f.model.openPanel(E) }); else switch (this.movingLock(() => Fo({ from: p, to: f })), h) { case "grid": p.api.setVisible(!1); break; case "floating": case "popout": this.removeGroup(p); break }v.classList.add("dv-dockview"), v.style.overflow = "hidden", v.appendChild(w), v.appendChild(f.element), f.model.location = { type: "popout", getWindow: () => d.window }, this.doSetGroupAndPanelActive(f), c.addDisposables(f.api.onDidActiveChange(E => { var x; E.isActive && ((x = d.window) === null || x === void 0 || x.focus()) }), f.api.onWillFocus(() => { var E; (E = d.window) === null || E === void 0 || E.focus() })); let y; const S = { window: d, popoutGroup: f, referenceGroup: this.getPanel(p.id) ? p.id : void 0, disposable: { dispose: () => (c.dispose(), y) } }; c.addDisposables(mt(d.window, "resize", () => { f.layout(window.innerWidth, window.innerHeight) }), C, Oe.from(() => { if (this.getPanel(p.id)) this.movingLock(() => Fo({ from: f, to: p })), p.api.isVisible || p.api.setVisible(!0), this.getPanel(f.id) && this.doRemoveGroup(f, { skipPopoutAssociated: !0 }); else if (this.getPanel(f.id)) { const E = this.doRemoveGroup(f, { skipDispose: !0, skipActive: !0 }); E.model.renderContainer = this.overlayRenderContainer, E.model.location = { type: "grid" }, y = E } })), this._popoutGroups.push(S), this.updateWatermark() }).catch(v => { console.error(v) }) } addFloatingGroup(e, i, n) { var r, o, s, l, a, u, m; let d; if (e instanceof fi) d = this.createGroup(), this._onDidAddGroup.fire(d), this.movingLock(() => this.removePanel(e, { removeEmptyGroup: !0, skipDispose: !0, skipSetActiveGroup: !0 })), d.model.openPanel(e, { skipSetGroupActive: !0 }); else { d = e; const h = (r = this._popoutGroups.find(S => S.popoutGroup === d)) === null || r === void 0 ? void 0 : r.referenceGroup, f = h ? this.getPanel(h) : void 0; typeof (n == null ? void 0 : n.skipRemoveGroup) == "boolean" && n.skipRemoveGroup || (f ? (this.movingLock(() => Fo({ from: e, to: f })), this.doRemoveGroup(e, { skipPopoutReturn: !0, skipPopoutAssociated: !0 }), this.doRemoveGroup(f, { skipDispose: !0 }), d = f) : this.doRemoveGroup(e, { skipDispose: !0, skipPopoutReturn: !0, skipPopoutAssociated: !!f })) } d.model.location = { type: "floating" }; const c = typeof (i == null ? void 0 : i.x) == "number" ? Math.max(i.x, 0) : iu.left, v = typeof (i == null ? void 0 : i.y) == "number" ? Math.max(i.y, 0) : iu.top, g = new Lt({ container: this.gridview.element, content: d.element, height: (o = i == null ? void 0 : i.height) !== null && o !== void 0 ? o : 300, width: (s = i == null ? void 0 : i.width) !== null && s !== void 0 ? s : 300, left: c, top: v, minimumInViewportWidth: this.options.floatingGroupBounds === "boundedWithinViewport" ? void 0 : (a = (l = this.options.floatingGroupBounds) === null || l === void 0 ? void 0 : l.minimumWidthWithinViewport) !== null && a !== void 0 ? a : lr, minimumInViewportHeight: this.options.floatingGroupBounds === "boundedWithinViewport" ? void 0 : (m = (u = this.options.floatingGroupBounds) === null || u === void 0 ? void 0 : u.minimumHeightWithinViewport) !== null && m !== void 0 ? m : lr }), w = d.element.querySelector(".void-container"); if (!w) throw new Error("failed to find drag handle"); g.setupDrag(w, { inDragMode: typeof (n == null ? void 0 : n.inDragMode) == "boolean" ? n.inDragMode : !1 }); const C = new lm(d, g), p = Eh(d.element, h => { const { width: f, height: y } = h.contentRect; d.layout(f, y) }); C.addDisposables(g.onDidChange(() => { d.layout(d.height, d.width) }), g.onDidChangeEnd(() => { this._bufferOnDidLayoutChange.fire() }), d.onDidChange(h => { g.setBounds({ height: h == null ? void 0 : h.height, width: h == null ? void 0 : h.width }) }), { dispose: () => { p.dispose(), d.model.location = { type: "grid" }, Ka(this._floatingGroups, C), this.updateWatermark() } }), this._floatingGroups.push(C), n != null && n.skipActiveGroup || this.doSetGroupAndPanelActive(d), this.updateWatermark() } orthogonalize(e) { switch (e) { case "top": case "bottom": this.gridview.orientation === I.HORIZONTAL && this.gridview.insertOrthogonalSplitviewAtRoot(); break; case "left": case "right": this.gridview.orientation === I.VERTICAL && this.gridview.insertOrthogonalSplitviewAtRoot(); break }switch (e) { case "top": case "left": case "center": return this.createGroupAtLocation([0]); case "bottom": case "right": return this.createGroupAtLocation([this.gridview.length]); default: throw new Error(`unsupported position ${e}`) } } updateOptions(e) { var i, n; const r = typeof e.orientation == "string" && this.gridview.orientation !== e.orientation, o = e.floatingGroupBounds !== void 0 && e.floatingGroupBounds !== this.options.floatingGroupBounds, s = e.rootOverlayModel !== void 0 && e.rootOverlayModel !== this.options.rootOverlayModel; if (this._options = Object.assign(Object.assign({}, this.options), e), r && (this.gridview.orientation = e.orientation), o) for (const l of this._floatingGroups) { switch (this.options.floatingGroupBounds) { case "boundedWithinViewport": l.overlay.minimumInViewportHeight = void 0, l.overlay.minimumInViewportWidth = void 0; break; case void 0: l.overlay.minimumInViewportHeight = lr, l.overlay.minimumInViewportWidth = lr; break; default: l.overlay.minimumInViewportHeight = (i = this.options.floatingGroupBounds) === null || i === void 0 ? void 0 : i.minimumHeightWithinViewport, l.overlay.minimumInViewportWidth = (n = this.options.floatingGroupBounds) === null || n === void 0 ? void 0 : n.minimumWidthWithinViewport }l.overlay.setBounds({}) } s && this._rootDropTarget.setOverlayModel(e.rootOverlayModel), this.layout(this.gridview.width, this.gridview.height, !0) } layout(e, i, n) { if (super.layout(e, i, n), this._floatingGroups) for (const r of this._floatingGroups) r.overlay.setBounds() } focus() { var e; (e = this.activeGroup) === null || e === void 0 || e.focus() } getGroupPanel(e) { return this.panels.find(i => i.id === e) } setActivePanel(e) { e.group.model.openPanel(e), this.doSetGroupAndPanelActive(e.group) } moveToNext(e = {}) { var i; if (!e.group) { if (!this.activeGroup) return; e.group = this.activeGroup } if (e.includePanel && e.group && e.group.activePanel !== e.group.panels[e.group.panels.length - 1]) { e.group.model.moveToNext({ suppressRoll: !0 }); return } const n = q(e.group.element), r = (i = this.gridview.next(n)) === null || i === void 0 ? void 0 : i.view; this.doSetGroupAndPanelActive(r) } moveToPrevious(e = {}) { var i; if (!e.group) { if (!this.activeGroup) return; e.group = this.activeGroup } if (e.includePanel && e.group && e.group.activePanel !== e.group.panels[0]) { e.group.model.moveToPrevious({ suppressRoll: !0 }); return } const n = q(e.group.element), r = (i = this.gridview.previous(n)) === null || i === void 0 ? void 0 : i.view; r && this.doSetGroupAndPanelActive(r) } toJSON() { var e; const i = this.gridview.serialize(), n = this.panels.reduce((l, a) => (l[a.id] = a.toJSON(), l), {}), r = this._floatingGroups.map(l => ({ data: l.group.toJSON(), position: l.overlay.toJSON() })), o = this._popoutGroups.map(l => ({ data: l.popoutGroup.toJSON(), gridReferenceGroup: l.referenceGroup, position: l.window.dimensions() })), s = { grid: i, panels: n, activeGroup: (e = this.activeGroup) === null || e === void 0 ? void 0 : e.id }; return r.length > 0 && (s.floatingGroups = r), o.length > 0 && (s.popoutGroups = o), s } fromJSON(e) { var i, n, r; if (this.clear(), typeof e != "object" || e === null) throw new Error("serialized layout must be a non-null object"); const { grid: o, panels: s, activeGroup: l } = e; if (o.root.type !== "branch" || !Array.isArray(o.root.data)) throw new Error("root must be of type branch"); try { const a = this.width, u = this.height, m = v => { const { id: g, locked: w, hideHeader: C, views: p, activeView: h } = v; if (typeof g != "string") throw new Error("group id must be of type string"); const f = this.createGroup({ id: g, locked: !!w, hideHeader: !!C }), y = []; for (const S of p) { const E = this._deserializer.fromJSON(s[S], f); y.push(E) } this._onDidAddGroup.fire(f); for (let S = 0; S < p.length; S++) { const E = y[S], x = typeof h == "string" && h === E.id; f.model.openPanel(E, { skipSetActive: !x, skipSetGroupActive: !0 }) } return !f.activePanel && f.panels.length > 0 && f.model.openPanel(f.panels[f.panels.length - 1], { skipSetGroupActive: !0 }), f }; this.gridview.deserialize(o, { fromJSON: v => m(v.data) }), this.layout(a, u, !0); const d = (i = e.floatingGroups) !== null && i !== void 0 ? i : []; for (const v of d) { const { data: g, position: w } = v, C = m(g); this.addFloatingGroup(C, { x: w.left, y: w.top, height: w.height, width: w.width }, { skipRemoveGroup: !0, inDragMode: !1 }) } const c = (n = e.popoutGroups) !== null && n !== void 0 ? n : []; for (const v of c) { const { data: g, position: w, gridReferenceGroup: C } = v, p = m(g); this.addPopoutGroup((r = C ? this.getPanel(C) : void 0) !== null && r !== void 0 ? r : p, { skipRemoveGroup: !0, position: w ?? void 0, overridePopoutGroup: C ? p : void 0 }) } for (const v of this._floatingGroups) v.overlay.setBounds(); if (typeof l == "string") { const v = this.getPanel(l); v && this.doSetGroupAndPanelActive(v) } } catch (a) { for (const u of this.groups) for (const m of u.panels) this.removePanel(m, { removeEmptyGroup: !1, skipDispose: !1 }); for (const u of this.groups) u.dispose(), this._groups.delete(u.id), this._onDidRemoveGroup.fire(u); for (const u of [...this._floatingGroups]) u.dispose(); throw this.clear(), a } this.updateWatermark(), this._onDidLayoutFromJSON.fire() } clear() { const e = Array.from(this._groups.values()).map(n => n.value), i = !!this.activeGroup; this.activePanel; for (const n of e) this.removeGroup(n, { skipActive: !0 }); i && this.doSetGroupAndPanelActive(void 0), this.gridview.clear() } closeAllGroups() { for (const e of this._groups.entries()) { const [i, n] = e; n.value.model.closeAllPanels() } } addPanel(e) { var i, n; if (this.panels.find(s => s.id === e.id)) throw new Error(`panel with id ${e.id} already exists`); let r; if (e.position && e.floating) throw new Error("you can only provide one of: position, floating as arguments to .addPanel(...)"); if (e.position) if (Xf(e.position)) { const s = typeof e.position.referencePanel == "string" ? this.getGroupPanel(e.position.referencePanel) : e.position.referencePanel; if (!s) throw new Error(`referencePanel ${e.position.referencePanel} does not exist`); r = this.findGroup(s) } else if (qf(e.position)) { if (r = typeof e.position.referenceGroup == "string" ? (i = this._groups.get(e.position.referenceGroup)) === null || i === void 0 ? void 0 : i.value : e.position.referenceGroup, !r) throw new Error(`referencePanel ${e.position.referenceGroup} does not exist`) } else { const s = this.orthogonalize(qa(e.position.direction)), l = this.createPanel(e, s); return s.model.openPanel(l), this.doSetGroupAndPanelActive(s), l } else r = this.activeGroup; let o; if (r) { const s = Jr(((n = e.position) === null || n === void 0 ? void 0 : n.direction) || "within"); if (e.floating) { const l = this.createGroup(); this._onDidAddGroup.fire(l); const a = typeof e.floating == "object" && e.floating !== null ? e.floating : {}; this.addFloatingGroup(l, a, { inDragMode: !1, skipRemoveGroup: !0, skipActiveGroup: !0 }), o = this.createPanel(e, l), l.model.openPanel(o) } else if (r.api.location.type === "floating" || s === "center") o = this.createPanel(e, r), r.model.openPanel(o), this.doSetGroupAndPanelActive(r); else { const l = q(r.element), a = ot(this.gridview.orientation, l, s), u = this.createGroupAtLocation(a); o = this.createPanel(e, u), u.model.openPanel(o), this.doSetGroupAndPanelActive(u) } } else if (e.floating) { const s = this.createGroup(); this._onDidAddGroup.fire(s); const l = typeof e.floating == "object" && e.floating !== null ? e.floating : {}; this.addFloatingGroup(s, l, { inDragMode: !1, skipRemoveGroup: !0, skipActiveGroup: !0 }), o = this.createPanel(e, s), s.model.openPanel(o) } else { const s = this.createGroupAtLocation(); o = this.createPanel(e, s), s.model.openPanel(o), this.doSetGroupAndPanelActive(s) } return o } removePanel(e, i = { removeEmptyGroup: !0, skipDispose: !1 }) { const n = e.group; if (!n) throw new Error(`cannot remove panel ${e.id}. it's missing a group.`); n.model.removePanel(e, { skipSetActiveGroup: i.skipSetActiveGroup }), i.skipDispose || (e.group.model.renderContainer.detatch(e), e.dispose()), n.size === 0 && i.removeEmptyGroup && this.removeGroup(n, { skipActive: i.skipSetActiveGroup }) } createWatermarkComponent() { var e; return je("watermark-id", "watermark-name", this.options.watermarkComponent ? { "watermark-name": this.options.watermarkComponent } : {}, this.options.watermarkFrameworkComponent ? { "watermark-name": this.options.watermarkFrameworkComponent } : {}, (e = this.options.frameworkComponentFactory) === null || e === void 0 ? void 0 : e.watermark) } updateWatermark() { var e, i; if (this.groups.filter(n => n.api.location.type === "grid" && n.api.isVisible).length === 0) { if (!this.watermark) { this.watermark = this.createWatermarkComponent(), this.watermark.init({ containerApi: new Tn(this) }); const n = document.createElement("div"); n.className = "dv-watermark-container", n.appendChild(this.watermark.element), this.gridview.element.appendChild(n) } } else this.watermark && (this.watermark.element.parentElement.remove(), (i = (e = this.watermark).dispose) === null || i === void 0 || i.call(e), this.watermark = null) } addGroup(e) { var i; const n = this.createGroup(e); if (e) { let r; if (em(e)) { const a = typeof e.referencePanel == "string" ? this.panels.find(u => u.id === e.referencePanel) : e.referencePanel; if (!a) throw new Error(`reference panel ${e.referencePanel} does not exist`); if (r = this.findGroup(a), !r) throw new Error(`reference group for reference panel ${e.referencePanel} does not exist`) } else if (tm(e)) { if (r = typeof e.referenceGroup == "string" ? (i = this._groups.get(e.referenceGroup)) === null || i === void 0 ? void 0 : i.value : e.referenceGroup, !r) throw new Error(`reference group ${e.referenceGroup} does not exist`) } else { const a = this.orthogonalize(qa(e.direction)); return e.skipSetActive || this.doSetGroupAndPanelActive(a), a } const o = Jr(e.direction || "within"), s = q(r.element), l = ot(this.gridview.orientation, s, o); return this.doAddGroup(n, l), e.skipSetActive || this.doSetGroupAndPanelActive(n), n } else return this.doAddGroup(n), this.doSetGroupAndPanelActive(n), n } removeGroup(e, i) { this.doRemoveGroup(e, i) } doRemoveGroup(e, i) { var n; const r = [...e.panels]; if (!(i != null && i.skipDispose)) for (const l of r) this.removePanel(l, { removeEmptyGroup: !1, skipDispose: (n = i == null ? void 0 : i.skipDispose) !== null && n !== void 0 ? n : !1 }); const o = this.activePanel; if (e.api.location.type === "floating") { const l = this._floatingGroups.find(a => a.group === e); if (l) { if (i != null && i.skipDispose || (l.group.dispose(), this._groups.delete(e.id), this._onDidRemoveGroup.fire(e)), Ka(this._floatingGroups, l), l.dispose(), !(i != null && i.skipActive) && this._activeGroup === e) { const a = Array.from(this._groups.values()); this.doSetGroupAndPanelActive(a.length > 0 ? a[0].value : void 0) } return l.group } throw new Error("failed to find floating group") } if (e.api.location.type === "popout") { const l = this._popoutGroups.find(a => a.popoutGroup === e); if (l) { if (!(i != null && i.skipDispose)) { if (!(i != null && i.skipPopoutAssociated)) { const u = l.referenceGroup ? this.getPanel(l.referenceGroup) : void 0; u && this.removeGroup(u) } l.popoutGroup.dispose(), this._groups.delete(e.id), this._onDidRemoveGroup.fire(e) } const a = l.disposable.dispose(); if (!(i != null && i.skipPopoutReturn) && a && (this.doAddGroup(a, [0]), this.doSetGroupAndPanelActive(a)), !(i != null && i.skipActive) && this._activeGroup === e) { const u = Array.from(this._groups.values()); this.doSetGroupAndPanelActive(u.length > 0 ? u[0].value : void 0) } return this.updateWatermark(), l.popoutGroup } throw new Error("failed to find popout group") } const s = super.doRemoveGroup(e, i); return i != null && i.skipActive || this.activePanel !== o && this._onDidActivePanelChange.fire(this.activePanel), s } movingLock(e) { const i = this._moving; try { return this._moving = !0, e() } finally { this._moving = i } } moveGroupOrPanel(e) { var i; const n = e.to.group, r = e.from.groupId, o = e.from.panelId, s = e.to.position, l = e.to.index, a = r ? (i = this._groups.get(r)) === null || i === void 0 ? void 0 : i.value : void 0; if (!a) throw new Error(`Failed to find group id ${r}`); if (o === void 0) { this.moveGroup({ from: { group: a }, to: { group: n, position: s } }); return } if (!s || s === "center") { const u = this.movingLock(() => a.model.removePanel(o, { skipSetActive: !1, skipSetActiveGroup: !0 })); if (!u) throw new Error(`No panel with id ${o}`); a.model.size === 0 && this.doRemoveGroup(a, { skipActive: !0 }), this.movingLock(() => n.model.openPanel(u, { index: l, skipSetGroupActive: !0 })), this.doSetGroupAndPanelActive(n), this._onDidMovePanel.fire({ panel: u }) } else { const u = q(n.element), m = ot(this.gridview.orientation, u, s); if (a.size < 2) { const [d, c] = vt(m); if (a.api.location.type === "grid") { const C = q(a.element), [p, h] = vt(C); if (Ph(p, d)) { this.gridview.moveView(p, h, c); return } } const v = this.movingLock(() => this.doRemoveGroup(a, { skipActive: !0, skipDispose: !0 })), g = q(n.element), w = ot(this.gridview.orientation, g, s); this.movingLock(() => this.doAddGroup(v, w)), this.doSetGroupAndPanelActive(v) } else { const d = this.movingLock(() => a.model.removePanel(o, { skipSetActive: !1, skipSetActiveGroup: !0 })); if (!d) throw new Error(`No panel with id ${o}`); const c = ot(this.gridview.orientation, u, s), v = this.createGroupAtLocation(c); this.movingLock(() => v.model.openPanel(d, { skipSetGroupActive: !0 })), this.doSetGroupAndPanelActive(v) } } } moveGroup(e) { const i = e.from.group, n = e.to.group, r = e.to.position; if (r === "center") { const o = i.activePanel, s = this.movingLock(() => [...i.panels].map(l => i.model.removePanel(l.id, { skipSetActive: !0 }))); (i == null ? void 0 : i.model.size) === 0 && this.doRemoveGroup(i, { skipActive: !0 }), this.movingLock(() => { for (const l of s) n.model.openPanel(l, { skipSetActive: l !== o, skipSetGroupActive: !0 }) }), this.doSetGroupAndPanelActive(n), s.forEach(l => { this._onDidMovePanel.fire({ panel: l }) }) } else { switch (i.api.location.type) { case "grid": this.gridview.removeView(q(i.element)); break; case "floating": { const l = this._floatingGroups.find(a => a.group === i); if (!l) throw new Error("failed to find floating group"); l.dispose(); break } case "popout": { const l = this._popoutGroups.find(a => a.popoutGroup === i); if (!l) throw new Error("failed to find popout group"); l.disposable.dispose() } }const o = q(n.element), s = ot(this.gridview.orientation, o, r); this.gridview.addView(i, Le.Distribute, s), i.panels.forEach(l => { this._onDidMovePanel.fire({ panel: l }) }) } } doSetGroupActive(e) { super.doSetGroupActive(e); const i = this.activePanel; !this._moving && i !== this._onDidActivePanelChange.value && this._onDidActivePanelChange.fire(i) } doSetGroupAndPanelActive(e) { super.doSetGroupActive(e); const i = this.activePanel; e && this.hasMaximizedGroup() && !this.isMaximizedGroup(e) && this.exitMaximizedGroup(), !this._moving && i !== this._onDidActivePanelChange.value && this._onDidActivePanelChange.fire(i) } getNextGroupId() { let e = this.nextGroupId.next(); for (; this._groups.has(e);)e = this.nextGroupId.next(); return e } createGroup(e) { e || (e = {}); let i = e == null ? void 0 : e.id; if (i && this._groups.has(e.id) && (console.warn(`Duplicate group id ${e == null ? void 0 : e.id}. reassigning group id to avoid errors`), i = void 0), !i) for (i = this.nextGroupId.next(); this._groups.has(i);)i = this.nextGroupId.next(); const n = new eu(this, i, e); if (n.init({ params: {}, accessor: this }), !this._groups.has(n.id)) { const r = new V(n.model.onTabDragStart(o => { this._onWillDragPanel.fire(o) }), n.model.onGroupDragStart(o => { this._onWillDragGroup.fire(o) }), n.model.onMove(o => { const { groupId: s, itemId: l, target: a, index: u } = o; this.moveGroupOrPanel({ from: { groupId: s, panelId: l }, to: { group: n, position: a, index: u } }) }), n.model.onDidDrop(o => { this._onDidDrop.fire(o) }), n.model.onWillDrop(o => { this._onWillDrop.fire(o) }), n.model.onWillShowOverlay(o => { if (this.options.disableDnd) { o.preventDefault(); return } this._onWillShowOverlay.fire(o) }), n.model.onDidAddPanel(o => { this._moving || this._onDidAddPanel.fire(o.panel) }), n.model.onDidRemovePanel(o => { this._moving || this._onDidRemovePanel.fire(o.panel) }), n.model.onDidActivePanelChange(o => { this._moving || o.panel === this.activePanel && this._onDidActivePanelChange.value !== o.panel && this._onDidActivePanelChange.fire(o.panel) }), ni.any(n.model.onDidPanelTitleChange, n.model.onDidPanelParametersChange)(() => { this._bufferOnDidLayoutChange.fire() })); this._groups.set(n.id, { value: n, disposable: r }) } return n.initialize(), n } createPanel(e, i) { var n, r, o; const s = e.component, l = (n = e.tabComponent) !== null && n !== void 0 ? n : this.options.defaultTabComponent, a = new bh(this, e.id, s, l), u = new fi(e.id, s, l, this, this._api, i, a, { renderer: e.renderer }); return u.init({ title: (r = e.title) !== null && r !== void 0 ? r : e.id, params: (o = e == null ? void 0 : e.params) !== null && o !== void 0 ? o : {} }), u } createGroupAtLocation(e = [0]) { const i = this.createGroup(); return this.doAddGroup(i, e), i } findGroup(e) { var i; return (i = Array.from(this._groups.values()).find(n => n.value.model.containsPanel(e))) === null || i === void 0 ? void 0 : i.value } } class fm extends Lh { get orientation() { return this.gridview.orientation } set orientation(e) { this.gridview.orientation = e } get options() { return this._options } get deserializer() { return this._deserializer } set deserializer(e) { this._deserializer = e } constructor(e) { super({ parentElement: e.parentElement, proportionalLayout: e.proportionalLayout, orientation: e.orientation, styles: e.styles, disableAutoResizing: e.disableAutoResizing }), this._onDidLayoutfromJSON = new _, this.onDidLayoutFromJSON = this._onDidLayoutfromJSON.event, this._onDidRemoveGroup = new _, this.onDidRemoveGroup = this._onDidRemoveGroup.event, this._onDidAddGroup = new _, this.onDidAddGroup = this._onDidAddGroup.event, this._onDidActiveGroupChange = new _, this.onDidActiveGroupChange = this._onDidActiveGroupChange.event, this._options = e, this.addDisposables(this._onDidAddGroup, this._onDidRemoveGroup, this._onDidActiveGroupChange, this.onDidAdd(i => { this._onDidAddGroup.fire(i) }), this.onDidRemove(i => { this._onDidRemoveGroup.fire(i) }), this.onDidActiveChange(i => { this._onDidActiveGroupChange.fire(i) })), this.options.components || (this.options.components = {}), this.options.frameworkComponents || (this.options.frameworkComponents = {}) } updateOptions(e) { const i = typeof e.orientation == "string" && this.gridview.orientation !== e.orientation; this._options = Object.assign(Object.assign({}, this.options), e), i && (this.gridview.orientation = e.orientation), this.layout(this.gridview.width, this.gridview.height, !0) } removePanel(e) { this.removeGroup(e) } toJSON() { var e; return { grid: this.gridview.serialize(), activePanel: (e = this.activeGroup) === null || e === void 0 ? void 0 : e.id } } setVisible(e, i) { this.gridview.setViewVisible(q(e.element), i) } setActive(e) { this._groups.forEach((i, n) => { i.value.setActive(e === i.value) }) } focus() { var e; (e = this.activeGroup) === null || e === void 0 || e.focus() } fromJSON(e) { this.clear(); const { grid: i, activePanel: n } = e; try { const r = [], o = this.width, s = this.height; if (this.gridview.deserialize(i, { fromJSON: l => { var a, u; const { data: m } = l, d = je(m.id, m.component, (a = this.options.components) !== null && a !== void 0 ? a : {}, (u = this.options.frameworkComponents) !== null && u !== void 0 ? u : {}, this.options.frameworkComponentFactory ? { createComponent: this.options.frameworkComponentFactory.createComponent } : void 0); return r.push(() => d.init({ params: m.params, minimumWidth: m.minimumWidth, maximumWidth: m.maximumWidth, minimumHeight: m.minimumHeight, maximumHeight: m.maximumHeight, priority: m.priority, snap: !!m.snap, accessor: this, isVisible: l.visible })), this._onDidAddGroup.fire(d), this.registerPanel(d), d } }), this.layout(o, s, !0), r.forEach(l => l()), typeof n == "string") { const l = this.getPanel(n); l && this.doSetGroupActive(l) } } catch (r) { for (const o of this.groups) o.dispose(), this._groups.delete(o.id), this._onDidRemoveGroup.fire(o); throw this.clear(), r } this._onDidLayoutfromJSON.fire() } clear() { const e = this.activeGroup, i = Array.from(this._groups.values()); for (const n of i) n.disposable.dispose(), this.doRemoveGroup(n.value, { skipActive: !0 }); e && this.doSetGroupActive(void 0), this.gridview.clear() } movePanel(e, i) { var n; let r; const o = this.gridview.remove(e), s = (n = this._groups.get(i.reference)) === null || n === void 0 ? void 0 : n.value; if (!s) throw new Error(`reference group ${i.reference} does not exist`); const l = Jr(i.direction); if (l === "center") throw new Error(`${l} not supported as an option`); { const a = q(s.element); r = ot(this.gridview.orientation, a, l) } this.doAddGroup(o, r, i.size) } addPanel(e) { var i, n, r, o, s, l; let a = (i = e.location) !== null && i !== void 0 ? i : [0]; if (!((n = e.position) === null || n === void 0) && n.referencePanel) { const m = (r = this._groups.get(e.position.referencePanel)) === null || r === void 0 ? void 0 : r.value; if (!m) throw new Error(`reference group ${e.position.referencePanel} does not exist`); const d = Jr(e.position.direction); if (d === "center") throw new Error(`${d} not supported as an option`); { const c = q(m.element); a = ot(this.gridview.orientation, c, d) } } const u = je(e.id, e.component, (o = this.options.components) !== null && o !== void 0 ? o : {}, (s = this.options.frameworkComponents) !== null && s !== void 0 ? s : {}, this.options.frameworkComponentFactory ? { createComponent: this.options.frameworkComponentFactory.createComponent } : void 0); return u.init({ params: (l = e.params) !== null && l !== void 0 ? l : {}, minimumWidth: e.minimumWidth, maximumWidth: e.maximumWidth, minimumHeight: e.minimumHeight, maximumHeight: e.maximumHeight, priority: e.priority, snap: !!e.snap, accessor: this, isVisible: !0 }), this.registerPanel(u), this.doAddGroup(u, a, e.size), this.doSetGroupActive(u), u } registerPanel(e) { const i = new V(e.api.onDidFocusChange(n => { n.isFocused && this._groups.forEach(r => { const o = r.value; o !== e ? o.setActive(!1) : o.setActive(!0) }) })); this._groups.set(e.id, { value: e, disposable: i }) } moveGroup(e, i, n) { const r = this.getPanel(i); if (!r) throw new Error("invalid operation"); const o = q(e.element), s = ot(this.gridview.orientation, o, n), [l, a] = vt(s), u = q(r.element), [m, d] = vt(u); if (Ph(m, l)) { this.gridview.moveView(m, d, a); return } const c = this.doRemoveGroup(r, { skipActive: !0, skipDispose: !0 }), v = q(e.element), g = ot(this.gridview.orientation, v, n); this.doAddGroup(c, g) } removeGroup(e) { super.removeGroup(e) } dispose() { super.dispose(), this._onDidLayoutfromJSON.dispose() } } class mm extends Gl { get panels() { return this.splitview.getViews() } get options() { return this._options } get length() { return this._panels.size } get orientation() { return this.splitview.orientation } get splitview() { return this._splitview } set splitview(e) { this._splitview = e, this._splitviewChangeDisposable.value = new V(this._splitview.onDidSashEnd(() => { this._onDidLayoutChange.fire(void 0) }), this._splitview.onDidAddView(i => this._onDidAddView.fire(i)), this._splitview.onDidRemoveView(i => this._onDidRemoveView.fire(i))) } get minimumSize() { return this.splitview.minimumSize } get maximumSize() { return this.splitview.maximumSize } get height() { return this.splitview.orientation === I.HORIZONTAL ? this.splitview.orthogonalSize : this.splitview.size } get width() { return this.splitview.orientation === I.HORIZONTAL ? this.splitview.size : this.splitview.orthogonalSize } constructor(e) { super(e.parentElement, e.disableAutoResizing), this._splitviewChangeDisposable = new Qe, this._panels = new Map, this._onDidLayoutfromJSON = new _, this.onDidLayoutFromJSON = this._onDidLayoutfromJSON.event, this._onDidAddView = new _, this.onDidAddView = this._onDidAddView.event, this._onDidRemoveView = new _, this.onDidRemoveView = this._onDidRemoveView.event, this._onDidLayoutChange = new _, this.onDidLayoutChange = this._onDidLayoutChange.event, this._options = e, e.components || (e.components = {}), e.frameworkComponents || (e.frameworkComponents = {}), this.splitview = new Rn(this.element, e), this.addDisposables(this._onDidAddView, this._onDidLayoutfromJSON, this._onDidRemoveView, this._onDidLayoutChange) } updateOptions(e) { const i = typeof e.orientation == "string" && this.options.orientation !== e.orientation; this._options = Object.assign(Object.assign({}, this.options), e), i && (this.splitview.orientation = e.orientation), this.splitview.layout(this.splitview.size, this.splitview.orthogonalSize) } focus() { var e; (e = this._activePanel) === null || e === void 0 || e.focus() } movePanel(e, i) { this.splitview.moveView(e, i) } setVisible(e, i) { const n = this.panels.indexOf(e); this.splitview.setViewVisible(n, i) } setActive(e, i) { this._activePanel = e, this.panels.filter(n => n !== e).forEach(n => { n.api._onDidActiveChange.fire({ isActive: !1 }), i || n.focus() }), e.api._onDidActiveChange.fire({ isActive: !0 }), i || e.focus() } removePanel(e, i) { const n = this._panels.get(e.id); if (!n) throw new Error(`unknown splitview panel ${e.id}`); n.dispose(), this._panels.delete(e.id); const r = this.panels.findIndex(l => l === e); this.splitview.removeView(r, i).dispose(); const s = this.panels; s.length > 0 && this.setActive(s[s.length - 1]) } getPanel(e) { return this.panels.find(i => i.id === e) } addPanel(e) { var i, n, r; if (this._panels.has(e.id)) throw new Error(`panel ${e.id} already exists`); const o = je(e.id, e.component, (i = this.options.components) !== null && i !== void 0 ? i : {}, (n = this.options.frameworkComponents) !== null && n !== void 0 ? n : {}, this.options.frameworkWrapper ? { createComponent: this.options.frameworkWrapper.createComponent } : void 0); o.orientation = this.splitview.orientation, o.init({ params: (r = e.params) !== null && r !== void 0 ? r : {}, minimumSize: e.minimumSize, maximumSize: e.maximumSize, snap: e.snap, priority: e.priority, accessor: this }); const s = typeof e.size == "number" ? e.size : Le.Distribute, l = typeof e.index == "number" ? e.index : void 0; return this.splitview.addView(o, s, l), this.doAddView(o), this.setActive(o), o } layout(e, i) { const [n, r] = this.splitview.orientation === I.HORIZONTAL ? [e, i] : [i, e]; this.splitview.layout(n, r) } doAddView(e) { const i = e.api.onDidFocusChange(n => { n.isFocused && this.setActive(e, !0) }); this._panels.set(e.id, i) } toJSON() { var e; return { views: this.splitview.getViews().map((n, r) => ({ size: this.splitview.getViewSize(r), data: n.toJSON(), snap: !!n.snap, priority: n.priority })), activeView: (e = this._activePanel) === null || e === void 0 ? void 0 : e.id, size: this.splitview.size, orientation: this.splitview.orientation } } fromJSON(e) { this.clear(); const { views: i, orientation: n, size: r, activeView: o } = e, s = [], l = this.width, a = this.height; if (this.splitview = new Rn(this.element, { orientation: n, proportionalLayout: this.options.proportionalLayout, descriptor: { size: r, views: i.map(u => { var m, d; const c = u.data; if (this._panels.has(c.id)) throw new Error(`panel ${c.id} already exists`); const v = je(c.id, c.component, (m = this.options.components) !== null && m !== void 0 ? m : {}, (d = this.options.frameworkComponents) !== null && d !== void 0 ? d : {}, this.options.frameworkWrapper ? { createComponent: this.options.frameworkWrapper.createComponent } : void 0); return s.push(() => { var g; v.init({ params: (g = c.params) !== null && g !== void 0 ? g : {}, minimumSize: c.minimumSize, maximumSize: c.maximumSize, snap: u.snap, priority: u.priority, accessor: this }) }), v.orientation = n, this.doAddView(v), setTimeout(() => { this._onDidAddView.fire(v) }, 0), { size: u.size, view: v } }) } }), this.layout(l, a), s.forEach(u => u()), typeof o == "string") { const u = this.getPanel(o); u && this.setActive(u) } this._onDidLayoutfromJSON.fire() } clear() { for (const e of this._panels.values()) e.dispose(); for (this._panels.clear(); this.splitview.length > 0;)this.splitview.removeView(0, Le.Distribute, !0).dispose() } dispose() { for (const i of this._panels.values()) i.dispose(); this._panels.clear(); const e = this.splitview.getViews(); this._splitviewChangeDisposable.dispose(), this.splitview.dispose(); for (const i of e) i.dispose(); super.dispose() } } class ru extends V { get element() { return this._element } constructor() { super(), this._expandedIcon = nm(), this._collapsedIcon = rm(), this.disposable = new Qe, this.apiRef = { api: null }, this._element = document.createElement("div"), this.element.className = "default-header", this._content = document.createElement("span"), this._expander = document.createElement("div"), this._expander.className = "dockview-pane-header-icon", this.element.appendChild(this._expander), this.element.appendChild(this._content), this.addDisposables($(this._element, "click", () => { var e; (e = this.apiRef.api) === null || e === void 0 || e.setExpanded(!this.apiRef.api.isExpanded) })) } init(e) { this.apiRef.api = e.api, this._content.textContent = e.title, this.updateIcon(), this.disposable.value = e.api.onDidExpansionChange(() => { this.updateIcon() }) } updateIcon() { var e; const i = !!(!((e = this.apiRef.api) === null || e === void 0) && e.isExpanded); G(this._expander, "collapsed", !i), i ? (this._expander.contains(this._collapsedIcon) && this._collapsedIcon.remove(), this._expander.contains(this._expandedIcon) || this._expander.appendChild(this._expandedIcon)) : (this._expander.contains(this._expandedIcon) && this._expandedIcon.remove(), this._expander.contains(this._collapsedIcon) || this._expander.appendChild(this._collapsedIcon)) } update(e) { } dispose() { this.disposable.dispose(), super.dispose() } } const vm = Ll(); class ou extends Qf { constructor(e) { super(e.accessor, e.id, e.component, e.headerComponent, e.orientation, e.isExpanded, e.disableDnd), this.options = e } getBodyComponent() { return this.options.body } getHeaderComponent() { return this.options.header } } class gm extends Gl { get id() { return this._id } get panels() { return this.paneview.getPanes() } set paneview(e) { this._paneview = e, this._disposable.value = new V(this._paneview.onDidChange(() => { this._onDidLayoutChange.fire(void 0) }), this._paneview.onDidAddView(i => this._onDidAddView.fire(i)), this._paneview.onDidRemoveView(i => this._onDidRemoveView.fire(i))) } get paneview() { return this._paneview } get minimumSize() { return this.paneview.minimumSize } get maximumSize() { return this.paneview.maximumSize } get height() { return this.paneview.orientation === I.HORIZONTAL ? this.paneview.orthogonalSize : this.paneview.size } get width() { return this.paneview.orientation === I.HORIZONTAL ? this.paneview.size : this.paneview.orthogonalSize } get options() { return this._options } constructor(e) { super(e.parentElement, e.disableAutoResizing), this._id = vm.next(), this._disposable = new Qe, this._viewDisposables = new Map, this._onDidLayoutfromJSON = new _, this.onDidLayoutFromJSON = this._onDidLayoutfromJSON.event, this._onDidLayoutChange = new _, this.onDidLayoutChange = this._onDidLayoutChange.event, this._onDidDrop = new _, this.onDidDrop = this._onDidDrop.event, this._onDidAddView = new _, this.onDidAddView = this._onDidAddView.event, this._onDidRemoveView = new _, this.onDidRemoveView = this._onDidRemoveView.event, this.addDisposables(this._onDidLayoutChange, this._onDidLayoutfromJSON, this._onDidDrop, this._onDidAddView, this._onDidRemoveView), this._options = e, e.components || (e.components = {}), e.frameworkComponents || (e.frameworkComponents = {}), this.paneview = new Xa(this.element, { orientation: I.VERTICAL }), this.addDisposables(this._disposable) } setVisible(e, i) { const n = this.panels.indexOf(e); this.paneview.setViewVisible(n, i) } focus() { } updateOptions(e) { this._options = Object.assign(Object.assign({}, this.options), e) } addPanel(e) { var i, n, r, o; const s = je(e.id, e.component, (i = this.options.components) !== null && i !== void 0 ? i : {}, (n = this.options.frameworkComponents) !== null && n !== void 0 ? n : {}, this.options.frameworkWrapper ? { createComponent: this.options.frameworkWrapper.body.createComponent } : void 0); let l; e.headerComponent ? l = je(e.id, e.headerComponent, (r = this.options.headerComponents) !== null && r !== void 0 ? r : {}, this.options.headerframeworkComponents, this.options.frameworkWrapper ? { createComponent: this.options.frameworkWrapper.header.createComponent } : void 0) : l = new ru; const a = new ou({ id: e.id, component: e.component, headerComponent: e.headerComponent, header: l, body: s, orientation: I.VERTICAL, isExpanded: !!e.isExpanded, disableDnd: !!this.options.disableDnd, accessor: this }); this.doAddPanel(a); const u = typeof e.size == "number" ? e.size : Le.Distribute, m = typeof e.index == "number" ? e.index : void 0; return a.init({ params: (o = e.params) !== null && o !== void 0 ? o : {}, minimumBodySize: e.minimumBodySize, maximumBodySize: e.maximumBodySize, isExpanded: e.isExpanded, title: e.title, containerApi: new Wi(this), accessor: this }), this.paneview.addPane(a, u, m), a.orientation = this.paneview.orientation, a } removePanel(e) { const n = this.panels.findIndex(r => r === e); this.paneview.removePane(n), this.doRemovePanel(e) } movePanel(e, i) { this.paneview.moveView(e, i) } getPanel(e) { return this.panels.find(i => i.id === e) } layout(e, i) { const [n, r] = this.paneview.orientation === I.HORIZONTAL ? [e, i] : [i, e]; this.paneview.layout(n, r) } toJSON() { const e = r => r === Number.MAX_SAFE_INTEGER || r === Number.POSITIVE_INFINITY ? void 0 : r, i = r => r <= 0 ? void 0 : r; return { views: this.paneview.getPanes().map((r, o) => ({ size: this.paneview.getViewSize(o), data: r.toJSON(), minimumSize: i(r.minimumBodySize), maximumSize: e(r.maximumBodySize), expanded: r.isExpanded() })), size: this.paneview.size } } fromJSON(e) { this.clear(); const { views: i, size: n } = e, r = [], o = this.width, s = this.height; this.paneview = new Xa(this.element, { orientation: I.VERTICAL, descriptor: { size: n, views: i.map(l => { var a, u, m, d; const c = l.data, v = je(c.id, c.component, (a = this.options.components) !== null && a !== void 0 ? a : {}, (u = this.options.frameworkComponents) !== null && u !== void 0 ? u : {}, this.options.frameworkWrapper ? { createComponent: this.options.frameworkWrapper.body.createComponent } : void 0); let g; c.headerComponent ? g = je(c.id, c.headerComponent, (m = this.options.headerComponents) !== null && m !== void 0 ? m : {}, (d = this.options.headerframeworkComponents) !== null && d !== void 0 ? d : {}, this.options.frameworkWrapper ? { createComponent: this.options.frameworkWrapper.header.createComponent } : void 0) : g = new ru; const w = new ou({ id: c.id, component: c.component, headerComponent: c.headerComponent, header: g, body: v, orientation: I.VERTICAL, isExpanded: !!l.expanded, disableDnd: !!this.options.disableDnd, accessor: this }); return this.doAddPanel(w), r.push(() => { var C; w.init({ params: (C = c.params) !== null && C !== void 0 ? C : {}, minimumBodySize: l.minimumSize, maximumBodySize: l.maximumSize, title: c.title, isExpanded: !!l.expanded, containerApi: new Wi(this), accessor: this }), w.orientation = this.paneview.orientation }), setTimeout(() => { this._onDidAddView.fire(w) }, 0), { size: l.size, view: w } }) } }), this.layout(o, s), r.forEach(l => l()), this._onDidLayoutfromJSON.fire() } clear() { for (const [e, i] of this._viewDisposables.entries()) i.dispose(); this._viewDisposables.clear(), this.paneview.dispose() } doAddPanel(e) { const i = e.onDidDrop(n => { this._onDidDrop.fire(n) }); this._viewDisposables.set(e.id, i) } doRemovePanel(e) { const i = this._viewDisposables.get(e.id); i && (i.dispose(), this._viewDisposables.delete(e.id)) } dispose() { super.dispose(); for (const [e, i] of this._viewDisposables.entries()) i.dispose(); this._viewDisposables.clear(), this.paneview.dispose() } } class wm extends Vl { get priority() { return this._priority } set orientation(e) { this._orientation = e } get orientation() { return this._orientation } get minimumSize() { const e = typeof this._minimumSize == "function" ? this._minimumSize() : this._minimumSize; return e !== this._evaluatedMinimumSize && (this._evaluatedMinimumSize = e, this.updateConstraints()), e } get maximumSize() { const e = typeof this._maximumSize == "function" ? this._maximumSize() : this._maximumSize; return e !== this._evaluatedMaximumSize && (this._evaluatedMaximumSize = e, this.updateConstraints()), e } get snap() { return this._snap } constructor(e, i) { super(e, i, new Gh(e, i)), this._evaluatedMinimumSize = 0, this._evaluatedMaximumSize = Number.POSITIVE_INFINITY, this._minimumSize = 0, this._maximumSize = Number.POSITIVE_INFINITY, this._snap = !1, this._onDidChange = new _, this.onDidChange = this._onDidChange.event, this.api.initialize(this), this.addDisposables(this._onDidChange, this.api.onWillVisibilityChange(n => { const { isVisible: r } = n, { accessor: o } = this._params; o.setVisible(this, r) }), this.api.onActiveChange(() => { const { accessor: n } = this._params; n.setActive(this) }), this.api.onDidConstraintsChangeInternal(n => { (typeof n.minimumSize == "number" || typeof n.minimumSize == "function") && (this._minimumSize = n.minimumSize), (typeof n.maximumSize == "number" || typeof n.maximumSize == "function") && (this._maximumSize = n.maximumSize), this.updateConstraints() }), this.api.onDidSizeChange(n => { this._onDidChange.fire({ size: n.size }) })) } setVisible(e) { this.api._onDidVisibilityChange.fire({ isVisible: e }) } setActive(e) { this.api._onDidActiveChange.fire({ isActive: e }) } layout(e, i) { const [n, r] = this.orientation === I.HORIZONTAL ? [e, i] : [i, e]; super.layout(n, r) } init(e) { super.init(e), this._priority = e.priority, e.minimumSize && (this._minimumSize = e.minimumSize), e.maximumSize && (this._maximumSize = e.maximumSize), e.snap && (this._snap = e.snap) } toJSON() { const e = n => n === Number.MAX_SAFE_INTEGER || n === Number.POSITIVE_INFINITY ? void 0 : n, i = n => n <= 0 ? void 0 : n; return Object.assign(Object.assign({}, super.toJSON()), { minimumSize: i(this.minimumSize), maximumSize: e(this.maximumSize) }) } updateConstraints() { this.api._onDidConstraintsChange.fire({ maximumSize: this._evaluatedMaximumSize, minimumSize: this._evaluatedMinimumSize }) } } const Wh = (t, e) => { const [i, n] = A.useState(), r = A.useRef(t.componentProps); return A.useImperativeHandle(e, () => ({ update: o => { r.current = Object.assign(Object.assign({}, r.current), o), n(Date.now()) } }), []), A.createElement(t.component, r.current) }; Wh.displayName = "DockviewReactJsBridge"; const _m = (() => { let t = 1; return { next: () => `dockview_react_portal_key_${(t++).toString()}` } })(), ym = A.createContext({}); class hi { constructor(e, i, n, r, o) { this.parent = e, this.portalStore = i, this.component = n, this.parameters = r, this.context = o, this._initialProps = {}, this.disposed = !1, this.createPortal() } update(e) { if (this.disposed) throw new Error("invalid operation: resource is already disposed"); this.componentInstance ? this.componentInstance.update(e) : this._initialProps = Object.assign(Object.assign({}, this._initialProps), e) } createPortal() { if (this.disposed) throw new Error("invalid operation: resource is already disposed"); if (!Dm(this.component)) throw new Error("Dockview: Only React.memo(...), React.ForwardRef(...) and functional components are accepted as components"); const e = A.createElement(A.forwardRef(Wh), { component: this.component, componentProps: this.parameters, ref: r => { this.componentInstance = r, Object.keys(this._initialProps).length > 0 && (this.componentInstance.update(this._initialProps), this._initialProps = {}) } }), i = this.context ? A.createElement(ym.Provider, { value: this.context }, e) : e, n = pf.createPortal(i, this.parent, _m.next()); this.ref = { portal: n, disposable: this.portalStore.addPortal(n) } } dispose() { var e; (e = this.ref) === null || e === void 0 || e.disposable.dispose(), this.disposed = !0 } } const co = () => { const [t, e] = A.useState([]); A.useDebugValue(`Portal count: ${t.length}`); const i = A.useCallback(n => { e(o => [...o, n]); let r = !1; return { dispose: () => { if (r) throw new Error("invalid operation: resource already disposed"); r = !0, e(o => o.filter(s => s !== n)) } } }, []); return [t, i] }; function Dm(t) { return typeof t == "function" || !!(t != null && t.$$typeof) } class Cm { get element() { return this._element } constructor(e, i, n) { this.id = e, this.component = i, this.reactPortalStore = n, this._onDidFocus = new _, this.onDidFocus = this._onDidFocus.event, this._onDidBlur = new _, this.onDidBlur = this._onDidBlur.event, this._element = document.createElement("div"), this._element.className = "dockview-react-part", this._element.style.height = "100%", this._element.style.width = "100%" } focus() { } init(e) { this.part = new hi(this.element, this.reactPortalStore, this.component, { params: e.params, api: e.api, containerApi: e.containerApi }) } update(e) { var i; (i = this.part) === null || i === void 0 || i.update(e.params) } layout(e, i) { } dispose() { var e; this._onDidFocus.dispose(), this._onDidBlur.dispose(), (e = this.part) === null || e === void 0 || e.dispose() } } class Sm { get element() { return this._element } constructor(e, i, n) { this.id = e, this.component = i, this.reactPortalStore = n, this._element = document.createElement("div"), this._element.className = "dockview-react-part", this._element.style.height = "100%", this._element.style.width = "100%" } focus() { } init(e) { this.part = new hi(this.element, this.reactPortalStore, this.component, { params: e.params, api: e.api, containerApi: e.containerApi }) } update(e) { var i; (i = this.part) === null || i === void 0 || i.update(e.params) } layout(e, i) { } dispose() { var e; (e = this.part) === null || e === void 0 || e.dispose() } } class Em { get element() { return this._element } constructor(e, i, n) { this.id = e, this.component = i, this.reactPortalStore = n, this._element = document.createElement("div"), this._element.className = "dockview-react-part", this._element.style.height = "100%", this._element.style.width = "100%" } init(e) { this.part = new hi(this.element, this.reactPortalStore, this.component, { group: e.group, containerApi: e.containerApi, close: () => { e.group && e.containerApi.removeGroup(e.group) } }) } focus() { } update(e) { var i, n, r; this.parameters && (this.parameters.params = e.params), (i = this.part) === null || i === void 0 || i.update({ params: (r = (n = this.parameters) === null || n === void 0 ? void 0 : n.params) !== null && r !== void 0 ? r : {} }) } layout(e, i) { } updateParentGroup(e, i) { } dispose() { var e; (e = this.part) === null || e === void 0 || e.dispose() } } class xm { get element() { return this._element } get part() { return this._part } get group() { return this._group } constructor(e, i, n) { this.component = e, this.reactPortalStore = i, this._group = n, this.mutableDisposable = new Qe, this._element = document.createElement("div"), this._element.className = "dockview-react-part", this._element.style.height = "100%", this._element.style.width = "100%" } focus() { } init(e) { this.mutableDisposable.value = new V(this._group.model.onDidAddPanel(() => { this.updatePanels() }), this._group.model.onDidRemovePanel(() => { this.updatePanels() }), this._group.model.onDidActivePanelChange(() => { this.updateActivePanel() }), e.api.onDidActiveChange(() => { this.updateGroupActive() })), this._part = new hi(this.element, this.reactPortalStore, this.component, { api: e.api, containerApi: e.containerApi, panels: this._group.model.panels, activePanel: this._group.model.activePanel, isGroupActive: this._group.api.isActive, group: this._group }) } update(e) { var i; (i = this._part) === null || i === void 0 || i.update(e.params) } dispose() { var e; this.mutableDisposable.dispose(), (e = this._part) === null || e === void 0 || e.dispose() } updatePanels() { this.update({ params: { panels: this._group.model.panels } }) } updateActivePanel() { this.update({ params: { activePanel: this._group.model.activePanel } }) } updateGroupActive() { this.update({ params: { isGroupActive: this._group.api.isActive } }) } } function pi(t, e) { return t ? i => new xm(t, e, i) : void 0 } const ar = "props.defaultTabComponent", Hh = A.forwardRef((t, e) => { const i = A.useRef(null), n = A.useRef(), [r, o] = co(); return A.useImperativeHandle(e, () => i.current, []), A.useEffect(() => { var s; if (!i.current) return () => { }; const l = { content: { createComponent: (c, v, g) => new Cm(v, g, { addPortal: o }) }, tab: { createComponent: (c, v, g) => new Sm(v, g, { addPortal: o }) }, watermark: { createComponent: (c, v, g) => new Em(v, g, { addPortal: o }) } }, a = (s = t.tabComponents) !== null && s !== void 0 ? s : {}; t.defaultTabComponent && (a[ar] = t.defaultTabComponent); const u = new pm({ parentElement: i.current, frameworkComponentFactory: l, frameworkComponents: t.components, disableAutoResizing: t.disableAutoResizing, frameworkTabComponents: a, watermarkFrameworkComponent: t.watermarkComponent, defaultTabComponent: t.defaultTabComponent ? ar : void 0, styles: t.hideBorders ? { separatorBorder: "transparent" } : void 0, showDndOverlay: t.showDndOverlay, createLeftHeaderActionsElement: pi(t.leftHeaderActionsComponent, { addPortal: o }), createRightHeaderActionsElement: pi(t.rightHeaderActionsComponent, { addPortal: o }), createPrefixHeaderActionsElement: pi(t.prefixHeaderActionsComponent, { addPortal: o }), singleTabMode: t.singleTabMode, disableFloatingGroups: t.disableFloatingGroups, floatingGroupBounds: t.floatingGroupBounds, defaultRenderer: t.defaultRenderer, debug: t.debug, rootOverlayModel: t.rootOverlayModel, locked: t.locked, disableDnd: t.disableDnd }), { clientWidth: m, clientHeight: d } = i.current; return u.layout(m, d), t.onReady && t.onReady({ api: new Tn(u) }), n.current = u, () => { u.dispose() } }, []), A.useEffect(() => { n.current && (n.current.locked = !!t.locked) }, [t.locked]), A.useEffect(() => { n.current && n.current.updateOptions({ disableDnd: t.disableDnd }) }, [t.disableDnd]), A.useEffect(() => { if (!n.current) return () => { }; const s = n.current.onDidDrop(l => { t.onDidDrop && t.onDidDrop(l) }); return () => { s.dispose() } }, [t.onDidDrop]), A.useEffect(() => { if (!n.current) return () => { }; const s = n.current.onWillDrop(l => { t.onWillDrop && t.onWillDrop(l) }); return () => { s.dispose() } }, [t.onWillDrop]), A.useEffect(() => { n.current && n.current.updateOptions({ frameworkComponents: t.components }) }, [t.components]), A.useEffect(() => { n.current && n.current.updateOptions({ floatingGroupBounds: t.floatingGroupBounds }) }, [t.floatingGroupBounds]), A.useEffect(() => { n.current && n.current.updateOptions({ watermarkFrameworkComponent: t.watermarkComponent }) }, [t.watermarkComponent]), A.useEffect(() => { n.current && n.current.updateOptions({ showDndOverlay: t.showDndOverlay }) }, [t.showDndOverlay]), A.useEffect(() => { n.current && n.current.updateOptions({ frameworkTabComponents: t.tabComponents }) }, [t.tabComponents]), A.useEffect(() => { n.current && n.current.updateOptions({ disableFloatingGroups: t.disableFloatingGroups }) }, [t.disableFloatingGroups]), A.useEffect(() => { var s; if (!n.current) return; const l = (s = t.tabComponents) !== null && s !== void 0 ? s : {}; t.defaultTabComponent && (l[ar] = t.defaultTabComponent), n.current.updateOptions({ defaultTabComponent: t.defaultTabComponent ? ar : void 0, frameworkTabComponents: l }) }, [t.defaultTabComponent]), A.useEffect(() => { n.current && n.current.updateOptions({ createRightHeaderActionsElement: pi(t.rightHeaderActionsComponent, { addPortal: o }) }) }, [t.rightHeaderActionsComponent]), A.useEffect(() => { n.current && n.current.updateOptions({ createLeftHeaderActionsElement: pi(t.leftHeaderActionsComponent, { addPortal: o }) }) }, [t.leftHeaderActionsComponent]), A.useEffect(() => { n.current && n.current.updateOptions({ rootOverlayModel: t.rootOverlayModel }) }, [t.rootOverlayModel]), A.useEffect(() => { n.current && n.current.updateOptions({ createPrefixHeaderActionsElement: pi(t.prefixHeaderActionsComponent, { addPortal: o }) }) }, [t.prefixHeaderActionsComponent]), A.createElement("div", { className: t.className, style: { height: "100%", width: "100%" }, ref: i }, r) }); Hh.displayName = "DockviewComponent"; class km extends wm { constructor(e, i, n, r) { super(e, i), this.reactComponent = n, this.reactPortalStore = r } getComponent() { var e, i; return new hi(this.element, this.reactPortalStore, this.reactComponent, { params: (i = (e = this._params) === null || e === void 0 ? void 0 : e.params) !== null && i !== void 0 ? i : {}, api: this.api, containerApi: new Ah(this._params.accessor) }) } } const Pm = A.forwardRef((t, e) => { const i = A.useRef(null), n = A.useRef(), [r, o] = co(); return A.useImperativeHandle(e, () => i.current, []), A.useEffect(() => { var s; const l = new mm({ parentElement: i.current, disableAutoResizing: t.disableAutoResizing, orientation: (s = t.orientation) !== null && s !== void 0 ? s : I.HORIZONTAL, frameworkComponents: t.components, frameworkWrapper: { createComponent: (m, d, c) => new km(m, d, c, { addPortal: o }) }, proportionalLayout: typeof t.proportionalLayout == "boolean" ? t.proportionalLayout : !0, styles: t.hideBorders ? { separatorBorder: "transparent" } : void 0 }), { clientWidth: a, clientHeight: u } = i.current; return l.layout(a, u), t.onReady && t.onReady({ api: new Ah(l) }), n.current = l, () => { l.dispose() } }, []), A.useEffect(() => { n.current && n.current.updateOptions({ frameworkComponents: t.components }) }, [t.components]), A.createElement("div", { className: t.className, style: { height: "100%", width: "100%" }, ref: i }, r) }); Pm.displayName = "SplitviewComponent"; class zm extends Vh { constructor(e, i, n, r) { super(e, i), this.reactComponent = n, this.reactPortalStore = r } getComponent() { var e, i; return new hi(this.element, this.reactPortalStore, this.reactComponent, { params: (i = (e = this._params) === null || e === void 0 ? void 0 : e.params) !== null && i !== void 0 ? i : {}, api: this.api, containerApi: new Ih(this._params.accessor) }) } } const Am = A.forwardRef((t, e) => { const i = A.useRef(null), n = A.useRef(), [r, o] = co(); return A.useImperativeHandle(e, () => i.current, []), A.useEffect(() => { var s; if (!i.current) return () => { }; const l = new fm({ parentElement: i.current, disableAutoResizing: t.disableAutoResizing, proportionalLayout: typeof t.proportionalLayout == "boolean" ? t.proportionalLayout : !0, orientation: (s = t.orientation) !== null && s !== void 0 ? s : I.HORIZONTAL, frameworkComponents: t.components, frameworkComponentFactory: { createComponent: (m, d, c) => new zm(m, d, c, { addPortal: o }) }, styles: t.hideBorders ? { separatorBorder: "transparent" } : void 0 }), { clientWidth: a, clientHeight: u } = i.current; return l.layout(a, u), t.onReady && t.onReady({ api: new Ih(l) }), n.current = l, () => { l.dispose() } }, []), A.useEffect(() => { n.current && n.current.updateOptions({ frameworkComponents: t.components }) }, [t.components]), A.createElement("div", { className: t.className, style: { height: "100%", width: "100%" }, ref: i }, r) }); Am.displayName = "GridviewComponent"; class Im { get element() { return this._element } constructor(e, i, n) { this.id = e, this.component = i, this.reactPortalStore = n, this._element = document.createElement("div"), this._element.style.height = "100%", this._element.style.width = "100%" } init(e) { this.part = new hi(this.element, this.reactPortalStore, this.component, { params: e.params, api: e.api, title: e.title, containerApi: e.containerApi }) } toJSON() { return { id: this.id } } update(e) { var i; (i = this.part) === null || i === void 0 || i.update(e.params) } dispose() { var e; (e = this.part) === null || e === void 0 || e.dispose() } } const Nm = A.forwardRef((t, e) => { const i = A.useRef(null), n = A.useRef(), [r, o] = co(); return A.useImperativeHandle(e, () => i.current, []), A.useEffect(() => { const s = (d, c, v) => new Im(d, v, { addPortal: o }), l = new gm({ parentElement: i.current, disableAutoResizing: t.disableAutoResizing, frameworkComponents: t.components, components: {}, headerComponents: {}, disableDnd: t.disableDnd, headerframeworkComponents: t.headerComponents, frameworkWrapper: { header: { createComponent: s }, body: { createComponent: s } }, showDndOverlay: t.showDndOverlay }), a = new Wi(l), { clientWidth: u, clientHeight: m } = i.current; return l.layout(u, m), t.onReady && t.onReady({ api: a }), n.current = l, () => { l.dispose() } }, []), A.useEffect(() => { n.current && n.current.updateOptions({ frameworkComponents: t.components }) }, [t.components]), A.useEffect(() => { n.current && n.current.updateOptions({ headerframeworkComponents: t.headerComponents }) }, [t.headerComponents]), A.useEffect(() => { if (!n.current) return () => { }; const s = n.current, l = s.onDidDrop(a => { t.onDidDrop && t.onDidDrop(Object.assign(Object.assign({}, a), { api: new Wi(s) })) }); return () => { l.dispose() } }, [t.onDidDrop]), A.useEffect(() => { n.current && n.current.updateOptions({ showDndOverlay: t.showDndOverlay }) }, [t.showDndOverlay]), A.createElement("div", { className: t.className, style: { height: "100%", width: "100%" }, ref: i }, r) }); Nm.displayName = "PaneviewComponent"; const Om = () => { const [t, e] = At.useState([{ text: "Hello! How can I assist you today?", sender: "bot" }]), [i, n] = At.useState(""), [r, o] = At.useState([]), [s, l] = At.useState([]), a = () => { i.trim() !== "" && (e(d => [...d, { text: i, sender: "user" }]), m(), console.log(JSON.stringify({ prompt: i })), fetch("http://localhost:8000/api/v1/prompt", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ prompt: i }) }).then(d => d.json()).then(d => { e(c => [...c, { text: d.prompt, sender: "bot" }]) }).catch(d => { console.error("Error:", d) })) }, u = d => { d.target.files && (o(Array.from(d.target.files)), l(Array.from(d.target.files).map(c => c.name))) }, m = () => { if (r.length === 0) return; const d = new FormData; r.forEach((c, v) => { d.append("files", c) }), fetch("http://localhost:8000/api/v1/upload", { method: "POST", body: d }).then(c => c.json()).catch(c => { console.error("Error:", c) }) }; return ie.jsxs("div", { className: "chatbot-container", children: [ie.jsx("div", { className: "messages-container", children: t.map((d, c) => ie.jsx("div", { className: `message ${d.sender}`, children: d.text }, d.sender + c)) }), ie.jsx("input", { type: "text", className: "input-field", value: i, onChange: d => n(d.target.value), placeholder: "Type your message...", onKeyPress: d => { d.key === "Enter" && a() } }), ie.jsx("button", { className: "send-button", onClick: a, children: "Send" }), ie.jsxs("div", { children: [ie.jsx("input", { type: "file", onChange: u, multiple: !0 }), ie.jsx("button", { onClick: m, children: "Upload" }), ie.jsx("ul", { children: s.map((d, c) => ie.jsx("li", { children: d }, d + c)) })] })] }) }, Lm = { dataViewer: t => ie.jsx("div", { style: { padding: 10 }, children: t.params.title }), graphViewer: t => ie.jsx("div", { style: { padding: 10 }, children: t.params.title }), taskViewer: t => ie.jsx("div", { style: { padding: 10 }, children: t.params.title }), chatViewer: t => ie.jsx(Om, {}) }, Rm = t => { const e = i => { i.api.addPanel({ id: "Data", component: "dataViewer", params: {} }), i.api.addPanel({ id: "Graph", component: "graphViewer", params: {}, position: { referencePanel: "Data", direction: "right" } }), i.api.addPanel({ id: "Task", component: "taskViewer", params: {}, position: { referencePanel: "Graph", direction: "right" } }), i.api.addPanel({ id: "Chat", component: "chatViewer", params: {}, position: { referencePanel: "Task", direction: "below" } }) }; return ie.jsx(Hh, { components: Lm, onReady: e, className: `${t.theme || "dockview-theme-abyss"}` }) }, Tm = t => ie.jsx("div", { className: "app", children: ie.jsx(Rm, { ...t }) }), su = document.getElementById("root"); su && Ch(su).render(ie.jsx(At.StrictMode, { children: ie.jsx("div", { className: "app", children: ie.jsx(Tm, {}) }) }));
